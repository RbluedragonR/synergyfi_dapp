import { BigNumber as e } from "@ethersproject/bignumber";
import { Contract as r } from "@ethersproject/contracts";
import { serialize as a } from "@ethersproject/transactions";
import { base as i } from "../../chains/base.js";
import { baseGoerli as t } from "../../chains/baseGoerli.js";
import { baseSepolia as o } from "../../chains/baseSepolia.js";
import { optimism as s } from "../../chains/optimism.js";
import { optimismGoerli as m } from "../../chains/optimismGoerli.js";
import { optimismSepolia as n } from "../../chains/optimismSepolia.js";
import { zora as c } from "../../chains/zora.js";
import { zoraSepolia as f } from "../../chains/zoraSepolia.js";
import { zoraTestnet as h } from "../../chains/zoraTestnet.js";
import {
  convertBigNumberish as P,
  toEthersUnsignedTransaction as p,
} from "../utils/ethers.js";
const d = 81457,
  l = 168587773,
  F = "0x420000000000000000000000000000000000000F",
  x = ["function getL1Fee(bytes memory _data) external view returns (uint256)"],
  G = (e) =>
    [i.id, t.id, o.id, s.id, m.id, n.id, c.id, h.id, f.id, d, l].includes(e),
  u = async (r, a) => {
    if (!G(r.chainId))
      throw new Error("Invalid chain ID for OP Stack gas estimation.");
    if (
      (void 0 === r.type && (r.type = 2),
      (r.maxPriorityFeePerGas && r.maxFeePerGas) || r.gasPrice)
    )
      return r;
    try {
      if (!r.maxPriorityFeePerGas) {
        const e = await a.send("eth_maxPriorityFeePerGas", []);
        r.maxPriorityFeePerGas = e;
      }
      if (
        r.maxFeePerGas &&
        (console.warn(
          "maxFeePerGas is specified without maxPriorityFeePerGas - this can result in hung transactions."
        ),
        r.maxPriorityFeePerGas >= r.maxFeePerGas)
      )
        throw new Error(
          "Overridden maxFeePerGas is less than or equal to the calculated maxPriorityFeePerGas. Please set both values or maxPriorityFeePerGas alone for correct gas estimation."
        );
      if (!r.maxFeePerGas) {
        const { lastBaseFeePerGas: i } = await a.getFeeData();
        if (!i) throw new Error("Unable to fetch baseFee for last block.");
        const t = e.from(i),
          o = t
            .mul(e.from(126))
            .div(e.from(100))
            .add(e.from(r.maxPriorityFeePerGas));
        r.maxFeePerGas = P(o);
      }
    } catch (e) {
      throw new Error(
        `Failed to set gas price for OP stack transaction: ${e}.`
      );
    }
    return r;
  };
async function y(i, t) {
  if (!i.chainId || (i.chainId && !G(i.chainId))) return e.from(0);
  let o = e.from(0);
  try {
    const e = new r(F, x, t),
      s = p(i),
      m = a(s);
    o = await e.getL1Fee(m);
  } catch (e) {}
  return o;
}
export {
  x as OPTIMISM_STACK_GAS_PRICE_ORACLE_ABI,
  F as OPTIMISM_STACK_GAS_PRICE_ORACLE_ADDRESS,
  u as defaultGasForOpStack,
  y as estimateOpStackL1Gas,
  G as isOpStack,
};
