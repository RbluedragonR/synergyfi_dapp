import { BigNumber as t } from "@ethersproject/bignumber";
import { PrivyProviderRpcError as e } from "../errors.js";
import { isOpStack as r, estimateOpStackL1Gas as s } from "../gas/op-stack.js";
import { QuantityToBigNumber as a } from "./ethers.js";
import "../types.js";
import "@ethersproject/contracts";
import "@ethersproject/transactions";
import "../../chains/base.js";
import "../../chains/baseGoerli.js";
import "../../chains/baseSepolia.js";
import "../../chains/optimism.js";
import "../../chains/optimismGoerli.js";
import "../../chains/optimismSepolia.js";
import "../../chains/zora.js";
import "../../chains/zoraSepolia.js";
import "../../chains/zoraTestnet.js";
const i = async (t, e) => {
  if ((void 0 === t.type && (t.type = 2), 2 === t.type)) {
    if (!t.maxFeePerGas || !t.maxPriorityFeePerGas) {
      const r = await e.getFeeData();
      t.maxFeePerGas || (t.maxFeePerGas = r.maxFeePerGas?.toHexString()),
        t.maxPriorityFeePerGas ||
          (t.maxPriorityFeePerGas = r.maxPriorityFeePerGas?.toHexString());
    }
  } else if (!t.gasPrice) {
    const r = await e.getFeeData();
    t.gasPrice = r.gasPrice?.toHexString();
  }
  return t;
};
async function o(i, o) {
  if (!i.gasLimit)
    throw new e("gasLimit was not successfully set for transaction.");
  const n = a(i.gasLimit);
  let m = t.from(0);
  if (2 == i.type) {
    if (!i.maxFeePerGas)
      throw new e(
        "maxFeePerGas was not successfully set for transaction of type 2."
      );
    m = a(i.maxFeePerGas);
  } else {
    if (!i.gasPrice)
      throw new e(
        "gasPrice was not successfully set for transaction of type 0 or 1."
      );
    m = a(i.gasPrice);
  }
  let c = n.mul(m),
    p = t.from(0);
  if (i.chainId && r(i.chainId))
    try {
      (p = await s(i, o)), (c = c.add(p));
    } catch (t) {}
  return { totalGasEstimate: c, l1ExecutionFeeEstimate: p };
}
async function n(t, e) {
  try {
    return (await e.estimateGas(t)).toHexString();
  } catch (r) {
    console.warn(
      `Gas estimation failed with error: ${r}. Retrying gas estimation by omitting the 'from' address`
    );
    try {
      const r = { ...t, from: void 0 };
      return (await e.estimateGas(r)).toHexString();
    } catch (t) {
      throw (
        (console.warn(
          `Gas estimation failed with error: ${t} when omitting the 'from' address`
        ),
        r)
      );
    }
  }
}
export {
  o as calculateTotalGasEstimate,
  i as defaultGasForEvmChain,
  n as defaultGasLimit,
};
