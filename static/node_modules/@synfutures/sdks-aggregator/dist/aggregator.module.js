"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AggregatorModule = void 0;
const ethers_1 = require("ethers");
const utils_1 = require("ethers/lib/utils");
const sdks_perp_1 = require("@synfutures/sdks-perp");
const typechain_1 = require("./typechain");
const context_1 = require("@derivation-tech/context");
const constants_1 = require("./constants");
const types_1 = require("./types");
const utils_2 = require("./utils");
class AggregatorModule {
  get querySingleRouteContract() {
    return typechain_1.QuerySingleRoute__factory.connect(
      constants_1.QUERY_SINGLE_ROUTE_ADDRESS[this.context.chainId] ??
        context_1.ZERO_ADDRESS,
      this.context.provider
    );
  }
  get querySplitRouteContract() {
    return typechain_1.QuerySplitRoute__factory.connect(
      constants_1.QUERY_SPLIT_ROUTE_ADDRESS[this.context.chainId] ??
        context_1.ZERO_ADDRESS,
      this.context.provider
    );
  }
  get oysterAggregator() {
    return typechain_1.OysterAggregator__factory.connect(
      constants_1.OYSTER_AGGREGATOR_ADDRESS[this.context.chainId] ??
        context_1.ZERO_ADDRESS,
      this.context.provider
    );
  }
  get config() {
    return typechain_1.Config__factory.connect(
      constants_1.CONFIG_ADDRESS[this.context.chainId] ??
        context_1.ZERO_ADDRESS,
      this.context.provider
    );
  }
  async getPoolList(token0Address, token1Address, excludePoolTypes = []) {
    const res = await this.config.callStatic.getPoolsWithFlag(
      token0Address,
      token1Address,
      (0, utils_2.getDexFlag)(excludePoolTypes)
    );
    return res;
  }
  async getPoolAdapter(poolType) {
    const res = this.poolAdapters.get(poolType);
    if (!res) {
      try {
        const poolAdapter = await this.config.getPoolAdapter(poolType);
        this.poolAdapters.set(poolType, poolAdapter);
        return poolAdapter;
      } catch (e) {
        throw new Error(
          `Pool adapter not found for pool type ${poolType}, reason: ${e}`
        );
      }
    }
    return res;
  }
  constructor(context) {
    this.poolAdapters = new Map();
    this.DEFAULT_GAS_LIMIT_MULTIPLE = 1.5;
    this.context = context;
  }
  async init() {
    if (this.config.address === context_1.ZERO_ADDRESS) {
      return;
    }
    const poolTypes = Object.values(types_1.PoolType).filter(
      (value) => !isNaN(Number(value))
    );
    const multicallCalls = poolTypes.map((poolType) => ({
      target: this.config.address,
      callData: this.config.interface.encodeFunctionData("getPoolAdapter", [
        poolType,
      ]),
    }));
    const multicallResults = (
      await this.context.multiCall3.callStatic.aggregate(multicallCalls)
    ).returnData;
    for (let i = 0; i < poolTypes.length; i++) {
      const decoded = this.config.interface.decodeFunctionResult(
        "getPoolAdapter",
        multicallResults[i]
      );
      this.poolAdapters.set(Number(poolTypes[i]), decoded[0]);
    }
  }
  async getMidPrices(params) {
    const res = await this.config.callStatic.getMidPrices(
      params.poolAddresses,
      params.poolTypes,
      params.isBuy
    );
    return {
      midPrices: res.prices,
      token0Balances: res.token0bals,
      token1Balances: res.token1bals,
    };
  }
  async getAmountsOut(params) {
    const res = await this.config.callStatic.getAmountsOut(
      params.pool,
      params.poolType,
      params.zeroForOne,
      params.amountsIn
    );
    return {
      amountsOut: res,
    };
  }
  async queryDirectRoute(params) {
    params.fromTokenAddress = (0, utils_2.toWrappedETH)(
      this.context,
      params.fromTokenAddress
    );
    params.toTokenAddress = (0, utils_2.toWrappedETH)(
      this.context,
      params.toTokenAddress
    );
    const res = await this.querySingleRouteContract.callStatic.querySingleRoute(
      params.fromTokenAddress,
      params.toTokenAddress,
      params.fromAmount,
      (0, utils_2.getDexFlag)(params.excludePoolTypes)
    );
    return {
      bestAmount: res.resAmount.bestAmount,
      midPrice: res.resAmount.midPrice,
      bestPath: res.bestPath,
      bestPoolPath: res.bestPoolPath,
    };
  }
  async querySingleRoute(params) {
    params.fromTokenAddress = (0, utils_2.toWrappedETH)(
      this.context,
      params.fromTokenAddress
    );
    params.toTokenAddress = (0, utils_2.toWrappedETH)(
      this.context,
      params.toTokenAddress
    );
    const res = await this.querySingleRouteContract.callStatic.querySingleRoute(
      params.fromTokenAddress,
      params.toTokenAddress,
      params.fromAmount,
      (0, utils_2.getDexFlag)(params.excludePoolTypes)
    );
    return {
      bestAmount: res.resAmount.bestAmount,
      midPrice: res.resAmount.midPrice,
      bestPath: res.bestPath,
      bestPoolPath: res.bestPoolPath,
    };
  }
  async querySplitRoute(params) {
    params.fromTokenAddress = (0, utils_2.toWrappedETH)(
      this.context,
      params.fromTokenAddress
    );
    params.toTokenAddress = (0, utils_2.toWrappedETH)(
      this.context,
      params.toTokenAddress
    );
    const res = await this.querySplitRouteContract.callStatic.querySplitRoute(
      params.fromTokenAddress,
      params.toTokenAddress,
      params.fromAmount,
      params.isDirect,
      (0, utils_2.getDexFlagAndSplits)(
        params.excludePoolTypes,
        params.splitNumber ?? 0
      ),
      params.specifiedMiddleToken ?? context_1.ZERO_ADDRESS
    );
    const filteredOneHops = res.bestPathInfo.oneHops.map((hop) => ({
      ...hop,
      pools: hop.pools.filter((pool) =>
        hop.weights[hop.pools.indexOf(pool)].gt(context_1.ZERO)
      ),
      weights: hop.weights.filter((weight) => weight.gt(context_1.ZERO)),
    }));
    return {
      bestAmount: res.resAmount.bestAmount,
      midPrice: res.resAmount.midPrice,
      bestPathInfo: {
        ...res.bestPathInfo,
        oneHops: filteredOneHops,
      },
    };
  }
  async simulateMixSwap(params) {
    const querySingleRouteResult = await this.querySingleRoute({
      fromTokenAddress: params.fromTokenAddress,
      toTokenAddress: params.toTokenAddress,
      fromAmount: params.fromAmount,
      excludePoolTypes: params.excludePoolTypes,
    });
    const minReturnAmount = querySingleRouteResult.bestAmount
      .mul(sdks_perp_1.RATIO_BASE - params.slippageInBps)
      .div(sdks_perp_1.RATIO_BASE);
    const bestAmount = Number(
      (0, context_1.formatUnits)(
        querySingleRouteResult.bestAmount,
        params.toTokenDecimals
      )
    );
    const midPrice = Number(
      (0, context_1.formatUnits)(querySingleRouteResult.midPrice, 18)
    );
    const numberFromTokenAmount = Number(
      (0, context_1.formatUnits)(params.fromAmount, params.fromTokenDecimals)
    );
    return {
      priceImpact: Math.max(
        bestAmount / (numberFromTokenAmount * midPrice) - 1,
        0
      ),
      minReceivedAmount: minReturnAmount,
      route: querySingleRouteResult.bestPoolPath.map((pool) => pool.poolType),
    };
  }
  async simulateMultiSwap(params) {
    const querySplitRouteResult = await this.querySplitRoute({
      fromTokenAddress: params.fromTokenAddress,
      toTokenAddress: params.toTokenAddress,
      fromAmount: params.fromAmount,
      excludePoolTypes: params.excludePoolTypes,
      isDirect: params.isDirect,
    });
    const minReturnAmount = querySplitRouteResult.bestAmount
      .mul(sdks_perp_1.RATIO_BASE - params.slippageInBps)
      .div(sdks_perp_1.RATIO_BASE);
    const WAD = ethers_1.BigNumber.from(10).pow(18);
    const fromTokenDecimalCorrect = ethers_1.BigNumber.from(10).pow(
      params.fromTokenDecimals
    );
    const toTokenDecimalCorrect = ethers_1.BigNumber.from(10).pow(
      params.toTokenDecimals
    );
    const priceImpactBN = querySplitRouteResult.bestAmount
      .mul(fromTokenDecimalCorrect)
      .mul(WAD)
      .div(
        params.fromAmount
          .mul(toTokenDecimalCorrect)
          .mul(querySplitRouteResult.midPrice)
          .div(WAD)
      );
    return {
      priceImpact: Math.min(
        Number((0, context_1.formatUnits)(priceImpactBN, 18)) - 1,
        0
      ),
      minReceivedAmount: minReturnAmount,
      route: querySplitRouteResult.bestPathInfo.oneHops.map((hop) =>
        hop.pools.map((pool) => ({
          poolAddr: pool.poolAddr,
          poolType: pool.poolType,
          ratio: hop.weights[hop.pools.indexOf(pool)],
          fee: pool.fee,
        }))
      ),
      tokens: querySplitRouteResult.bestPathInfo.tokens,
    };
  }
  async getPoolLiquidity(params) {
    params.blockTag =
      params.blockTag ?? (await this.context.provider.getBlockNumber());
    const [
      { prices: sellPrices, token0bals, token1bals },
      { prices: buyPrices },
    ] = await Promise.all([
      this.config.getMidPrices(
        params.pools.map((pool) => pool.poolAddr),
        params.pools.map((pool) => pool.poolType),
        false,
        {
          blockTag: params.blockTag,
        }
      ),
      this.config.getMidPrices(
        params.pools.map((pool) => pool.poolAddr),
        params.pools.map((pool) => pool.poolType),
        true,
        {
          blockTag: params.blockTag,
        }
      ),
    ]);
    const avgSellPrice =
      sellPrices.reduce(
        (sum, price) => sum + (0, context_1.fromWad)(price),
        0
      ) / sellPrices.length;
    const avgBuyPrice =
      buyPrices.reduce((sum, price) => sum + (0, context_1.fromWad)(price), 0) /
      buyPrices.length;
    const avgMidPrice = (avgSellPrice + avgBuyPrice) / 2;
    const allPoolCurves = await sdks_perp_1.utils.limitedMap(
      params.pools,
      (pool) =>
        (0, utils_2.fitPoolCurves)(
          this.config,
          pool.poolAddr,
          pool.poolType,
          token0bals[params.pools.indexOf(pool)],
          token1bals[params.pools.indexOf(pool)],
          params.token0Decimal,
          params.token1Decimal,
          params.ratio,
          params.steps,
          params.batchSize,
          params.blockTag
        ),
      params.parallel ?? 3
    );
    const allPoolMinBuyPrices = allPoolCurves.map((curves) => {
      const buyCurves = curves.buyCurves;
      if (!buyCurves || buyCurves.length === 0) return Infinity;
      return buyCurves.reduce((minPrice, curve) => {
        if (curve && curve.range && typeof curve.range.min === "number") {
          return Math.min(minPrice, curve.range.min);
        }
        return minPrice;
      }, Infinity);
    });
    const minPoolBuyPrice = Math.min(...allPoolMinBuyPrices);
    const buyQueryPrices = params.priceMultipliers
      .map((priceMultiplier) => avgBuyPrice * priceMultiplier)
      .filter((price) => price > avgBuyPrice);
    if (Math.min(...buyQueryPrices) < minPoolBuyPrice) {
      const adjustmentRatio = minPoolBuyPrice / avgBuyPrice;
      const adjustedPrices = buyQueryPrices.map(
        (price) => price * adjustmentRatio
      );
      buyQueryPrices.splice(0, buyQueryPrices.length, ...adjustedPrices);
    }
    const buyResults = (0, utils_2.adjustLiquidityResults)(
      (0, utils_2.analyzePoolLiquidity)(
        params.pools.map((pool) => pool.poolAddr),
        allPoolCurves,
        buyQueryPrices,
        true
      ),
      true
    );
    const allPoolMaxSellPrices = allPoolCurves.map((curves) => {
      const sellCurves = curves.sellCurves;
      if (!sellCurves || sellCurves.length === 0) return -Infinity;
      return sellCurves.reduce((maxPrice, curve) => {
        if (curve && curve.range && typeof curve.range.max === "number") {
          return Math.max(maxPrice, curve.range.max);
        }
        return maxPrice;
      }, -Infinity);
    });
    const maxPoolSellPrice = Math.max(...allPoolMaxSellPrices);
    const sellQueryPrices = params.priceMultipliers
      .map((priceMultiplier) => avgSellPrice * priceMultiplier)
      .filter((price) => price < avgSellPrice);
    if (Math.max(...sellQueryPrices) < maxPoolSellPrice) {
      const adjustmentRatio = maxPoolSellPrice / avgSellPrice;
      const adjustedPrices = sellQueryPrices.map(
        (price) => price * adjustmentRatio
      );
      sellQueryPrices.splice(0, sellQueryPrices.length, ...adjustedPrices);
    }
    const sellResults = (0, utils_2.adjustLiquidityResults)(
      (0, utils_2.analyzePoolLiquidity)(
        params.pools.map((pool) => pool.poolAddr),
        allPoolCurves,
        sellQueryPrices,
        false
      ),
      false
    );
    return {
      midPrice: avgMidPrice,
      buyLiquidityResults: buyResults,
      sellLiquidityResults: sellResults,
    };
  }
  async _mixSwap(params) {
    const {
      fromTokenAddress,
      fromTokenAmount,
      toTokenAddress,
      bestPath,
      bestPoolPath,
      bestAmount,
      slippageInBps,
      broker,
      brokerFeeRate,
      deadline,
    } = params;
    const fromTokenAddressNonZero = (0, utils_2.zeroToETHForSwap)(
      fromTokenAddress
    );
    const toTokenAddressNonZero = (0, utils_2.zeroToETHForSwap)(toTokenAddress);
    const minReturnAmount = bestAmount
      .mul(sdks_perp_1.RATIO_BASE - slippageInBps)
      .div(sdks_perp_1.RATIO_BASE);
    const mixAdapters = await Promise.all(
      bestPoolPath.map((pair) => this.getPoolAdapter(pair.poolType))
    );
    const mixPairs = bestPoolPath.map((pair) => pair.poolAddr);
    const assetTo = await Promise.all(
      bestPoolPath.map((pair) => {
        if (pair.swapType === types_1.SwapType.DIRECT) {
          return pair.poolAddr;
        } else if (pair.swapType === types_1.SwapType.ADAPTER) {
          return this.getPoolAdapter(pair.poolType);
        } else {
          throw new Error(`Invalid swap type: ${pair.swapType}`);
        }
      })
    );
    assetTo.push(this.oysterAggregator.address);
    const moreInfos = new Array(bestPoolPath.length).fill("0x");
    const feeData = new ethers_1.ethers.utils.AbiCoder().encode(
      ["address", "uint256"],
      [broker, brokerFeeRate]
    );
    let directions = context_1.ZERO;
    for (let i = 0; i < bestPoolPath.length; i++) {
      const token0 = bestPoolPath[i].token0;
      const sellToken = bestPath[i];
      if (sellToken !== token0) {
        directions = directions.add(context_1.ONE.shl(i));
      }
    }
    if (mixPairs.length === 0) throw new Error("RouteProxy: PAIRS_EMPTY");
    if (mixPairs.length !== mixAdapters.length)
      throw new Error("RouteProxy: PAIR_ADAPTER_NOT_MATCH");
    if (mixPairs.length !== assetTo.length - 1)
      throw new Error("RouteProxy: PAIR_ASSETTO_NOT_MATCH");
    if (minReturnAmount.eq(context_1.ZERO))
      throw new Error("RouteProxy: RETURN_AMOUNT_ZERO");
    return {
      fromTokenAddress: fromTokenAddressNonZero,
      toTokenAddress: toTokenAddressNonZero,
      fromTokenAmount,
      minReturnAmount,
      mixAdapters,
      mixPairs,
      assetTo,
      directions,
      moreInfos,
      feeData,
      deadline,
    };
  }
  async mixSwap(params, txOptions) {
    const {
      fromTokenAddress,
      toTokenAddress,
      fromTokenAmount,
      minReturnAmount,
      mixAdapters,
      mixPairs,
      assetTo,
      directions,
      moreInfos,
      feeData,
      deadline,
    } = await this._mixSwap(params);
    txOptions = {
      ...txOptions,
      value:
        fromTokenAddress === constants_1.ETH_ADDRESS
          ? fromTokenAmount
          : context_1.ZERO,
      gasLimitMultiple:
        txOptions?.gasLimitMultiple ?? this.DEFAULT_GAS_LIMIT_MULTIPLE,
    };
    const tx = await this.oysterAggregator.populateTransaction.mixSwap(
      fromTokenAddress,
      toTokenAddress,
      fromTokenAmount,
      minReturnAmount,
      mixAdapters,
      mixPairs,
      assetTo,
      directions,
      moreInfos,
      feeData,
      deadline,
      {
        ...sdks_perp_1.utils.toPopulatedTxOverrides(txOptions),
        from: await txOptions?.from,
      }
    );
    return await this.context.tx.sendTx(tx, txOptions);
  }
  async _multiSwap(params) {
    const {
      fromTokenAddress,
      fromTokenAmount,
      toTokenAddress,
      bestPathInfo,
      bestAmount,
      slippageInBps,
      broker,
      brokerFeeRate,
      deadline,
    } = params;
    const fromTokenAddressNonZero = (0, utils_2.zeroToETHForSwap)(
      fromTokenAddress
    );
    const toTokenAddressNonZero = (0, utils_2.zeroToETHForSwap)(toTokenAddress);
    const minReturnAmount = bestAmount
      .mul(sdks_perp_1.RATIO_BASE - slippageInBps)
      .div(sdks_perp_1.RATIO_BASE);
    const splitNumber = [0];
    const assetTo = [];
    const sequence = [];
    for (let i = 0; i < bestPathInfo.oneHops.length; i++) {
      const token0 = bestPathInfo.tokens[i];
      const pools = bestPathInfo.oneHops[i].pools;
      const weights = bestPathInfo.oneHops[i].weights;
      splitNumber.push(splitNumber[i] + pools.length);
      if (pools.length > 1) {
        assetTo.push(this.oysterAggregator.address);
      } else {
        const poolInfo = bestPathInfo.oneHops[i].pools[0];
        if (poolInfo.swapType === types_1.SwapType.DIRECT) {
          assetTo.push(poolInfo.poolAddr);
        } else if (poolInfo.swapType === types_1.SwapType.ADAPTER) {
          assetTo.push(await this.getPoolAdapter(poolInfo.poolType));
        } else {
          throw new Error(`Invalid swap type: ${poolInfo.swapType}`);
        }
      }
      for (let j = 0; j < pools.length; j++) {
        const poolInfo = pools[j];
        const sequencePool = poolInfo.poolAddr;
        const sequenceMixAdapter = await this.getPoolAdapter(poolInfo.poolType);
        const direction =
          token0 === poolInfo.token0 ? context_1.ZERO : context_1.ONE;
        const poolEdition = ethers_1.BigNumber.from(poolInfo.swapType).mask(3);
        const weight = weights[j];
        const mixPara = direction.add(poolEdition.shl(1)).add(weight.shl(3));
        const sequenceMixPara = mixPara;
        const sequenceMoreInfo = "0x";
        const abiCoder = new utils_1.AbiCoder();
        sequence.push(
          abiCoder.encode(
            ["address", "address", "uint256", "bytes"],
            [
              sequencePool,
              sequenceMixAdapter,
              sequenceMixPara,
              sequenceMoreInfo,
            ]
          )
        );
      }
    }
    assetTo.push(this.oysterAggregator.address);
    const midToken = [...bestPathInfo.tokens];
    midToken[0] = fromTokenAddressNonZero;
    midToken[midToken.length - 1] = toTokenAddressNonZero;
    const feeData = new ethers_1.ethers.utils.AbiCoder().encode(
      ["address", "uint256"],
      [broker, brokerFeeRate]
    );
    if (assetTo.length !== splitNumber.length)
      throw new Error("RouteProxy: PAIR_ASSETTO_NOT_MATCH");
    if (minReturnAmount.eq(context_1.ZERO))
      throw new Error("RouteProxy: RETURN_AMOUNT_ZERO");
    return {
      fromTokenAddress: fromTokenAddressNonZero,
      fromTokenAmount,
      minReturnAmount,
      splitNumber,
      midToken,
      assetTo,
      sequence,
      feeData,
      deadline,
    };
  }
  async multiSwap(params, txOptions) {
    const {
      fromTokenAddress,
      fromTokenAmount,
      minReturnAmount,
      splitNumber,
      midToken,
      assetTo,
      sequence,
      feeData,
      deadline,
    } = await this._multiSwap(params);
    txOptions = {
      ...txOptions,
      value:
        fromTokenAddress === constants_1.ETH_ADDRESS
          ? fromTokenAmount
          : context_1.ZERO,
      gasLimitMultiple:
        txOptions?.gasLimitMultiple ?? this.DEFAULT_GAS_LIMIT_MULTIPLE,
    };
    const tx = await this.oysterAggregator.populateTransaction.multiSwap(
      fromTokenAmount,
      minReturnAmount,
      splitNumber,
      midToken,
      assetTo,
      sequence,
      feeData,
      deadline,
      {
        ...sdks_perp_1.utils.toPopulatedTxOverrides(txOptions),
        from: await txOptions?.from,
      }
    );
    return await this.context.tx.sendTx(tx, txOptions);
  }
  async _wethConvert(params) {
    const isFromETH =
      params.fromTokenAddress.toLowerCase() ===
      context_1.ZERO_ADDRESS.toLowerCase();
    const isToETH =
      params.toTokenAddress.toLowerCase() ===
      context_1.ZERO_ADDRESS.toLowerCase();
    if ((!isFromETH && !isToETH) || isFromETH == isToETH) {
      throw new Error("At least one token must be ETH for WETH conversion");
    }
    return {
      fromTokenAddress: params.fromTokenAddress,
      amount: params.amount,
    };
  }
  async wethConvert(params, txOptions) {
    const { fromTokenAddress, amount } = await this._wethConvert(params);
    const isFromETH =
      fromTokenAddress.toLowerCase() === context_1.ZERO_ADDRESS.toLowerCase();
    const weth = typechain_1.IWETH__factory.connect(
      this.context.wrappedNativeToken.address,
      this.context.provider
    );
    txOptions = {
      ...txOptions,
      value: isFromETH ? amount : context_1.ZERO,
      gasLimitMultiple:
        txOptions?.gasLimitMultiple ?? this.DEFAULT_GAS_LIMIT_MULTIPLE,
    };
    const tx = isFromETH
      ? await weth.populateTransaction.deposit({
          ...sdks_perp_1.utils.toPopulatedTxOverrides(txOptions),
          value: amount,
          from: await txOptions?.from,
        })
      : await weth.populateTransaction.withdraw(amount, {
          ...sdks_perp_1.utils.toPopulatedTxOverrides(txOptions),
          from: await txOptions?.from,
        });
    return await this.context.tx.sendTx(tx, txOptions);
  }
  async querySinglePoolRoute(params) {
    params.fromTokenAddress = (0, utils_2.toWrappedETH)(
      this.context,
      params.fromTokenAddress
    );
    params.toTokenAddress = (0, utils_2.toWrappedETH)(
      this.context,
      params.toTokenAddress
    );
    const adapterAddress =
      params.adapterAddress ||
      (await this.getPoolAdapter(types_1.PoolType.OYSTER_NEW));
    const adapterInterface = new ethers_1.ethers.utils.Interface([
      "function querySell(address fromToken, uint256 fromAmount, address pool) external returns (address toToken, uint256 toAmount)",
      "function getMidPriceAndBalances(address pool, bool isBuy) external view returns (uint256 price, uint256 token0bal, uint256 token1bal)",
    ]);
    const isBuy =
      params.fromTokenAddress.toLowerCase() <
      params.toTokenAddress.toLowerCase();
    const multicallCalls = [
      {
        target: adapterAddress,
        callData: adapterInterface.encodeFunctionData("querySell", [
          params.fromTokenAddress,
          params.fromAmount,
          params.poolAddress,
        ]),
      },
      {
        target: adapterAddress,
        callData: adapterInterface.encodeFunctionData(
          "getMidPriceAndBalances",
          [params.poolAddress, isBuy]
        ),
      },
    ];
    const multicallResults = (
      await this.context.multiCall3.callStatic.aggregate(multicallCalls)
    ).returnData;
    const [, toAmount] = adapterInterface.decodeFunctionResult(
      "querySell",
      multicallResults[0]
    );
    const [midPrice, ,] = adapterInterface.decodeFunctionResult(
      "getMidPriceAndBalances",
      multicallResults[1]
    );
    const [token0, token1] = isBuy
      ? [params.fromTokenAddress, params.toTokenAddress]
      : [params.toTokenAddress, params.fromTokenAddress];
    const poolInfo = {
      token0,
      token1,
      poolAddr: params.poolAddress,
      poolType: types_1.PoolType.OYSTER_NEW,
      fee: context_1.ZERO,
      swapType: types_1.SwapType.ADAPTER,
    };
    const oneHop = {
      pools: [poolInfo],
      weights: [context_1.ONE],
    };
    const bestPathInfo = {
      tokens: [params.fromTokenAddress, params.toTokenAddress],
      oneHops: [oneHop],
      finalAmountOut: toAmount,
      isValid: true,
    };
    return {
      bestAmount: toAmount,
      midPrice: midPrice,
      bestPathInfo: bestPathInfo,
    };
  }
  async simulateMTSinglePool(params) {
    const querySinglePoolRouteResult = await this.querySinglePoolRoute({
      fromTokenAddress: params.fromTokenAddress,
      toTokenAddress: params.toTokenAddress,
      fromAmount: params.fromAmount,
      poolAddress: params.poolAddress,
      adapterAddress: params.adapterAddress,
    });
    const minReturnAmount = querySinglePoolRouteResult.bestAmount
      .mul(sdks_perp_1.RATIO_BASE - params.slippageInBps)
      .div(sdks_perp_1.RATIO_BASE);
    const WAD = ethers_1.BigNumber.from(10).pow(18);
    const fromTokenDecimalCorrect = ethers_1.BigNumber.from(10).pow(
      params.fromTokenDecimals
    );
    const toTokenDecimalCorrect = ethers_1.BigNumber.from(10).pow(
      params.toTokenDecimals
    );
    const priceImpactBN = querySinglePoolRouteResult.bestAmount
      .mul(fromTokenDecimalCorrect)
      .mul(WAD)
      .div(
        params.fromAmount
          .mul(toTokenDecimalCorrect)
          .mul(querySinglePoolRouteResult.midPrice)
          .div(WAD)
      );
    return {
      priceImpact: Math.min(
        Number((0, context_1.formatUnits)(priceImpactBN, 18)) - 1,
        0
      ),
      minReceivedAmount: minReturnAmount,
      route: querySinglePoolRouteResult.bestPathInfo.oneHops.map((hop) =>
        hop.pools.map((pool) => ({
          poolAddr: pool.poolAddr,
          poolType: pool.poolType,
          ratio: hop.weights[hop.pools.indexOf(pool)],
          fee: pool.fee,
        }))
      ),
      tokens: querySinglePoolRouteResult.bestPathInfo.tokens,
    };
  }
}
exports.AggregatorModule = AggregatorModule;
