"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toWrappedETH = toWrappedETH;
exports.zeroToETHForSwap = zeroToETHForSwap;
exports.fromWei = fromWei;
exports.toWei = toWei;
exports.fitPoolCurves = fitPoolCurves;
exports.analyzePoolLiquidity = analyzePoolLiquidity;
exports.adjustLiquidityResults = adjustLiquidityResults;
exports.getDexFlag = getDexFlag;
exports.getDexFlagAndSplits = getDexFlagAndSplits;
const context_1 = require("@derivation-tech/context");
const constants_1 = require("./constants");
const ethers_1 = require("ethers");
const utils_1 = require("ethers/lib/utils");
function toWrappedETH(ctx, tokenAddress) {
  return tokenAddress.toLowerCase() === context_1.ZERO_ADDRESS.toLowerCase()
    ? ctx.wrappedNativeToken.address
    : tokenAddress;
}
function zeroToETHForSwap(tokenAddress) {
  return tokenAddress.toLowerCase() ==
    context_1.ZERO_ADDRESS.toLocaleLowerCase()
    ? constants_1.ETH_ADDRESS
    : tokenAddress;
}
function fromWei(amount, decimals = 18) {
  return Number((0, context_1.formatUnits)(amount, decimals));
}
function toWei(amount, decimals = 18) {
  return (0, utils_1.parseUnits)(amount.toFixed(decimals), decimals);
}
async function fitPoolCurves(
  config,
  pool,
  poolType,
  token0Balance,
  token1Balance,
  token0Decimal,
  token1Decimal,
  ratio = 0.5,
  steps = 50,
  batchSize = 10,
  blockTag
) {
  const token0Bal = fromWei(token0Balance, token0Decimal);
  const token1Bal = fromWei(token1Balance, token1Decimal);
  const maxToken0In = token0Bal * ratio;
  const maxToken1In = token1Bal * ratio;
  const token0Step = maxToken0In / steps;
  const token1Step = maxToken1In / steps;
  let token0Inputs = [
    toWei(token0Bal * 0.0001, token0Decimal).toString(),
  ].concat(
    Array.from({ length: steps }, (_, i) =>
      toWei(token0Step * (i + 1), token0Decimal).toString()
    )
  );
  let token1Inputs = [
    toWei(token1Bal * 0.0001, token1Decimal).toString(),
  ].concat(
    Array.from({ length: steps }, (_, i) =>
      toWei(token1Step * (i + 1), token1Decimal).toString()
    )
  );
  let sellAmountsOut = [];
  let buyAmountsOut = [];
  for (let i = 0; i < token0Inputs.length; i += batchSize) {
    const batchInputs = token0Inputs.slice(i, i + batchSize);
    const batchResults = await config.callStatic
      .getAmountsOut(pool, poolType, true, batchInputs, { blockTag })
      .catch((err) => {
        throw err;
      });
    sellAmountsOut = sellAmountsOut.concat(batchResults);
  }
  for (let i = 0; i < token1Inputs.length; i += batchSize) {
    const batchInputs = token1Inputs.slice(i, i + batchSize);
    const batchResults = await config.callStatic
      .getAmountsOut(pool, poolType, false, batchInputs, { blockTag })
      .catch((err) => {
        throw err;
      });
    buyAmountsOut = buyAmountsOut.concat(batchResults);
  }
  const [filteredToken0Inputs, filteredSellAmountsOut] = (() => {
    let cutoffIndex = token0Inputs.length;
    for (let i = 1; i < token0Inputs.length; i++) {
      if (
        ethers_1.BigNumber.from(sellAmountsOut[i]).eq(
          ethers_1.BigNumber.from(sellAmountsOut[i - 1])
        )
      ) {
        cutoffIndex = i;
        break;
      }
    }
    return [
      token0Inputs.slice(0, cutoffIndex),
      sellAmountsOut.slice(0, cutoffIndex),
    ];
  })();
  const [filteredToken1Inputs, filteredBuyAmountsOut] = (() => {
    let cutoffIndex = token1Inputs.length;
    for (let i = 1; i < token1Inputs.length; i++) {
      if (
        ethers_1.BigNumber.from(buyAmountsOut[i]).eq(
          ethers_1.BigNumber.from(buyAmountsOut[i - 1])
        )
      ) {
        cutoffIndex = i;
        break;
      }
    }
    return [
      token1Inputs.slice(0, cutoffIndex),
      buyAmountsOut.slice(0, cutoffIndex),
    ];
  })();
  token0Inputs = filteredToken0Inputs;
  token1Inputs = filteredToken1Inputs;
  sellAmountsOut = filteredSellAmountsOut;
  buyAmountsOut = filteredBuyAmountsOut;
  const sellPoints = token0Inputs
    .map((amountInWei, i) => {
      const amountIn = fromWei(
        ethers_1.BigNumber.from(amountInWei),
        token0Decimal
      );
      const amountOut = fromWei(
        ethers_1.BigNumber.from(sellAmountsOut[i]),
        token1Decimal
      );
      const price = amountOut / amountIn;
      return [price, amountOut];
    })
    .filter((point, i, arr) => {
      if (i === 0) return true;
      return point[0] < arr[i - 1][0] && point[1] > arr[i - 1][1];
    });
  const buyPoints = token1Inputs
    .map((amountInWei, i) => {
      const amountIn = fromWei(
        ethers_1.BigNumber.from(amountInWei),
        token1Decimal
      );
      const amountOut = fromWei(
        ethers_1.BigNumber.from(buyAmountsOut[i]),
        token0Decimal
      );
      const price = amountIn / amountOut;
      return [price, amountOut];
    })
    .filter((point, i, arr) => {
      if (i === 0) return true;
      return point[0] > arr[i - 1][0] && point[1] > arr[i - 1][1];
    });
  const sellPricePoints = sellPoints.map((p) => [p[0], p[1]]);
  const buyPricePoints = buyPoints.map((p) => [p[0], p[1]]);
  const sellCurves = calculateSplineParams(sellPricePoints);
  const buyCurves = calculateSplineParams(buyPricePoints);
  return {
    sellCurves,
    buyCurves,
  };
}
function calculateSplineParams(points) {
  const x = points.map((p) => p[0]);
  const a = points.map((p) => p[1]);
  const n = x.length - 1;
  const h = new Array(n);
  const A = new Array(n);
  const l = new Array(n + 1);
  const u = new Array(n);
  const z = new Array(n + 1);
  const c = new Array(n + 1);
  const b = new Array(n);
  const d = new Array(n);
  for (let i = 0; i < n; i++) {
    h[i] = x[i + 1] - x[i];
  }
  for (let i = 1; i < n; i++) {
    A[i] = (3 * (a[i + 1] - a[i])) / h[i] - (3 * (a[i] - a[i - 1])) / h[i - 1];
  }
  l[0] = 1;
  u[0] = 0;
  z[0] = 0;
  for (let i = 1; i < n; i++) {
    l[i] = 2 * (x[i + 1] - x[i - 1]) - h[i - 1] * u[i - 1];
    u[i] = h[i] / l[i];
    z[i] = (A[i] - h[i - 1] * z[i - 1]) / l[i];
  }
  l[n] = 1;
  z[n] = 0;
  c[n] = 0;
  for (let j = n - 1; j >= 0; j--) {
    c[j] = z[j] - u[j] * c[j + 1];
    b[j] = (a[j + 1] - a[j]) / h[j] - (h[j] * (c[j + 1] + 2 * c[j])) / 3;
    d[j] = (c[j + 1] - c[j]) / (3 * h[j]);
  }
  return points.slice(0, -1).map((_, i) => ({
    range: {
      min: x[i],
      max: x[i + 1],
    },
    coefficients: [a[i], b[i], c[i], d[i]],
  }));
}
function analyzePoolLiquidity(pools, allPoolCurves, testPrices, isBuy) {
  const results = testPrices.map((price) => {
    const poolAmounts = pools.map((pool) => {
      if (isBuy) {
        const curves = allPoolCurves[pools.indexOf(pool)].buyCurves;
        const maxPriceCurve = curves.reduce(
          (max, curve) =>
            curve.range.max > (max?.range.max || -Infinity) ? curve : max,
          curves[0]
        );
        for (const curve of curves) {
          const amount0 = getAmountOutFromPrice(price, curve);
          if (amount0 !== null) {
            const amount1 = amount0 * price;
            return { pool, amount0, amount1 };
          }
        }
        if (price > maxPriceCurve.range.max) {
          const amount0 = getAmountOutFromPrice(
            maxPriceCurve.range.max,
            maxPriceCurve
          );
          if (amount0 !== null) {
            const amount1 = amount0 * maxPriceCurve.range.max;
            return { pool, amount0, amount1 };
          }
        }
      } else {
        const curves = allPoolCurves[pools.indexOf(pool)].sellCurves;
        const minPriceCurve = curves.reduce(
          (min, curve) =>
            curve.range.min < (min?.range.min || Infinity) ? curve : min,
          curves[0]
        );
        for (const curve of curves) {
          const amount1 = getAmountOutFromPrice(price, curve);
          if (amount1 !== null) {
            const amount0 = amount1 / price;
            return { pool, amount0, amount1 };
          }
        }
        if (price < minPriceCurve.range.min) {
          const amount1 = getAmountOutFromPrice(
            minPriceCurve.range.min,
            minPriceCurve
          );
          if (amount1 !== null) {
            const amount0 = amount1 / minPriceCurve.range.min;
            return { pool, amount0, amount1 };
          }
        }
      }
      return { pool, amount0: 0, amount1: 0 };
    });
    return {
      price,
      poolAmounts,
    };
  });
  return results;
}
function getAmountOutFromPrice(price, curve) {
  const [a, b, c, d] = curve.coefficients;
  const lower = Math.min(curve.range.min, curve.range.max);
  const upper = Math.max(curve.range.min, curve.range.max);
  const x0 = curve.range.min;
  const dx = price - x0;
  const amountOut = a + b * dx + c * dx * dx + d * dx * dx * dx;
  if (price >= lower && price <= upper) {
    return amountOut;
  }
  return null;
}
function adjustLiquidityResults(results, isBuy) {
  const sortedResults = [...results].sort((a, b) =>
    isBuy ? a.price - b.price : b.price - a.price
  );
  const poolMap = new Map();
  sortedResults[0].poolAmounts.forEach(({ pool }) => {
    poolMap.set(pool, {
      maxAmount: isBuy
        ? sortedResults[0].poolAmounts.find((p) => p.pool === pool)?.amount0 ||
          0
        : sortedResults[0].poolAmounts.find((p) => p.pool === pool)?.amount1 ||
          0,
      lastValidIndex: 0,
    });
  });
  for (let i = 1; i < sortedResults.length; i++) {
    sortedResults[i].poolAmounts.forEach(({ pool, amount0, amount1 }) => {
      const poolData = poolMap.get(pool);
      if (!poolData) return;
      const currentAmount = isBuy ? amount0 : amount1;
      if (currentAmount > poolData.maxAmount) {
        poolData.maxAmount = currentAmount;
        poolData.lastValidIndex = i;
      }
    });
  }
  poolMap.forEach((poolData, pool) => {
    for (let i = poolData.lastValidIndex + 1; i < sortedResults.length; i++) {
      const poolAmount = sortedResults[i].poolAmounts.find(
        (p) => p.pool === pool
      );
      if (poolAmount) {
        if (isBuy) {
          poolAmount.amount0 = poolData.maxAmount;
        } else {
          poolAmount.amount1 = poolData.maxAmount;
        }
      }
    }
  });
  return sortedResults;
}
function getDexFlag(poolTypes) {
  return poolTypes.reduce(
    (acc, poolType) => acc.or(context_1.ONE.shl(poolType)),
    context_1.ZERO
  );
}
function getDexFlagAndSplits(poolTypes, splitNumber = 0) {
  const maxSplitNumber = 127;
  if (poolTypes.length > maxSplitNumber) {
    throw new Error(`poolTypes length must be less than ${maxSplitNumber}`);
  }
  return getDexFlag(poolTypes).or(
    ethers_1.BigNumber.from(splitNumber).shl(maxSplitNumber)
  );
}
