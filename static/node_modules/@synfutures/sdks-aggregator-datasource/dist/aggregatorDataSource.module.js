"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AggregatorDataSourceModule = exports.ETH_ADDRESS = void 0;
const ethers_1 = require("ethers");
const contracts_1 = require("@derivation-tech/contracts");
const graph_1 = require("@derivation-tech/context/dist/utils/graph");
exports.ETH_ADDRESS = "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE";
class AggregatorDataSourceModule extends graph_1.Graph {
  constructor(context, endpoint, retryOption) {
    super(endpoint, retryOption);
    this.context = context;
  }
  async getOrderHistory(params) {
    const graphQL = `query($skip: Int, $first: Int, $lastID: String){
            orderHistoryEvents(
                where: {user: "${params.user.toLowerCase()}"}
                orderBy: transaction__timestamp
                orderDirection: desc
            ) {
                id
                logIndex
                transaction {
                    id
                    timestamp
                    input
                }
                address
                fromToken
                toToken
                sender
                fromAmount
                returnAmount
            }
        }`;
    const orderHistoryEvents = await this.queryAll(
      graphQL,
      graph_1.GRAPH_PAGE_SIZE,
      true
    );
    const tokens = Array.from(
      new Set(
        orderHistoryEvents
          .map((orderHistory) => [orderHistory.fromToken, orderHistory.toToken])
          .flat()
      )
    );
    const calls = [];
    const erc20Interface = contracts_1.ERC20__factory.createInterface();
    for (const token of tokens) {
      const targetAddress =
        token.toLowerCase() === exports.ETH_ADDRESS.toLowerCase()
          ? this.context.wrappedNativeToken.address
          : token;
      calls.push({
        target: targetAddress,
        callData: erc20Interface.encodeFunctionData("symbol"),
      });
      calls.push({
        target: targetAddress,
        callData: erc20Interface.encodeFunctionData("decimals"),
      });
    }
    const rawData = await this.context.multiCall3.callStatic.aggregate(calls);
    const tokenMap = new Map();
    for (let i = 0; i < tokens.length; i++) {
      try {
        const token = tokens[i];
        const isETH = token.toLowerCase() === exports.ETH_ADDRESS.toLowerCase();
        const symbol = isETH
          ? "ETH"
          : erc20Interface.decodeFunctionResult(
              "symbol",
              rawData.returnData[i * 2]
            )[0];
        const decimals = erc20Interface.decodeFunctionResult(
          "decimals",
          rawData.returnData[i * 2 + 1]
        )[0];
        tokenMap.set(token, {
          symbol,
          decimals: Number(decimals),
          address: token,
        });
      } catch (e) {
        console.warn(
          `Failed to get symbol and decimals for ${tokens[i]}, error: ${e}`
        );
      }
    }
    const result = [];
    for (const orderHistory of orderHistoryEvents) {
      result.push({
        timestamp: Number(orderHistory.transaction.timestamp),
        transactionHash: orderHistory.transaction.id,
        logIndex: orderHistory.logIndex,
        fromToken: tokenMap.get(orderHistory.fromToken),
        toToken: tokenMap.get(orderHistory.toToken),
        sender: orderHistory.sender,
        fromAmount: ethers_1.BigNumber.from(orderHistory.fromAmount),
        returnAmount: ethers_1.BigNumber.from(orderHistory.returnAmount),
      });
    }
    return {
      orderHistory: result,
    };
  }
}
exports.AggregatorDataSourceModule = AggregatorDataSourceModule;
