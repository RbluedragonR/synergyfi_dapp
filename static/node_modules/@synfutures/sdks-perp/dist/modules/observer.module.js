"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ObserverModule = void 0;
const ethers_1 = require("ethers");
const context_1 = require("@derivation-tech/context");
const typechain_1 = require("../typechain");
const enum_1 = require("../enum");
const math_1 = require("../math");
const utils_1 = require("../utils");
const lowLevel_1 = require("../utils/lowLevel");
const parser_1 = require("../parser");
const errors_1 = require("../errors");
const batchSize = 10;
class ObserverModule {
  constructor(context) {
    this.cache = new Map();
    this.context = context;
  }
  async getMiscInfo(instrumentAddress, overrides) {
    const instrumentInterface =
      typechain_1.Instrument__factory.createInterface();
    let needFundingHour =
      this.context.chainId !== context_1.CHAIN_ID.BLAST &&
      this.context.chainId !== context_1.CHAIN_ID.LOCAL;
    if (overrides && overrides.blockTag) {
      const blockTag = await overrides.blockTag;
      if (typeof blockTag === "number" || blockTag.startsWith("0x")) {
        const blockNumber = ethers_1.ethers.BigNumber.from(blockTag).toNumber();
        if (
          this.context.chainId === context_1.CHAIN_ID.BASE &&
          blockNumber < 21216046
        ) {
          needFundingHour = false;
        }
      }
    }
    const calls = [];
    for (const instrumentAddr of instrumentAddress) {
      calls.push({
        target: instrumentAddr,
        callData: instrumentInterface.encodeFunctionData("placePaused"),
      });
      if (needFundingHour) {
        calls.push({
          target: instrumentAddr,
          callData: instrumentInterface.encodeFunctionData("fundingHour"),
        });
      }
    }
    const rawMiscInfo = await this.context
      .getMulticall3()
      .callStatic.aggregate(calls, overrides ?? {});
    const miscList = [];
    for (
      let j = 0;
      j < rawMiscInfo.returnData.length;
      j = needFundingHour ? j + 2 : j + 1
    ) {
      const [placePaused] = instrumentInterface.decodeFunctionResult(
        "placePaused",
        rawMiscInfo.returnData[j]
      );
      const [fundingHour] = needFundingHour
        ? instrumentInterface.decodeFunctionResult(
            "fundingHour",
            rawMiscInfo.returnData[j + 1]
          )
        : [24];
      miscList.push({
        placePaused: placePaused,
        fundingHour: fundingHour === 0 ? 24 : fundingHour,
      });
    }
    return miscList;
  }
  async getPortfolio(params, overrides) {
    params = Array.isArray(params) ? params : [params];
    const observerInterface = this.context.perp.contracts.observer.interface;
    let portfolios = [];
    for (let i = 0; i < params.length; i += batchSize) {
      const _params = params.slice(i, i + batchSize);
      const calls = _params.map((p) => {
        return {
          target: this.context.perp.contracts.observer.address,
          callData: observerInterface.encodeFunctionData("getAcc", [
            p.instrumentAddr,
            p.expiry,
            p.traderAddr,
          ]),
        };
      });
      portfolios = portfolios.concat(
        await (0, utils_1.quickRetry)(() =>
          this.context
            .getMulticall3()
            .callStatic.aggregate(calls, overrides ?? {})
            .then(({ returnData }) =>
              returnData.map((d, i) => {
                const p = _params[i];
                return (0, utils_1.toPortfolio)(
                  p.instrumentAddr,
                  p.expiry,
                  p.traderAddr,
                  observerInterface.decodeFunctionResult("getAcc", d)
                );
              })
            )
        )
      );
    }
    return portfolios.length === 1 ? portfolios[0] : portfolios;
  }
  async getAllInstruments(overrides) {
    const instrumentLists =
      await this.context.perp.contracts.gate.getAllInstruments(overrides ?? {});
    const totalPage = Math.ceil(instrumentLists.length / batchSize);
    const rawList = [];
    const miscInfoList = [];
    for (let i = 0; i < totalPage; i++) {
      const queryList = instrumentLists.slice(
        i * batchSize,
        (i + 1) * batchSize >= instrumentLists.length
          ? instrumentLists.length
          : (i + 1) * batchSize
      );
      rawList.push(
        await (0, utils_1.quickRetry)(() =>
          this.context.perp.contracts.observer.getInstrumentByAddressList(
            queryList,
            overrides ?? {}
          )
        )
      );
      miscInfoList.push(
        await (0, utils_1.quickRetry)(async () =>
          this.getMiscInfo(queryList, overrides ?? {})
        )
      );
    }
    let assembledInstrumentDatas = [];
    for (let i = 0; i < rawList.length; i++) {
      const miscInfo = miscInfoList[i];
      const [rawInstrument, rawBlockInfo] = (0, utils_1.trimObj)(rawList[i]);
      assembledInstrumentDatas = assembledInstrumentDatas.concat(
        await this.parseInstrumentData(
          rawInstrument,
          miscInfo,
          rawBlockInfo,
          overrides ?? {}
        )
      );
    }
    return assembledInstrumentDatas;
  }
  async getInstrument(params, overrides) {
    const _params = Array.isArray(params) ? params : [params];
    const formattedParams = [];
    for (let i = 0; i < _params.length; i++) {
      const p = _params[i];
      if (typeof p === "string") {
        if (ethers_1.ethers.utils.isAddress(p)) {
          formattedParams.push({
            instrument: p,
            expiries: [],
          });
        } else {
          formattedParams.push({
            instrument: await this._getInstrumentBySymbol(p, overrides ?? {}),
            expiries: [],
          });
        }
      } else {
        if (ethers_1.ethers.utils.isAddress(p.instrument)) {
          formattedParams.push(p);
        } else {
          formattedParams.push({
            instrument: await this._getInstrumentBySymbol(
              p.instrument,
              overrides ?? {}
            ),
            expiries: p.expiries,
          });
        }
      }
    }
    const [rawList, rawBlockInfo] = (0, utils_1.trimObj)(
      await this.context.perp.contracts.observer.getInstrumentBatch(
        formattedParams,
        overrides ?? {}
      )
    );
    const miscInfoList = await this.getMiscInfo(
      formattedParams.map((p) => p.instrument),
      overrides ?? {}
    );
    const instruments = await this.parseInstrumentData(
      rawList,
      miscInfoList,
      rawBlockInfo,
      overrides ?? {}
    );
    return Array.isArray(params) ? instruments : instruments?.[0];
  }
  async _getInstrumentBySymbol(symbol, overrides) {
    const cachedInstrumentAddress = this.cache.get(symbol);
    if (cachedInstrumentAddress) {
      return cachedInstrumentAddress;
    }
    await this.getAllInstruments(overrides ?? {});
    const updatedInstrumentAddress = this.cache.get(symbol);
    if (!updatedInstrumentAddress) {
      throw new errors_1.SynfError("unknown symbol: " + symbol);
    }
    return updatedInstrumentAddress;
  }
  async parseInstrumentData(rawList, miscInfoList, blockInfo, overrides) {
    const assembledInstrumentDatas = [];
    for (let i = 0; i < rawList.length; i++) {
      const rawInstrument = rawList[i];
      const miscInfo = miscInfoList[i];
      const [baseSymbol, quoteSymbol, marketType] =
        rawInstrument.symbol.split("-");
      const quoteTokenInfo = await this.getQuoteTokenInfo(
        quoteSymbol,
        rawInstrument.instrumentAddr,
        overrides ?? {}
      );
      let baseInfo = {
        symbol: baseSymbol,
        address: ethers_1.ethers.constants.AddressZero,
        decimals: 0,
      };
      if (!(0, utils_1.isCexMarket)(marketType)) {
        const onCtxBaseInfo = await this.context.getTokenInfo(baseSymbol);
        if (onCtxBaseInfo) {
          baseInfo = onCtxBaseInfo;
        }
      }
      const instrumentInfo = {
        chainId: this.context.chainId,
        addr: rawInstrument.instrumentAddr,
        symbol: rawInstrument.symbol,
        base: baseInfo,
        quote: quoteTokenInfo,
      };
      const marketInfo = {
        addr: rawInstrument.market,
        type: marketType,
        beacon:
          this.context.perp.configuration.config.contractAddress.market[
            marketType
          ].beacon,
      };
      const marketConfig =
        this.context.perp.configuration.config.marketConfig[marketType];
      const feeder = (0, utils_1.isCexMarket)(marketType)
        ? rawInstrument.priceFeeder
        : rawInstrument.dexV2Feeder;
      const market = { info: marketInfo, config: marketConfig, feeder: feeder };
      const instrumentSetting = {
        initialMarginRatio: rawInstrument.initialMarginRatio,
        maintenanceMarginRatio: rawInstrument.maintenanceMarginRatio,
        quoteParam: rawInstrument.param,
      };
      const amms = new Map();
      for (let i = 0; i < rawInstrument.amms.length; i++) {
        const rawAmm = rawInstrument.amms[i];
        if (rawAmm.expiry === 0) {
          continue;
        }
        const amm = utils_1.factory.createAmm({
          ...rawAmm,
          instrumentAddr: rawInstrument.instrumentAddr,
          markPrice: rawInstrument.markPrices[i],
          blockInfo,
        });
        amms.set(rawAmm.expiry, amm);
      }
      const rawAssembledInstrumentData = {
        instrumentAddr: rawInstrument.instrumentAddr,
        symbol: rawInstrument.symbol,
        market,
        condition: rawInstrument.condition,
        setting: instrumentSetting,
        spotPrice: rawInstrument.spotPrice,
        amms,
        base: baseInfo,
        quote: quoteTokenInfo,
        blockInfo,
        ...miscInfo,
      };
      const assembledInstrumentData = utils_1.factory.createInstrument(
        rawAssembledInstrumentData
      );
      this.cache.set(
        instrumentInfo.symbol,
        assembledInstrumentData.instrumentAddr
      );
      this.context.registerAddress(instrumentInfo.addr, instrumentInfo.symbol);
      this.context.registerContractParser(
        instrumentInfo.addr,
        new parser_1.InstrumentParser()
      );
      assembledInstrumentDatas.push(assembledInstrumentData);
    }
    return assembledInstrumentDatas;
  }
  async getQuoteTokenInfo(quoteSymbol, instrumentAddr, overrides) {
    return (
      (await this.context.getTokenInfo(quoteSymbol)) ??
      (await this.context.getTokenInfo(
        (
          await this.context.perp.contracts.observer.getSetting(
            instrumentAddr,
            overrides ?? {}
          )
        ).quote
      ))
    );
  }
  async inspectDexV2MarketBenchmarkPrice(
    instrumentIdentifier,
    expiry,
    overrides
  ) {
    const { baseSymbol, quoteSymbol } = (0, utils_1.getTokenSymbol)(
      instrumentIdentifier.baseSymbol,
      instrumentIdentifier.quoteSymbol
    );
    const baseParam =
      this.context.perp.configuration.config.quotesParam[baseSymbol];
    const quoteParam =
      this.context.perp.configuration.config.quotesParam[quoteSymbol];
    const baseStable = baseParam && baseParam.qtype === enum_1.QuoteType.STABLE;
    const quoteStable =
      quoteParam && quoteParam.qtype === enum_1.QuoteType.STABLE;
    const feederType = (baseStable ? 2 : 0) + (quoteStable ? 1 : 0);
    const rawSpotPrice = await this.getDexV2RawSpotPrice(
      instrumentIdentifier,
      overrides ?? {}
    );
    return (0, lowLevel_1.calcBenchmarkPrice)(
      expiry,
      rawSpotPrice,
      feederType,
      this.context.perp.configuration.config.marketConfig.DEXV2
        .dailyInterestRate
    );
  }
  async inspectCexMarketBenchmarkPrice(instrumentIdentifier, expiry) {
    const instrumentAddress =
      await this.context.perp.instrument.computeInstrumentAddress(
        instrumentIdentifier
      );
    const market =
      this.context.perp.contracts.marketContracts[
        instrumentIdentifier.marketType
      ]?.market;
    let benchmarkPrice;
    try {
      benchmarkPrice = await market.getBenchmarkPrice(
        instrumentAddress,
        expiry
      );
    } catch (e) {
      console.error("fetch chainlink market price error", e);
      benchmarkPrice = math_1.ZERO;
    }
    return benchmarkPrice;
  }
  async getRawSpotPrice(identifier, overrides) {
    if (identifier.marketType === enum_1.MarketType.DEXV2) {
      return await this.getDexV2RawSpotPrice(identifier, overrides ?? {});
    } else if ((0, utils_1.isCexMarket)(identifier.marketType)) {
      return await this.getCexRawSpotPrice(identifier, overrides ?? {});
    } else {
      throw new errors_1.SynfError(
        "Unsupported market type: " + identifier.marketType
      );
    }
  }
  async getNextInitializedTickOutside(
    instrumentAddr,
    expiry,
    tick,
    right,
    overrides
  ) {
    return await this.context.perp.contracts.observer.getNextInitializedTickOutside(
      instrumentAddr,
      expiry,
      tick,
      right,
      overrides ?? {}
    );
  }
  async getSizeToTargetTick(instrumentAddr, expiry, targetTick, overrides) {
    const observer = this.context.perp.contracts.observer;
    const amm = await observer.getAmm(instrumentAddr, expiry, overrides ?? {});
    const targetPX96 = math_1.TickMath.getSqrtRatioAtTick(targetTick);
    if (targetPX96.eq(amm.sqrtPX96)) {
      return math_1.ZERO;
    }
    const long = targetTick > amm.tick;
    let size = math_1.ZERO;
    const currTickLeft = (
      await observer.getPearls(
        instrumentAddr,
        expiry,
        [amm.tick],
        overrides ?? {}
      )
    )[0].left;
    if (long && currTickLeft.isNegative()) {
      size = size.sub(currTickLeft);
    }
    let sqrtPX96 = amm.sqrtPX96;
    let liquidity = amm.liquidity;
    let nextTick = await this.getNextInitializedTickOutside(
      instrumentAddr,
      expiry,
      amm.tick + (long ? 0 : 1),
      long,
      overrides ?? {}
    );
    while (true) {
      const nextPX96 = math_1.TickMath.getSqrtRatioAtTick(nextTick);
      if ((long && nextTick > targetTick) || (!long && nextTick < targetTick)) {
        const delta = math_1.SqrtPriceMath.getDeltaBaseAutoRoundUp(
          sqrtPX96,
          targetPX96,
          liquidity
        );
        size = long ? size.add(delta).add(1) : size.sub(delta).sub(1);
        break;
      }
      const nextPearl = (
        await observer.getPearls(
          instrumentAddr,
          expiry,
          [nextTick],
          overrides ?? {}
        )
      )[0];
      const delta = math_1.SqrtPriceMath.getDeltaBaseAutoRoundUp(
        sqrtPX96,
        nextPX96,
        liquidity
      );
      size = long ? size.add(delta) : size.sub(delta);
      if (nextTick === targetTick) {
        break;
      }
      if (
        (long && nextPearl.left.isNegative()) ||
        (!long && nextPearl.left.gt(0))
      ) {
        size = size.sub(nextPearl.left);
      }
      sqrtPX96 = nextPX96;
      if (nextPearl.liquidityGross.gt(math_1.ZERO)) {
        liquidity = liquidity.add(
          long ? nextPearl.liquidityNet : nextPearl.liquidityNet.mul(-1)
        );
      }
      nextTick = await this.getNextInitializedTickOutside(
        instrumentAddr,
        expiry,
        nextTick,
        long,
        overrides ?? {}
      );
    }
    return size;
  }
  async getFundFlows(quoteAddrs, trader, overrides) {
    const gateInterface = this.context.perp.contracts.gate.interface;
    const observerInterface = this.context.perp.contracts.observer.interface;
    const calls = [];
    calls.push(
      ...quoteAddrs.map((quote) => {
        return {
          target: this.context.perp.contracts.gate.address,
          callData: gateInterface.encodeFunctionData("fundFlowOf", [
            quote,
            trader,
          ]),
        };
      })
    );
    calls.push({
      target: this.context.perp.contracts.observer.address,
      callData: observerInterface.encodeFunctionData("getVaultBalances", [
        trader,
        quoteAddrs,
      ]),
    });
    const rawRet = (
      await this.context
        .getMulticall3()
        .callStatic.aggregate(calls, overrides ?? {})
    ).returnData;
    const fundFlows = rawRet.slice(0, quoteAddrs.length).map((ret) => {
      return (0, utils_1.trimObj)(
        gateInterface.decodeFunctionResult("fundFlowOf", ret)[0]
      );
    });
    const blockInfo = (0, utils_1.trimObj)(
      observerInterface.decodeFunctionResult(
        "getVaultBalances",
        rawRet[quoteAddrs.length]
      )[1]
    );
    return { fundFlows, blockInfo: blockInfo };
  }
  async getUserPendings(quotes, trader, overrides) {
    const gateInterface = this.context.perp.contracts.gate.interface;
    const observerInterface = this.context.perp.contracts.observer.interface;
    const calls = [];
    calls.push(
      ...quotes.map((quote) => {
        return {
          target: this.context.perp.contracts.gate.address,
          callData: gateInterface.encodeFunctionData("fundFlowOf", [
            quote,
            trader,
          ]),
        };
      })
    );
    calls.push(
      ...quotes.map((quote) => {
        return {
          target: this.context.perp.contracts.gate.address,
          callData: gateInterface.encodeFunctionData("thresholdOf", [quote]),
        };
      })
    );
    calls.push(
      ...quotes.map((quote) => {
        return {
          target: this.context.perp.contracts.gate.address,
          callData: gateInterface.encodeFunctionData("reserveOf", [
            quote,
            trader,
          ]),
        };
      })
    );
    calls.push({
      target: this.context.perp.contracts.observer.address,
      callData: observerInterface.encodeFunctionData("getPendings", [
        quotes,
        trader,
      ]),
    });
    const rawRet = (
      await this.context
        .getMulticall3()
        .callStatic.aggregate(calls, overrides ?? {})
    ).returnData;
    const fundFlows = rawRet
      .slice(0, quotes.length)
      .map((ret) => gateInterface.decodeFunctionResult("fundFlowOf", ret)[0]);
    const thresholds = rawRet
      .slice(quotes.length, quotes.length * 2)
      .map((ret) => gateInterface.decodeFunctionResult("thresholdOf", ret)[0]);
    const reserves = rawRet
      .slice(quotes.length * 2, quotes.length * 3)
      .map((ret) => gateInterface.decodeFunctionResult("reserveOf", ret)[0]);
    const decoded = observerInterface.decodeFunctionResult(
      "getPendings",
      rawRet[quotes.length * 3]
    );
    const pendings = decoded[0];
    const blockInfo = (0, utils_1.trimObj)(decoded[1]);
    return {
      pendings: pendings.map((pending, index) => {
        return {
          maxWithdrawable: (0, math_1.calcMaxWithdrawable)(
            thresholds[index],
            pending,
            fundFlows[index],
            reserves[index]
          ),
          pending,
        };
      }),
      blockInfo,
    };
  }
  async inquireByBase(instrumentAddr, expiry, side, baseAmount, overrides) {
    const instrument = typechain_1.Instrument__factory.connect(
      instrumentAddr,
      this.context.provider
    );
    const sign = (0, utils_1.signOfSide)(side);
    const size = baseAmount.mul(sign);
    const quotation = await instrument.inquire(expiry, size, overrides ?? {});
    const entryNotional = quotation.entryNotional;
    return {
      quoteAmount: entryNotional,
      quotation: quotation,
    };
  }
  async inquireByQuote(instrumentAddr, expiry, side, quoteAmount, overrides) {
    const long = side === enum_1.Side.LONG;
    const { size, quotation } =
      await this.context.perp.contracts.observer.inquireByNotional(
        instrumentAddr,
        expiry,
        quoteAmount,
        long,
        overrides ?? {}
      );
    return {
      baseAmount: size.abs(),
      quotation: quotation,
    };
  }
  async getPositionIfSettle(portfolio, amm, overrides) {
    let finalPic = {
      balance: math_1.ZERO,
      size: math_1.ZERO,
      entryNotional: math_1.ZERO,
      entrySocialLossIndex: math_1.ZERO,
      entryFundingIndex: math_1.ZERO,
    };
    const instrumentAddr = portfolio.instrumentAddr;
    const expiry = amm.expiry;
    const ranges = Array.from(portfolio.ranges.values());
    const orders = Array.from(portfolio.orders.values());
    for (const range of ranges) {
      const position = (0, utils_1.rangeToPosition)(range, amm);
      finalPic = (0, lowLevel_1.combine)(amm, finalPic, position).position;
    }
    const ticks = orders.map((o) => o.tick);
    const nonces = orders.map((o) => o.nonce);
    const pearls = await this.context.perp.contracts.observer.getPearls(
      instrumentAddr,
      expiry,
      ticks,
      overrides ?? {}
    );
    const records = await this.context.perp.contracts.observer.getRecords(
      instrumentAddr,
      expiry,
      ticks,
      nonces,
      overrides ?? {}
    );
    for (let i = 0; i < orders.length; i++) {
      const order = orders[i];
      const pearl = pearls[i];
      const record = records[i];
      let position;
      if (pearl.nonce === order.nonce) {
        position = (0, lowLevel_1.cancelOrderToPosition)(
          pearl.left,
          pearl.nonce,
          pearl.taken,
          pearl.fee,
          pearl.entrySocialLossIndex,
          pearl.entryFundingIndex,
          order,
          order.tick,
          order.nonce,
          record
        );
      } else {
        position = (0, lowLevel_1.fillOrderToPosition)(
          pearl.nonce,
          pearl.taken,
          pearl.fee,
          pearl.entrySocialLossIndex,
          pearl.entryFundingIndex,
          order,
          order.tick,
          order.nonce,
          order.size,
          record
        );
      }
      finalPic = (0, lowLevel_1.combine)(amm, finalPic, position).position;
    }
    finalPic = (0, lowLevel_1.combine)(
      amm,
      finalPic,
      portfolio.position
    ).position;
    return utils_1.factory.createPosition({
      ...finalPic,
      instrumentAddr,
      expiry,
      traderAddr: portfolio.traderAddr,
    });
  }
  async getDexV2RawSpotPrice(identifier, overrides) {
    const { baseTokenInfo, quoteTokenInfo } = await (0, utils_1.getTokenInfo)(
      identifier,
      this.context
    );
    const baseScaler = ethers_1.BigNumber.from(10).pow(
      18 - baseTokenInfo.decimals
    );
    const quoteScaler = ethers_1.BigNumber.from(10).pow(
      18 - quoteTokenInfo.decimals
    );
    const isToken0Quote = ethers_1.BigNumber.from(baseTokenInfo.address).gt(
      ethers_1.BigNumber.from(quoteTokenInfo.address)
    );
    const dexV2PairInfo =
      await this.context.perp.contracts.observer.inspectMaxReserveDexV2Pair(
        baseTokenInfo.address,
        quoteTokenInfo.address,
        overrides ?? {}
      );
    if (
      dexV2PairInfo.maxReservePair === context_1.ZERO_ADDRESS ||
      dexV2PairInfo.reserve0.isZero() ||
      dexV2PairInfo.reserve1.isZero()
    ) {
      return math_1.ZERO;
    }
    return isToken0Quote
      ? (0, math_1.wdiv)(
          dexV2PairInfo.reserve0.mul(quoteScaler),
          dexV2PairInfo.reserve1.mul(baseScaler)
        )
      : (0, math_1.wdiv)(
          dexV2PairInfo.reserve1.mul(quoteScaler),
          dexV2PairInfo.reserve0.mul(baseScaler)
        );
  }
  async getCexRawSpotPrice(instrumentIdentifier, overrides) {
    const instrumentAddress =
      await this.context.perp.instrument.computeInstrumentAddress(
        instrumentIdentifier
      );
    const market =
      this.context.perp.contracts.marketContracts[
        instrumentIdentifier.marketType
      ]?.market;
    let rawSpotPrice;
    try {
      rawSpotPrice = await market.getRawPrice(
        instrumentAddress,
        overrides ?? {}
      );
    } catch (e) {
      console.error("fetch chainlink spot price error", e);
      rawSpotPrice = math_1.ZERO;
    }
    return rawSpotPrice;
  }
  async getGateBalance(target, quoteAddrs, overrides) {
    const resp = await this.context.perp.contracts.observer.getVaultBalances(
      target,
      quoteAddrs,
      overrides ?? {}
    );
    const balance = [];
    for (let i = 0; i < quoteAddrs.length; i++) {
      balance.push(resp[0][i]);
    }
    return balance;
  }
  async getGateBalances(target, overrides) {
    const quotes = await Promise.all(
      Object.keys(this.context.perp.configuration.config.quotesParam).map(
        (quote) => this.context.getTokenInfo(quote)
      )
    );
    const gateBalances = await this.getGateBalance(
      target,
      quotes.map((quote) => quote.address),
      overrides
    );
    const results = [];
    for (let i = 0; i < quotes.length; i++) {
      if (gateBalances[i].eq(0)) {
        continue;
      }
      results.push({
        ...quotes[i],
        balance: gateBalances[i],
      });
    }
    return results;
  }
  async getLiquidityDetails(instrumentAddr, expiry, tickDelta, overrides) {
    const liquidityDetails =
      await this.context.perp.contracts.observer.liquidityDetails(
        instrumentAddr,
        expiry,
        tickDelta,
        overrides ?? {}
      );
    const tick2Pearl = new Map();
    for (let i = 0; i < liquidityDetails.tids.length; i++) {
      tick2Pearl.set(liquidityDetails.tids[i], liquidityDetails.pearls[i]);
    }
    return {
      ...(0, utils_1.trimObj)(liquidityDetails),
      tick2Pearl,
    };
  }
}
exports.ObserverModule = ObserverModule;
