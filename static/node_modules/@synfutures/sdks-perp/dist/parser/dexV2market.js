"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DexV2MarketParser = void 0;
const ethers_1 = require("ethers");
const context_1 = require("@derivation-tech/context");
const typechain_1 = require("../typechain");
const utils_1 = require("../utils");
const enum_1 = require("../enum");
const farmat_1 = require("./farmat");
class DexV2MarketParser extends context_1.ContractParser {
  constructor() {
    super(typechain_1.DexV2Market__factory.createInterface());
  }
  async parseBaseParam(_description, param, data) {
    switch (param.name) {
      case "initTime":
      case "time":
        return (0, farmat_1.formatTimestamp)(data);
      case "raw":
      case "spot":
      case "initMark":
      case "initAccumulation":
        return (0, context_1.formatWad)(data);
      case "expiry":
        return (0, utils_1.formatExpiry)(data);
      case "ftype":
        return enum_1.FeederType[Number(data)];
      case "compactEmaParam": {
        return (0, farmat_1.formatCompactEmaParam)(
          ethers_1.BigNumber.from(data)
        );
      }
      default:
        return data.toString();
    }
  }
}
exports.DexV2MarketParser = DexV2MarketParser;
