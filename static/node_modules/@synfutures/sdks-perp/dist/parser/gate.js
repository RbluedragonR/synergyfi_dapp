"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GateParser = void 0;
const context_1 = require("@derivation-tech/context");
const typechain_1 = require("../typechain");
const ethers_1 = require("ethers");
const utils_1 = require("ethers/lib/utils");
const utils_2 = require("../utils");
const enum_1 = require("../enum");
const constants_1 = require("../constants");
const farmat_1 = require("./farmat");
class GateParser extends context_1.ContractParser {
  constructor(ctx) {
    super(typechain_1.Gate__factory.createInterface());
    this.ctx = ctx;
  }
  async formatEncodedFundctionArgs(obj) {
    let str = "{ ";
    for (const [k, v] of Object.entries(obj)) {
      if (ethers_1.ethers.utils.isAddress(v)) {
        str += `${k}: ${await this.parseAddress(v)}, `;
        continue;
      }
      if (k === "limitTicks") {
        str += `minTickLower: ${(0, farmat_1.formatTick)(
          v.toNumber() >> 24
        )}, maxTickUpper: ${(0, farmat_1.formatTick)(
          v.toNumber() & ((1 << 24) - 1)
        )}, `;
      } else {
        str += `${k}: ${this.parseDefaultBaseParam(
          utils_1.ParamType.from({ type: "string", name: k }),
          v
        )}, `;
      }
    }
    str = str.substring(0, str.length - 2) + " }";
    return str;
  }
  async parseBaseArrayParam(description, param, value) {
    if (description.name === "launch" && param.name === "addArgs") {
      return this.formatEncodedFundctionArgs(
        (0, utils_2.decodeAddParam)(value)
      );
    }
    return await super.parseBaseArrayParam(description, param, value);
  }
  async parseBaseParam(description, param, data) {
    switch (param.name) {
      case "arg":
        if (description.name === "deposit" || description.name === "withdraw") {
          const args = (0, utils_2.decodeParamForDepositAndWithdraw)(data);
          const usingNative =
            args.token.toLowerCase() ===
            constants_1.NATIVE_TOKEN_ADDRESS.toLowerCase();
          const quoteInfo = usingNative
            ? this.ctx.wrappedNativeToken
            : await this.ctx.getTokenInfo(args.token);
          return `{quantity:${(0, context_1.formatUnits)(
            args.quantity,
            quoteInfo.decimals
          )}, token:${await this.parseAddress(args.token)}}`;
        }
        return this.parseDefaultBaseParam(param, data);
      case "threshold":
      case "exemption":
      case "amount":
      case "quantity": {
        const quote = description.args["quote"];
        if (quote) {
          const usingNative =
            quote.toLowerCase() ===
            constants_1.NATIVE_TOKEN_ADDRESS.toLowerCase();
          const quoteInfo = usingNative
            ? this.ctx.wrappedNativeToken
            : await this.ctx.getTokenInfo(quote);
          return (
            (0, context_1.formatUnits)(data, quoteInfo.decimals) +
            " " +
            quoteInfo.symbol
          );
        } else {
          return data.toString();
        }
      }
      case "data": {
        if ((0, utils_2.isCexMarket)(description.args["mtype"])) {
          const [base, quote] = ethers_1.ethers.utils.defaultAbiCoder.decode(
            ["string", "address"],
            data
          );
          return `{base: ${base}, quote: ${await this.parseAddress(quote)}}`;
        } else if (description.args["mtype"] === enum_1.MarketType.DEXV2) {
          const [base, quote] = ethers_1.ethers.utils.defaultAbiCoder.decode(
            ["address", "address"],
            data
          );
          return `{base: ${await this.parseAddress(
            base
          )}, quote: ${await this.parseAddress(quote)}}`;
        } else {
          return data.toString();
        }
      }
      default:
        return this.parseDefaultBaseParam(param, data);
    }
  }
  parseDefaultBaseParam(param, data) {
    switch (param.name) {
      case "duration":
        return (Number(data) / 3600).toFixed(2) + " hours";
      case "amount":
        return (0, context_1.formatWad)(data);
      case "timestamp":
        return (0, farmat_1.formatTimestamp)(data);
      case "expiry":
        return (0, utils_2.formatExpiry)(data);
      case "sqrtStrikeLowerPX96":
      case "sqrtStrikeUpperPX96":
        return (0, farmat_1.formatSqrtPX96)(data);
      case "deadline":
        return (0, farmat_1.formatTimestamp)(data);
      default:
        return data.toString();
    }
  }
}
exports.GateParser = GateParser;
