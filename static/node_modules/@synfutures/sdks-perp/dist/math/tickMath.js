"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TickMath = void 0;
const ethers_1 = require("ethers");
const utils_1 = require("../utils");
const constants_1 = require("../constants");
const enum_1 = require("../enum");
const constants_2 = require("./constants");
const basic_1 = require("./basic");
const numeric_1 = require("./numeric");
const calculationError_1 = require("../errors/calculationError");
const utils_2 = require("../utils");
class TickMath {
  static getSqrtRatioAtTick(tick) {
    (0, utils_1.solidityRequire)(
      tick >= TickMath.MIN_TICK &&
        tick <= TickMath.MAX_TICK &&
        Number.isInteger(tick),
      "TICK"
    );
    const absTick = tick < 0 ? tick * -1 : tick;
    let ratio =
      (absTick & 0x1) != 0
        ? ethers_1.BigNumber.from("0xfffcb933bd6fad37aa2d162d1a594001")
        : ethers_1.BigNumber.from("0x100000000000000000000000000000000");
    if ((absTick & 0x2) != 0)
      ratio = (0, basic_1.mulShift)(
        ratio,
        "0xfff97272373d413259a46990580e213a"
      );
    if ((absTick & 0x4) != 0)
      ratio = (0, basic_1.mulShift)(
        ratio,
        "0xfff2e50f5f656932ef12357cf3c7fdcc"
      );
    if ((absTick & 0x8) != 0)
      ratio = (0, basic_1.mulShift)(
        ratio,
        "0xffe5caca7e10e4e61c3624eaa0941cd0"
      );
    if ((absTick & 0x10) != 0)
      ratio = (0, basic_1.mulShift)(
        ratio,
        "0xffcb9843d60f6159c9db58835c926644"
      );
    if ((absTick & 0x20) != 0)
      ratio = (0, basic_1.mulShift)(
        ratio,
        "0xff973b41fa98c081472e6896dfb254c0"
      );
    if ((absTick & 0x40) != 0)
      ratio = (0, basic_1.mulShift)(
        ratio,
        "0xff2ea16466c96a3843ec78b326b52861"
      );
    if ((absTick & 0x80) != 0)
      ratio = (0, basic_1.mulShift)(
        ratio,
        "0xfe5dee046a99a2a811c461f1969c3053"
      );
    if ((absTick & 0x100) != 0)
      ratio = (0, basic_1.mulShift)(
        ratio,
        "0xfcbe86c7900a88aedcffc83b479aa3a4"
      );
    if ((absTick & 0x200) != 0)
      ratio = (0, basic_1.mulShift)(
        ratio,
        "0xf987a7253ac413176f2b074cf7815e54"
      );
    if ((absTick & 0x400) != 0)
      ratio = (0, basic_1.mulShift)(
        ratio,
        "0xf3392b0822b70005940c7a398e4b70f3"
      );
    if ((absTick & 0x800) != 0)
      ratio = (0, basic_1.mulShift)(
        ratio,
        "0xe7159475a2c29b7443b29c7fa6e889d9"
      );
    if ((absTick & 0x1000) != 0)
      ratio = (0, basic_1.mulShift)(
        ratio,
        "0xd097f3bdfd2022b8845ad8f792aa5825"
      );
    if ((absTick & 0x2000) != 0)
      ratio = (0, basic_1.mulShift)(
        ratio,
        "0xa9f746462d870fdf8a65dc1f90e061e5"
      );
    if ((absTick & 0x4000) != 0)
      ratio = (0, basic_1.mulShift)(
        ratio,
        "0x70d869a156d2a1b890bb3df62baf32f7"
      );
    if ((absTick & 0x8000) != 0)
      ratio = (0, basic_1.mulShift)(
        ratio,
        "0x31be135f97d08fd981231505542fcfa6"
      );
    if ((absTick & 0x10000) != 0)
      ratio = (0, basic_1.mulShift)(ratio, "0x9aa508b5b7a84e1c677de54f3e99bc9");
    if ((absTick & 0x20000) != 0)
      ratio = (0, basic_1.mulShift)(ratio, "0x5d6af8dedb81196699c329225ee604");
    if ((absTick & 0x40000) != 0)
      ratio = (0, basic_1.mulShift)(ratio, "0x2216e584f5fa1ea926041bedfe98");
    if ((absTick & 0x80000) != 0)
      ratio = (0, basic_1.mulShift)(ratio, "0x48a170391f7dc42444e8fa2");
    if (tick > 0) ratio = constants_2.MAX_UINT_256.div(ratio);
    return ratio.mod(constants_2.Q32).gt(constants_2.ZERO)
      ? ratio.div(constants_2.Q32).add(constants_2.ONE)
      : ratio.div(constants_2.Q32);
  }
  static getTickAtSqrtRatio(sqrtRatioX96) {
    (0, utils_1.solidityRequire)(
      sqrtRatioX96.gte(TickMath.MIN_SQRT_RATIO) &&
        sqrtRatioX96.lt(TickMath.MAX_SQRT_RATIO),
      "SQRT_RATIO"
    );
    const sqrtRatioX128 = sqrtRatioX96.shl(32);
    const msb = (0, basic_1.mostSignificantBit)(sqrtRatioX128);
    let r;
    if (msb >= 128) {
      r = sqrtRatioX128.shr(msb - 127);
    } else {
      r = sqrtRatioX128.shl(127 - msb);
    }
    let log_2 = ethers_1.BigNumber.from(msb - 128).mul(constants_2.ONE.shl(64));
    let unsignedLog_2 = (0, numeric_1.asUint256)(log_2);
    for (let i = 0; i < 14; i++) {
      r = r.mul(r).shr(127);
      const f = r.shr(128);
      unsignedLog_2 = unsignedLog_2.or(f.shl(63 - i));
      r = r.shr(f.toNumber());
    }
    log_2 = (0, numeric_1.asInt256)(unsignedLog_2);
    const log_sqrt10001 = log_2.mul(
      ethers_1.BigNumber.from("255738958999603826347141")
    );
    const tickLow = (0, numeric_1.forceAsInt24)(
      this.signedShr(
        log_sqrt10001.sub(
          ethers_1.BigNumber.from("3402992956809132418596140100660247210")
        ),
        128
      )
    ).toNumber();
    const tickHigh = (0, numeric_1.forceAsInt24)(
      this.signedShr(
        log_sqrt10001.add(
          ethers_1.BigNumber.from("291339464771989622907027621153398088495")
        ),
        128
      )
    ).toNumber();
    return tickLow === tickHigh
      ? tickLow
      : TickMath.getSqrtRatioAtTick(tickHigh).lte(sqrtRatioX96)
      ? tickHigh
      : tickLow;
  }
  static signedShr(number, bits) {
    const negative = number.isNegative();
    const temp = negative ? (0, numeric_1.asUint256)(number) : number;
    return temp.shr(bits);
  }
  static getWadAtTick(tick) {
    return (0, basic_1.sqrtX96ToWad)(this.getSqrtRatioAtTick(tick));
  }
  static getTickAtPWad(pWad) {
    const sqrtX96 = (0, basic_1.wadToSqrtX96)(pWad);
    return this.getTickAtSqrtRatio(sqrtX96);
  }
  static calcTakenNotional(tick, size) {
    const price = TickMath.getWadAtTick(tick);
    return (0, basic_1.wmul)(price, size.abs());
  }
  static nextInitializedTick(tickBitMap, tick, right) {
    if (right) {
      const compressed = (0, basic_1.signedDiv)(
        tick -
          (0, basic_1.leastNonnegativeRemainder)(
            tick,
            constants_1.PEARL_SPACING
          ),
        constants_1.PEARL_SPACING
      );
      const start = compressed + 1;
      let { wordPos, bitPos } = (0, numeric_1.decompose)(start);
      const word = tickBitMap.get(wordPos) ?? constants_2.ZERO;
      let masked = word.sub(word.mask(bitPos));
      if (!masked.isZero()) {
        return (
          (start + (0, basic_1.leastSignificantBit)(masked) - bitPos) *
          constants_1.PEARL_SPACING
        );
      }
      const UPPER_BOUND =
        (0, basic_1.signedDiv)(
          constants_1.MAX_TICK,
          constants_1.PEARL_SPACING
        ) >> 8;
      while (wordPos < UPPER_BOUND) {
        wordPos++;
        masked = tickBitMap.get(wordPos) ?? constants_2.ZERO;
        if (!masked.isZero()) {
          return (
            (wordPos * 256 + (0, basic_1.leastSignificantBit)(masked)) *
            constants_1.PEARL_SPACING
          );
        }
      }
      throw new calculationError_1.CalculationError(
        "Search tick upward, out of bound",
        { tickBitMap, tick, right }
      );
    } else {
      const compressed = (0, basic_1.signedDiv)(
        tick +
          (0, basic_1.leastNonnegativeComplement)(
            tick,
            constants_1.PEARL_SPACING
          ),
        constants_1.PEARL_SPACING
      );
      const start = compressed - 1;
      let { wordPos, bitPos } = (0, numeric_1.decompose)(start);
      const word = tickBitMap.get(wordPos) ?? constants_2.ZERO;
      let masked = word.mask(bitPos + 1);
      if (!masked.isZero()) {
        return (
          (start - (bitPos - (0, basic_1.mostSignificantBit)(masked))) *
          constants_1.PEARL_SPACING
        );
      }
      const LOWER_BOUND =
        (0, basic_1.signedDiv)(
          constants_1.MIN_TICK,
          constants_1.PEARL_SPACING
        ) >> 8;
      while (wordPos > LOWER_BOUND) {
        wordPos--;
        masked = tickBitMap.get(wordPos) ?? constants_2.ZERO;
        if (!masked.isZero()) {
          return (
            (wordPos * 256 + (0, basic_1.mostSignificantBit)(masked)) *
            constants_1.PEARL_SPACING
          );
        }
      }
      throw new calculationError_1.CalculationError(
        "Search tick down, out of bound",
        { tickBitMap, tick, right }
      );
    }
  }
  static getLimitTick(tradePrice, slippage, side) {
    const sign = (0, utils_1.signOfSide)(side);
    const limitPrice = tradePrice
      .mul(constants_1.ONE_RATIO + sign * slippage)
      .div(constants_1.ONE_RATIO);
    const limitTick = TickMath.getTickAtPWad(limitPrice);
    return side == enum_1.Side.LONG ? limitTick : limitTick + 1;
  }
  static encodeLimitTicks(sqrtStrikeLowerPX96, sqrtStrikeUpperPX96) {
    let strikeLowerTick = sqrtStrikeLowerPX96.eq(0)
      ? constants_1.INT24_MIN
      : TickMath.getTickAtSqrtRatio(sqrtStrikeLowerPX96) + 1;
    strikeLowerTick =
      strikeLowerTick < 0 ? (1 << 24) + strikeLowerTick : strikeLowerTick;
    let strikeUpperTick = sqrtStrikeUpperPX96.eq(0)
      ? constants_1.INT24_MAX
      : TickMath.getTickAtSqrtRatio(sqrtStrikeUpperPX96);
    strikeUpperTick =
      strikeUpperTick < 0 ? (1 << 24) + strikeUpperTick : strikeUpperTick;
    return ethers_1.BigNumber.from(strikeLowerTick)
      .mul(ethers_1.BigNumber.from(2).pow(24))
      .add(strikeUpperTick);
  }
  static async getTickBitMaps(observer, instrument, expiry) {
    const keys = new Array();
    for (let i = -128; i < 128; i++) {
      keys.push(i);
    }
    const res = await observer.getTickBitmaps(instrument, expiry, keys);
    const ret = new Map();
    for (let i = 0; i < keys.length; i++) {
      ret.set(keys[i], res[i]);
    }
    return ret;
  }
  static getTickRangeByAlpha(alphaWad, curTick) {
    const tickDelta = (0, utils_1.alphaWadToTickDelta)(alphaWad);
    let upperTick =
      constants_1.RANGE_SPACING *
      ~~((curTick + tickDelta) / constants_1.RANGE_SPACING);
    let lowerTick =
      constants_1.RANGE_SPACING *
      ~~((curTick - tickDelta) / constants_1.RANGE_SPACING);
    upperTick = utils_2.lowLevel.alignRangeTick(
      Math.min(upperTick, curTick + constants_2.TICK_DELTA_MAX),
      false
    );
    lowerTick = utils_2.lowLevel.alignRangeTick(
      Math.max(lowerTick, curTick - constants_2.TICK_DELTA_MAX),
      true
    );
    return [lowerTick, upperTick];
  }
}
exports.TickMath = TickMath;
TickMath.MIN_TICK = -322517;
TickMath.MAX_TICK = 443636;
TickMath.MIN_SQRT_RATIO = ethers_1.BigNumber.from("7867958450021363558555");
TickMath.MAX_SQRT_RATIO = ethers_1.BigNumber.from(
  "340275971719517849884101479065584693834"
);
