"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SwapMath = void 0;
const constants_1 = require("./constants");
const sqrtPriceMath_1 = require("./sqrtPriceMath");
const tickMath_1 = require("./tickMath");
const basic_1 = require("./basic");
class SwapMath {
  static swapWithinRange(sqrtCurrentPX96, sqrtTargetPX96, liquidity, sizeLeft) {
    const long = sizeLeft.gt(constants_1.ZERO);
    const dxMax = sqrtPriceMath_1.SqrtPriceMath.getDeltaBaseAutoRoundUp(
      sqrtTargetPX96,
      sqrtCurrentPX96,
      liquidity
    );
    let dxAbs = sizeLeft.abs();
    let sqrtPostPX96;
    if (dxAbs.gte(dxMax)) {
      dxAbs = dxMax;
      sqrtPostPX96 = sqrtTargetPX96;
    } else {
      sqrtPostPX96 =
        sqrtPriceMath_1.SqrtPriceMath.getNextSqrtPriceFromDeltaBase(
          sqrtCurrentPX96,
          liquidity,
          dxAbs,
          long
        );
    }
    const dy = sqrtPriceMath_1.SqrtPriceMath.getDeltaQuote(
      sqrtPostPX96,
      sqrtCurrentPX96,
      liquidity,
      long
    );
    const dx = long ? dxAbs : dxAbs.mul(-1);
    return { sqrtPostPX96, dx, dy };
  }
  static swapCrossRange(pair, size) {
    const amm = pair.amm;
    const ticks = [];
    const takens = [];
    const long = size.gt(constants_1.ZERO);
    let totalOrderValue = constants_1.ZERO;
    let totalCurveValue = constants_1.ZERO;
    let swapSize = size;
    const currTickLeft = pair.getPearl(amm.tick).left;
    if (!swapSize.eq(0) && long && currTickLeft.lt(0)) {
      const taken = swapSize.abs().gte(currTickLeft.abs())
        ? currTickLeft
        : swapSize.mul(-1);
      ticks.push(amm.tick);
      takens.push(taken);
      const takenValue = tickMath_1.TickMath.calcTakenNotional(amm.tick, taken);
      swapSize = swapSize.add(taken);
      totalOrderValue = totalOrderValue.add(takenValue);
      if (swapSize.eq(0)) {
        return { liquidity: amm.liquidity, ticks, takens };
      }
    }
    let targetTick = tickMath_1.TickMath.nextInitializedTick(
      pair.tbitmap,
      long ? amm.tick : amm.tick + 1,
      long
    );
    let sqrtPX96State = amm.sqrtPX96;
    let liquidityState = amm.liquidity;
    while (true) {
      const targetPX96 = tickMath_1.TickMath.getSqrtRatioAtTick(targetTick);
      const { sqrtPostPX96, dx, dy } = SwapMath.swapWithinRange(
        sqrtPX96State,
        targetPX96,
        liquidityState,
        swapSize
      );
      sqrtPX96State = sqrtPostPX96;
      swapSize = swapSize.sub(dx);
      totalCurveValue = totalCurveValue.add(dy);
      if (sqrtPostPX96 == targetPX96) {
        const left = pair.getPearl(targetTick).left;
        if (
          !swapSize.eq(0) &&
          ((long && left.lt(0)) || (!long && left.gt(0)))
        ) {
          const taken = swapSize.abs().gte(left.abs())
            ? left
            : swapSize.mul(-1);
          ticks.push(targetTick);
          takens.push(taken);
          const takenValue = tickMath_1.TickMath.calcTakenNotional(
            targetTick,
            taken
          );
          swapSize = swapSize.add(taken);
          totalOrderValue = totalOrderValue.add(takenValue);
        }
        const isRangeEnd = pair.getPearl(targetTick).liquidityGross.gt(0);
        const lastLiquidity = liquidityState;
        if (isRangeEnd) {
          let liqNet = pair.getPearl(targetTick).liquidityNet;
          if (!long) liqNet = (0, basic_1.neg)(liqNet);
          liquidityState = liquidityState.add(liqNet);
        }
        if (swapSize.eq(constants_1.ZERO)) {
          if (!long) {
            liquidityState = lastLiquidity;
          }
          break;
        }
        targetTick = tickMath_1.TickMath.nextInitializedTick(
          pair.tbitmap,
          targetTick,
          long
        );
      } else {
        break;
      }
    }
    return { liquidity: liquidityState, ticks, takens };
  }
}
exports.SwapMath = SwapMath;
