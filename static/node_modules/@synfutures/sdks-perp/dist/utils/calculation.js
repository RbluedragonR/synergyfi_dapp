"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.positionLiquidationPrice = positionLiquidationPrice;
exports.positionUnrealizedSocialLoss = positionUnrealizedSocialLoss;
exports.positionUnrealizedPnl = positionUnrealizedPnl;
exports.positionUnrealizedPnlByFairPrice = positionUnrealizedPnlByFairPrice;
exports.positionUnrealizedFundingFee = positionUnrealizedFundingFee;
exports.positionEquity = positionEquity;
exports.positionLeverage = positionLeverage;
exports.positionMaxWithdrawableMargin = positionMaxWithdrawableMargin;
exports.positionAdditionMarginToIMRSafe = positionAdditionMarginToIMRSafe;
exports.isPositionIMSafe = isPositionIMSafe;
exports.isPositionMMSafe = isPositionMMSafe;
exports.rangeEntryDeltaBase = rangeEntryDeltaBase;
exports.rangeEntryDeltaQuote = rangeEntryDeltaQuote;
exports.rangeToPosition = rangeToPosition;
exports.rangeValueLocked = rangeValueLocked;
exports.rangeFeeEarned = rangeFeeEarned;
exports.rangeLowerPositionIfRemove = rangeLowerPositionIfRemove;
exports.rangeUpperPositionIfRemove = rangeUpperPositionIfRemove;
exports.orderToPosition = orderToPosition;
exports.orderLeverage = orderLeverage;
exports.orderEquity = orderEquity;
exports.ammPlaceOrderLimit = ammPlaceOrderLimit;
exports.ammPlaceCrossMarketOrderLimit = ammPlaceCrossMarketOrderLimit;
exports.ammWithinDeviationLimit = ammWithinDeviationLimit;
exports.getMinLiquidity = getMinLiquidity;
exports.getFundingRate = getFundingRate;
exports.getBenchmarkPrice = getBenchmarkPrice;
exports.estimateAPY = estimateAPY;
exports.estimateAdjustMarginLeverage = estimateAdjustMarginLeverage;
exports.inquireLeverageFromTransferAmount = inquireLeverageFromTransferAmount;
exports.inquireTransferAmountFromTargetLeverage =
  inquireTransferAmountFromTargetLeverage;
exports.calcLimitOrderTickBoundary = calcLimitOrderTickBoundary;
exports.calcCrossMarketOrderTickBoundary = calcCrossMarketOrderTickBoundary;
const context_1 = require("@derivation-tech/context");
const constants_1 = require("../constants");
const math_1 = require("../math");
const enum_1 = require("../enum");
const constants_2 = require("../constants");
const reverse_1 = require("./reverse");
const factory_1 = require("./factory");
const utils_1 = require("./utils");
const lowLevel_1 = require("./lowLevel");
const synfError_1 = require("../errors/synfError");
function toRawPosition(position) {
  if ("instrumentAddr" in position) {
    const _position = position;
    return _position.isInverse
      ? (0, reverse_1.reversePosition)(_position)
      : _position;
  } else {
    return position;
  }
}
function toRawAmm(amm) {
  if ("instrumentAddr" in amm) {
    const _amm = amm;
    return _amm.isInverse ? (0, reverse_1.reverseAmm)(_amm) : _amm;
  } else {
    return amm;
  }
}
function toRawRange(range) {
  if ("instrumentAddr" in range) {
    const _range = range;
    return _range.isInverse ? (0, reverse_1.reverseRange)(_range) : _range;
  } else {
    return range;
  }
}
function toRawOrder(order) {
  if ("instrumentAddr" in order) {
    const _order = order;
    return _order.isInverse ? (0, reverse_1.reverseOrder)(_order) : _order;
  } else {
    return order;
  }
}
function positionLiquidationPrice(
  position,
  amm = constants_1.EMPTY_AMM,
  maintenanceMarginRatio = 500
) {
  const _position = position;
  position = toRawPosition(position);
  amm = toRawAmm(amm);
  if (position.size.isZero() || position.balance.isZero()) {
    return math_1.ZERO;
  }
  const price = (0, lowLevel_1.calcLiquidationPrice)(
    amm,
    position,
    maintenanceMarginRatio
  );
  return _position.isInverse ? (0, reverse_1.reversePrice)(price) : price;
}
function positionUnrealizedSocialLoss(position, amm) {
  position = toRawPosition(position);
  amm = toRawAmm(amm);
  const { socialLoss } = (0, lowLevel_1.tally)(amm, position, amm.markPrice);
  return socialLoss;
}
function positionUnrealizedPnl(position, amm) {
  position = toRawPosition(position);
  amm = toRawAmm(amm);
  return (0, lowLevel_1.calcPnl)(amm, position, amm.markPrice);
}
function positionUnrealizedPnlByFairPrice(position, amm) {
  position = toRawPosition(position);
  amm = toRawAmm(amm);
  return (0, lowLevel_1.calcPnl)(
    amm,
    position,
    (0, math_1.sqrtX96ToWad)(amm.sqrtPX96)
  );
}
function positionUnrealizedFundingFee(position, amm) {
  if (amm.expiry !== constants_1.PERP_EXPIRY) {
    return math_1.ZERO;
  }
  position = toRawPosition(position);
  amm = toRawAmm(amm);
  return (0, lowLevel_1.calcFundingFee)(amm, position);
}
function positionEquity(position, amm) {
  position = toRawPosition(position);
  amm = toRawAmm(amm);
  return position.balance.add(positionUnrealizedPnl(position, amm));
}
function positionLeverage(position, amm) {
  position = toRawPosition(position);
  amm = toRawAmm(amm);
  const value = (0, math_1.wmul)(amm.markPrice, position.size.abs());
  const equity = positionEquity(position, amm);
  if (equity.isZero()) {
    return math_1.ZERO;
  }
  return (0, math_1.wdiv)(value, equity);
}
function positionMaxWithdrawableMargin(position, amm, initialMarginRatio) {
  position = toRawPosition(position);
  amm = toRawAmm(amm);
  const { pnl, socialLoss } = (0, lowLevel_1.tally)(
    amm,
    position,
    amm.markPrice
  );
  const funding = (0, lowLevel_1.calcFundingFee)(amm, position);
  const purePnl = pnl.add(socialLoss).sub(funding);
  const unrealizedLoss = (purePnl.gt(math_1.ZERO) ? math_1.ZERO : purePnl).sub(
    socialLoss
  );
  const value = (0, math_1.wmulUp)(amm.markPrice, position.size.abs());
  const imRequirement = (0, math_1.wmulUp)(
    value,
    (0, math_1.r2w)(initialMarginRatio)
  );
  const maxWithdrawableMargin = position.balance
    .add(unrealizedLoss)
    .sub(imRequirement);
  return maxWithdrawableMargin.gt(math_1.ZERO)
    ? maxWithdrawableMargin
    : math_1.ZERO;
}
function positionAdditionMarginToIMRSafe(
  position,
  amm,
  initialMarginRatio,
  increase,
  slippage
) {
  position = toRawPosition(position);
  amm = toRawAmm(amm);
  const positionValue = (0, math_1.wmul)(amm.markPrice, position.size.abs());
  let imrValue = (0, math_1.wmulUp)(
    positionValue,
    (0, math_1.r2w)(initialMarginRatio)
  );
  if (slippage) {
    imrValue = imrValue
      .mul(constants_1.ONE_RATIO + slippage)
      .div(constants_1.ONE_RATIO);
  }
  let equity;
  if (increase) {
    const unrealizedPnl = positionUnrealizedPnl(position, amm);
    const unrealizedLoss = unrealizedPnl.lt(math_1.ZERO)
      ? unrealizedPnl
      : math_1.ZERO;
    equity = position.balance.add(unrealizedLoss);
  } else {
    equity = positionEquity(position, amm);
  }
  const additionMargin = imrValue.sub(equity);
  return additionMargin.gt(math_1.ZERO) ? additionMargin : math_1.ZERO;
}
function isPositionIMSafe(position, amm, initialMarginRatio, increase) {
  position = toRawPosition(position);
  amm = toRawAmm(amm);
  let equity;
  if (increase) {
    const unrealizedPnl = positionUnrealizedPnl(position, amm);
    const unrealizedLoss = unrealizedPnl.lt(math_1.ZERO)
      ? unrealizedPnl
      : math_1.ZERO;
    equity = position.balance.add(unrealizedLoss);
  } else {
    equity = positionEquity(position, amm);
  }
  if (equity.isNegative()) {
    return false;
  }
  const positionValue = (0, math_1.wmulUp)(amm.markPrice, position.size.abs());
  return equity.gte(
    (0, math_1.wmulUp)(positionValue, (0, math_1.r2w)(initialMarginRatio))
  );
}
function isPositionMMSafe(position, amm, maintenanceMarginRatio) {
  position = toRawPosition(position);
  amm = toRawAmm(amm);
  const equity = positionEquity(position, amm);
  if (equity.isNegative()) {
    return false;
  }
  const positionValue = (0, math_1.wmulUp)(amm.markPrice, position.size.abs());
  return equity.gte(
    (0, math_1.wmulUp)(positionValue, (0, math_1.r2w)(maintenanceMarginRatio))
  );
}
function rangeEntryDeltaBase(range) {
  range = toRawRange(range);
  const sqrtUpperPX96 = math_1.TickMath.getSqrtRatioAtTick(range.tickUpper);
  return math_1.SqrtPriceMath.getDeltaBaseAutoRoundUp(
    range.sqrtEntryPX96,
    sqrtUpperPX96,
    range.liquidity
  );
}
function rangeEntryDeltaQuote(range) {
  range = toRawRange(range);
  const sqrtLowerPX96 = math_1.TickMath.getSqrtRatioAtTick(range.tickLower);
  return math_1.SqrtPriceMath.getDeltaQuoteAutoRoundUp(
    sqrtLowerPX96,
    range.sqrtEntryPX96,
    range.liquidity
  );
}
function rangeToPosition(range, amm) {
  const _range = range;
  range = toRawRange(range);
  amm = toRawAmm(amm);
  const sqrtUpperPX96 = math_1.TickMath.getSqrtRatioAtTick(range.tickUpper);
  const sqrtLowerPX96 = math_1.TickMath.getSqrtRatioAtTick(range.tickLower);
  const fair = (0, math_1.sqrtX96ToWad)(amm.sqrtPX96);
  const entryDeltaBase = rangeEntryDeltaBase(range);
  const entryDeltaQuote = rangeEntryDeltaQuote(range);
  let removeDeltaBase = math_1.ZERO;
  let removeDeltaQuote = math_1.ZERO;
  if (amm.tick < range.tickLower) {
    removeDeltaBase = math_1.SqrtPriceMath.getDeltaBaseAutoRoundUp(
      sqrtLowerPX96,
      math_1.TickMath.getSqrtRatioAtTick(range.tickUpper),
      range.liquidity
    );
  } else if (amm.tick < range.tickUpper) {
    removeDeltaBase = math_1.SqrtPriceMath.getDeltaBaseAutoRoundUp(
      amm.sqrtPX96,
      math_1.TickMath.getSqrtRatioAtTick(range.tickUpper),
      range.liquidity
    );
    removeDeltaQuote = math_1.SqrtPriceMath.getDeltaQuoteAutoRoundUp(
      sqrtLowerPX96,
      amm.sqrtPX96,
      range.liquidity
    );
  } else {
    removeDeltaQuote = math_1.SqrtPriceMath.getDeltaQuoteAutoRoundUp(
      sqrtLowerPX96,
      sqrtUpperPX96,
      range.liquidity
    );
  }
  const earnedByBase = (0, math_1.wmul)(
    removeDeltaBase.sub(entryDeltaBase),
    fair
  );
  const earnedByQuote = removeDeltaQuote.sub(entryDeltaQuote);
  const pnl = earnedByBase.add(earnedByQuote);
  const fee = (0, math_1.wmulDown)(
    amm.feeIndex.sub(range.entryFeeIndex),
    range.liquidity
  );
  const size = removeDeltaBase.sub(entryDeltaBase);
  const rawPosition = {
    balance: range.balance.add(fee).add(pnl).sub(math_1.ONE),
    size: size,
    entryNotional: (0, math_1.wmul)(fair, size.abs()),
    entrySocialLossIndex: size.gt(math_1.ZERO)
      ? amm.longSocialLossIndex
      : amm.shortSocialLossIndex,
    entryFundingIndex: size.gt(math_1.ZERO)
      ? amm.longFundingIndex
      : amm.shortFundingIndex,
  };
  if ("instrumentAddr" in _range) {
    const __range = _range;
    const position = (0, factory_1.createPosition)({
      instrumentAddr: __range.instrumentAddr,
      expiry: __range.expiry,
      traderAddr: __range.traderAddr,
      ...rawPosition,
    });
    return __range.isInverse
      ? (0, reverse_1.reversePosition)(position)
      : position;
  } else {
    return rawPosition;
  }
}
function rangeValueLocked(range, amm) {
  range = toRawRange(range);
  amm = toRawAmm(amm);
  const position = rangeToPosition(range, amm);
  const total = (0, lowLevel_1.tally)(amm, position, amm.markPrice);
  return total.equity;
}
function rangeFeeEarned(range, amm) {
  range = toRawRange(range);
  amm = toRawAmm(amm);
  return (0, math_1.wmulDown)(
    amm.feeIndex.sub(range.entryFeeIndex),
    range.liquidity
  );
}
function customAmm(tick, input) {
  return {
    ...input,
    tick,
    sqrtPX96: math_1.TickMath.getSqrtRatioAtTick(tick),
  };
}
function rangeLowerPositionIfRemove(range, amm) {
  const _range = range;
  range = toRawRange(range);
  amm = toRawAmm(amm);
  const rawPosition = rangeToPosition(range, customAmm(range.tickLower, amm));
  if ("instrumentAddr" in _range) {
    const __range = _range;
    const position = (0, factory_1.createPosition)({
      instrumentAddr: __range.instrumentAddr,
      expiry: __range.expiry,
      traderAddr: __range.traderAddr,
      ...rawPosition,
    });
    return __range.isInverse
      ? (0, reverse_1.reversePosition)(position)
      : position;
  } else {
    return rawPosition;
  }
}
function rangeUpperPositionIfRemove(range, amm) {
  const _range = range;
  range = toRawRange(range);
  amm = toRawAmm(amm);
  const rawPosition = rangeToPosition(range, customAmm(range.tickUpper, amm));
  if ("instrumentAddr" in _range) {
    const __range = _range;
    const position = (0, factory_1.createPosition)({
      instrumentAddr: __range.instrumentAddr,
      expiry: __range.expiry,
      traderAddr: __range.traderAddr,
      ...rawPosition,
    });
    return __range.isInverse
      ? (0, reverse_1.reversePosition)(position)
      : position;
  } else {
    return rawPosition;
  }
}
function orderToPosition(order) {
  const _order = order;
  order = toRawOrder(order);
  const rawPosition = {
    balance: order.balance,
    size: order.size,
    entryNotional: (0, math_1.wmul)(
      math_1.TickMath.getWadAtTick(order.tick),
      order.size.abs()
    ),
    entrySocialLossIndex: math_1.ZERO,
    entryFundingIndex: math_1.ZERO,
  };
  if ("instrumentAddr" in _order) {
    const __order = _order;
    const position = (0, factory_1.createPosition)({
      instrumentAddr: __order.instrumentAddr,
      expiry: __order.expiry,
      traderAddr: __order.traderAddr,
      ...rawPosition,
    });
    return __order.isInverse
      ? (0, reverse_1.reversePosition)(position)
      : position;
  } else {
    return rawPosition;
  }
}
function orderLeverage(order, amm) {
  order = toRawOrder(order);
  amm = toRawAmm(amm);
  const limitPrice = math_1.TickMath.getWadAtTick(order.tick);
  const px = order.taken.eq(math_1.ZERO) ? limitPrice : amm.markPrice;
  const value = (0, math_1.wmul)(px, order.size.abs());
  return (0, math_1.wdiv)(value, order.balance);
}
function orderEquity(order, amm) {
  order = toRawOrder(order);
  amm = toRawAmm(amm);
  return positionEquity(orderToPosition(order), amm);
}
function ammPlaceOrderLimit(amm, initialMarginRatio) {
  const _amm = amm;
  amm = toRawAmm(amm);
  const maxDiff = (0, math_1.wmul)(
    amm.markPrice,
    (0, math_1.r2w)(initialMarginRatio)
  ).mul(2);
  const rawUpperTick = math_1.TickMath.getTickAtPWad(
    amm.markPrice.add(maxDiff)
  );
  const rawLowerTick = math_1.TickMath.getTickAtPWad(
    amm.markPrice.sub(maxDiff)
  );
  let upperTick =
    constants_1.ORDER_SPACING *
    Math.floor(rawUpperTick / constants_1.ORDER_SPACING);
  let lowerTick =
    constants_1.ORDER_SPACING *
    Math.ceil(rawLowerTick / constants_1.ORDER_SPACING);
  if (
    !(0, lowLevel_1.withinOrderLimit)(
      math_1.TickMath.getWadAtTick(rawUpperTick),
      amm.markPrice,
      initialMarginRatio
    )
  ) {
    upperTick = upperTick - constants_1.ORDER_SPACING;
  }
  if (
    !(0, lowLevel_1.withinOrderLimit)(
      math_1.TickMath.getWadAtTick(rawLowerTick),
      amm.markPrice,
      initialMarginRatio
    )
  ) {
    lowerTick = lowerTick + constants_1.ORDER_SPACING;
  }
  return _amm.isInverse
    ? {
        upperTick: lowerTick,
        lowerTick: upperTick,
      }
    : {
        upperTick,
        lowerTick,
      };
}
function ammPlaceCrossMarketOrderLimit(amm, maintenanceMarginRatio) {
  const _amm = amm;
  amm = toRawAmm(amm);
  const priceLower = amm.markPrice.sub(
    (0, math_1.wmul)(amm.markPrice, (0, math_1.r2w)(maintenanceMarginRatio))
  );
  const priceUpper = amm.markPrice.add(
    (0, math_1.wmul)(amm.markPrice, (0, math_1.r2w)(maintenanceMarginRatio))
  );
  const upperTick =
    constants_1.ORDER_SPACING *
    Math.floor(
      math_1.TickMath.getTickAtPWad(priceUpper) / constants_1.ORDER_SPACING
    );
  const lowerTick =
    constants_1.ORDER_SPACING *
    Math.ceil(
      math_1.TickMath.getTickAtPWad(priceLower) / constants_1.ORDER_SPACING
    );
  return _amm.isInverse
    ? {
        upperTick: lowerTick,
        lowerTick: upperTick,
      }
    : {
        upperTick,
        lowerTick,
      };
}
function ammWithinDeviationLimit(amm, initialMarginRatio) {
  amm = toRawAmm(amm);
  return (0, lowLevel_1.withinDeviationLimit)(
    (0, math_1.sqrtX96ToWad)(amm.sqrtPX96),
    amm.markPrice,
    initialMarginRatio
  );
}
function getMinLiquidity(instrument, expiry, px96) {
  instrument = instrument.isInverse
    ? (0, reverse_1.reverseInstrument)(instrument)
    : instrument;
  const amm = instrument.amms.get(expiry);
  if (!amm) {
    throw new synfError_1.SynfError(
      "Pair not found," +
        `instrument: ${instrument.instrumentAddr}, expiry: ${expiry}`
    );
  }
  const sqrtPX96 = px96 ? px96 : amm.sqrtPX96;
  return instrument.minRangeValue.mul(math_1.Q96).div(sqrtPX96.mul(2));
}
function getFundingRate(instrument, expiry) {
  const _instrument = instrument;
  instrument = instrument.isInverse
    ? (0, reverse_1.reverseInstrument)(instrument)
    : instrument;
  if (instrument.spotPrice.eq(0)) {
    throw new synfError_1.SynfError("Spot price can not be zero");
  }
  const amm = instrument.amms.get(expiry);
  if (!amm) {
    throw new synfError_1.SynfError("Pair not found");
  }
  const period = instrument.fundingHour * 3600;
  const result = (0, math_1.wdiv)(
    (0, math_1.sqrtX96ToWad)(amm.sqrtPX96),
    instrument.spotPrice
  )
    .sub(math_1.WAD)
    .mul(86400)
    .div(period);
  return _instrument.isInverse ? result.mul(-1) : result;
}
function getBenchmarkPrice(instrument, expiry) {
  instrument = instrument.isInverse
    ? (0, reverse_1.reverseInstrument)(instrument)
    : instrument;
  if (expiry === constants_1.PERP_EXPIRY) {
    return instrument.spotPrice;
  } else {
    const rawSpotPrice = instrument.spotPrice;
    const daysLeft =
      Date.now() / 1000 >= expiry
        ? 0
        : ~~(expiry * 1000 - Date.now()) / (86400 * 1000) + 1;
    const instrumentType = instrument.market.feeder.ftype;
    if (
      instrumentType === enum_1.FeederType.BOTH_STABLE ||
      instrumentType === enum_1.FeederType.NONE_STABLE
    ) {
      return instrument.spotPrice;
    } else if (instrumentType === enum_1.FeederType.QUOTE_STABLE) {
      return (0, math_1.wmulDown)(
        rawSpotPrice,
        (0, math_1.r2w)(instrument.market.config.dailyInterestRate)
      )
        .mul(daysLeft)
        .add(rawSpotPrice);
    } else {
      const priceChange = (0, math_1.wmulDown)(
        rawSpotPrice,
        (0, math_1.r2w)(instrument.market.config.dailyInterestRate)
      ).mul(daysLeft);
      return rawSpotPrice.gt(priceChange)
        ? rawSpotPrice.sub(priceChange)
        : math_1.ZERO;
    }
  }
}
function estimateAPY(instrument, expiry, poolFee24h, alphaWad) {
  instrument = instrument.isInverse
    ? (0, reverse_1.reverseInstrument)(instrument)
    : instrument;
  const amm = instrument.amms.get(expiry);
  if (!amm || amm.liquidity.eq(math_1.ZERO)) {
    return 0;
  }
  const assumeAddMargin = instrument.minRangeValue;
  const tickDelta = (0, utils_1.alphaWadToTickDelta)(alphaWad);
  const upperTick =
    constants_2.RANGE_SPACING *
    ~~((amm.tick + tickDelta) / constants_2.RANGE_SPACING);
  const lowerTick =
    constants_2.RANGE_SPACING *
    ~~((amm.tick - tickDelta) / constants_2.RANGE_SPACING);
  const { liquidity: assumeAddLiquidity } = (0, lowLevel_1.entryDelta)(
    amm.sqrtPX96,
    lowerTick,
    upperTick,
    assumeAddMargin,
    instrument.setting.initialMarginRatio
  );
  const assumed24HrFee = poolFee24h.mul(assumeAddLiquidity).div(amm.liquidity);
  const apyWad = (0, math_1.wdiv)(assumed24HrFee.mul(365), assumeAddMargin);
  return (0, context_1.fromWad)(apyWad);
}
function estimateAdjustMarginLeverage(position, amm, amount) {
  position = toRawPosition(position);
  amm = toRawAmm(amm);
  const equity = positionEquity(position, amm).sub(amount);
  const value = (0, math_1.wmul)(amm.markPrice, position.size.abs()).sub(
    amount
  );
  return (0, math_1.wdiv)(value, equity);
}
function inquireLeverageFromTransferAmount(
  position,
  amm,
  transferIn,
  transferAmount
) {
  position = toRawPosition(position);
  amm = toRawAmm(amm);
  const sign = transferIn ? 1 : -1;
  const value = (0, math_1.wmul)(amm.markPrice, position.size.abs());
  const oldEquity = positionEquity(position, amm);
  const Amount = transferAmount.mul(sign);
  const newEquity = oldEquity.add(Amount);
  return (0, math_1.wdiv)(value, newEquity);
}
function inquireTransferAmountFromTargetLeverage(
  position,
  amm,
  targetLeverage
) {
  position = toRawPosition(position);
  amm = toRawAmm(amm);
  const value = (0, math_1.wmul)(amm.markPrice, position.size.abs());
  const targetEquity = (0, math_1.wdiv)(value, targetLeverage);
  const currentEquity = positionEquity(position, amm);
  return targetEquity.sub(currentEquity);
}
function calcLimitOrderTickBoundary(amm, initialMarginRatio, side) {
  const _amm = amm;
  if (_amm.isInverse) {
    side = (0, reverse_1.reverseSide)(side);
  }
  let currentTick =
    Math.floor(amm.tick / constants_1.PEARL_SPACING) *
    constants_1.PEARL_SPACING;
  if (side === enum_1.Side.LONG) {
    if (currentTick === amm.tick) {
      currentTick = currentTick - constants_1.PEARL_SPACING;
    }
  } else {
    currentTick = currentTick + constants_1.PEARL_SPACING;
  }
  const { upperTick, lowerTick } = ammPlaceOrderLimit(amm, initialMarginRatio);
  if (_amm.isInverse) {
    if (side === enum_1.Side.SHORT) {
      return {
        upperTick: lowerTick,
        lowerTick: currentTick,
      };
    } else {
      return {
        upperTick: currentTick,
        lowerTick: upperTick,
      };
    }
  } else {
    if (side === enum_1.Side.LONG) {
      return {
        upperTick: currentTick,
        lowerTick: lowerTick,
      };
    } else {
      return {
        upperTick: upperTick,
        lowerTick: currentTick,
      };
    }
  }
}
function calcCrossMarketOrderTickBoundary(
  amm,
  initialMarginRatio,
  maintenanceMarginRatio,
  side
) {
  const _amm = amm;
  if (_amm.isInverse) {
    side = (0, reverse_1.reverseSide)(side);
  }
  const { upperTick, lowerTick } = ammPlaceOrderLimit(amm, initialMarginRatio);
  const { upperTick: _upperTick, lowerTick: _lowerTick } =
    ammPlaceCrossMarketOrderLimit(amm, maintenanceMarginRatio);
  if (_amm.isInverse) {
    if (side === enum_1.Side.SHORT) {
      return {
        upperTick: lowerTick,
        lowerTick: _upperTick,
      };
    } else {
      return {
        upperTick: _lowerTick,
        lowerTick: upperTick,
      };
    }
  } else {
    if (side === enum_1.Side.LONG) {
      return {
        upperTick: _upperTick,
        lowerTick,
      };
    } else {
      return {
        upperTick,
        lowerTick: _lowerTick,
      };
    }
  }
}
