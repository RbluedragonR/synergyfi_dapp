"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLatestFundingIndex = getLatestFundingIndex;
exports.updateFundingIndex = updateFundingIndex;
exports.withinOrderLimit = withinOrderLimit;
exports.withinDeviationLimit = withinDeviationLimit;
exports.calcBenchmarkPrice = calcBenchmarkPrice;
exports.calcMinTickDelta = calcMinTickDelta;
exports.getBatchOrderRatios = getBatchOrderRatios;
exports.requiredMarginForOrder = requiredMarginForOrder;
exports.fillOrderToPosition = fillOrderToPosition;
exports.cancelOrderToPosition = cancelOrderToPosition;
exports.tally = tally;
exports.calcLiquidationPrice = calcLiquidationPrice;
exports.calculatePriceFromPnl = calculatePriceFromPnl;
exports.calcFundingFee = calcFundingFee;
exports.calcPnl = calcPnl;
exports.realizeFundingWithPnl = realizeFundingWithPnl;
exports.realizeFundingIncome = realizeFundingIncome;
exports.realizeSocialLoss = realizeSocialLoss;
exports.combine = combine;
exports.splitPosition = splitPosition;
exports.entryDelta = entryDelta;
exports.alignRangeTick = alignRangeTick;
exports.getLiquidityFromMarginByUpper = getLiquidityFromMarginByUpper;
exports.getLiquidityFromMarginByLower = getLiquidityFromMarginByLower;
exports.getMarginFromLiquidity = getMarginFromLiquidity;
const ethers_1 = require("ethers");
const context_1 = require("@derivation-tech/context");
const constants_1 = require("../constants");
const math_1 = require("../math");
const enum_1 = require("../enum");
const synfError_1 = require("../errors/synfError");
function getLatestFundingIndex(amm, markPrice, timestamp) {
  return updateFundingIndex(amm, markPrice, timestamp);
}
function updateFundingIndex(amm, mark, timestamp) {
  const timeElapsed = timestamp - amm.timestamp;
  if (timeElapsed == 0)
    return {
      longFundingIndex: amm.longFundingIndex,
      shortFundingIndex: amm.shortFundingIndex,
    };
  const fair = (0, math_1.sqrtX96ToWad)(amm.sqrtPX96);
  const longPayShort = fair.gt(mark);
  const [payerSize, receiverSize] = longPayShort
    ? [amm.totalLong, amm.totalShort]
    : [amm.totalShort, amm.totalLong];
  const fundingFeeIndex = (0, math_1.frac)(
    fair.sub(mark).abs(),
    ethers_1.BigNumber.from(timeElapsed),
    ethers_1.BigNumber.from(context_1.SECS_PER_DAY)
  );
  if (payerSize.gt(0)) {
    let [payerIndex, receiverIndex] = longPayShort
      ? [amm.longFundingIndex, amm.shortFundingIndex]
      : [amm.shortFundingIndex, amm.longFundingIndex];
    payerIndex = payerIndex.sub(fundingFeeIndex);
    const totalFundingFee = (0, math_1.wmul)(fundingFeeIndex, payerSize);
    if (receiverSize.gt(0)) {
      receiverIndex = receiverIndex.add(
        (0, math_1.wdiv)(totalFundingFee, receiverSize)
      );
    }
    return longPayShort
      ? { longFundingIndex: payerIndex, shortFundingIndex: receiverIndex }
      : { longFundingIndex: receiverIndex, shortFundingIndex: payerIndex };
  }
  return {
    longFundingIndex: amm.longFundingIndex,
    shortFundingIndex: amm.shortFundingIndex,
  };
}
function withinOrderLimit(limitPrice, markPrice, imr) {
  return (0, math_1.wdiv)(limitPrice.sub(markPrice).abs(), markPrice).lte(
    (0, math_1.r2w)(imr).mul(2)
  );
}
function withinDeviationLimit(fairPrice, markPrice, imr) {
  return (0, math_1.wdiv)(fairPrice.sub(markPrice).abs(), markPrice).lte(
    (0, math_1.r2w)(imr)
  );
}
function calcBenchmarkPrice(
  expiry,
  rawSpotPrice,
  feederType,
  dailyInterestRate
) {
  if (expiry == constants_1.PERP_EXPIRY) {
    return rawSpotPrice;
  } else {
    const daysLeft =
      Date.now() / 1000 >= expiry
        ? 0
        : Math.floor(
            (expiry * 1000 - Date.now()) / (context_1.SECS_PER_DAY * 1000)
          ) + 1;
    if (
      feederType === enum_1.FeederType.BOTH_STABLE ||
      feederType === enum_1.FeederType.NONE_STABLE
    ) {
      return rawSpotPrice;
    } else if (feederType === enum_1.FeederType.QUOTE_STABLE) {
      return (0, math_1.wmulDown)(
        rawSpotPrice,
        (0, math_1.r2w)(dailyInterestRate)
      )
        .mul(daysLeft)
        .add(rawSpotPrice);
    } else {
      const priceChange = (0, math_1.wmulDown)(
        rawSpotPrice,
        (0, math_1.r2w)(dailyInterestRate)
      ).mul(daysLeft);
      return rawSpotPrice.gt(priceChange)
        ? rawSpotPrice.sub(priceChange)
        : math_1.ZERO;
    }
  }
}
function calcMinTickDelta(initialMarginRatio) {
  return (0, math_1.wadToTick)(
    (0, math_1.r2w)(initialMarginRatio).add(math_1.WAD)
  );
}
function getBatchOrderRatios(sizeDistribution, orderCount) {
  let ratios = [];
  switch (sizeDistribution) {
    case enum_1.BatchOrderSizeDistribution.FLAT: {
      ratios = Array(orderCount).fill(
        Math.floor(constants_1.RATIO_BASE / orderCount)
      );
      break;
    }
    case enum_1.BatchOrderSizeDistribution.UPPER: {
      const sum = Array.from({ length: orderCount }, (_, i) => i + 1).reduce(
        (acc, i) => acc + i,
        0
      );
      ratios = Array.from({ length: orderCount }, (_, i) =>
        Math.floor((i + 1) * (constants_1.RATIO_BASE / sum))
      );
      break;
    }
    case enum_1.BatchOrderSizeDistribution.LOWER: {
      const sum = Array.from(
        { length: orderCount },
        (_, i) => orderCount - i
      ).reduce((acc, i) => acc + i, 0);
      ratios = Array.from({ length: orderCount }, (_, i) =>
        Math.floor((orderCount - i) * (constants_1.RATIO_BASE / sum))
      );
      break;
    }
    case enum_1.BatchOrderSizeDistribution.RANDOM: {
      let totalRatio = 0;
      const averageRatio = constants_1.RATIO_BASE / orderCount;
      const minRatio = Math.ceil(averageRatio * 0.95);
      const maxRatio = Math.floor(averageRatio * 1.05);
      for (let i = 0; i < orderCount; i++) {
        let ratio = Math.floor(averageRatio * (1 - 0.05 + Math.random() * 0.1));
        ratio = Math.max(minRatio, Math.min(maxRatio, ratio));
        ratios.push(ratio);
        totalRatio += ratio;
      }
      let adjustment = constants_1.RATIO_BASE - totalRatio;
      const increment = adjustment > 0 ? 1 : -1;
      while (adjustment !== 0) {
        for (let i = 0; i < orderCount && adjustment !== 0; i++) {
          const newRatio = ratios[i] + increment;
          if (newRatio >= minRatio && newRatio <= maxRatio) {
            ratios[i] = newRatio;
            adjustment -= increment;
          }
        }
      }
      break;
    }
    default:
      throw new synfError_1.SynfError("Invalid size distribution");
  }
  ratios[ratios.length - 1] =
    constants_1.RATIO_BASE -
    ratios.slice(0, ratios.length - 1).reduce((acc, ratio) => acc + ratio, 0);
  return ratios;
}
function requiredMarginForOrder(limit, sizeWad, ratio) {
  const marginValue = (0, math_1.wmul)(limit, sizeWad);
  const minAmount = (0, math_1.wmulUp)(marginValue, (0, math_1.r2w)(ratio));
  return minAmount;
}
function fillOrderToPosition(
  pearlNonce,
  pearlTaken,
  pearlFee,
  pearlSocialLoss,
  pearlFundingIndex,
  order,
  tick,
  nonce,
  fillSize,
  record
) {
  if (fillSize.eq(math_1.ZERO)) {
    fillSize = order.size;
  }
  const usize = fillSize.abs();
  let makerFee;
  let entrySocialLossIndex;
  let entryFundingIndex;
  if (nonce < pearlNonce) {
    const utaken0 = record.taken.abs();
    makerFee = record.taken.eq(fillSize)
      ? record.fee
      : (0, math_1.fracDown)(record.fee, usize, utaken0);
    entrySocialLossIndex = record.entrySocialLossIndex;
    entryFundingIndex = record.entryFundingIndex;
  } else {
    const utaken1 = pearlTaken.abs();
    makerFee = pearlTaken.eq(fillSize)
      ? pearlFee
      : (0, math_1.fracDown)(pearlFee, usize, utaken1);
    entrySocialLossIndex = pearlSocialLoss;
    entryFundingIndex = pearlFundingIndex;
  }
  const srtikePrice = math_1.TickMath.getWadAtTick(tick);
  return {
    balance: order.balance.add(makerFee),
    size: fillSize,
    entryNotional: (0, math_1.wmul)(srtikePrice, fillSize.abs()),
    entrySocialLossIndex: entrySocialLossIndex,
    entryFundingIndex: entryFundingIndex,
  };
}
function cancelOrderToPosition(
  pearlLeft,
  pearlNonce,
  pearlTaken,
  pearlFee,
  pearlSocialLoss,
  pearlFundingIndex,
  order,
  tick,
  nonce,
  record
) {
  let pic = {
    balance: order.balance,
    size: math_1.ZERO,
    entryNotional: math_1.ZERO,
    entrySocialLossIndex: math_1.ZERO,
    entryFundingIndex: math_1.ZERO,
  };
  const uleft = pearlLeft.abs();
  const usize = order.size.abs();
  if (uleft.lt(usize)) {
    const tLeft = pearlLeft;
    pic = fillOrderToPosition(
      pearlNonce,
      pearlTaken,
      pearlFee,
      pearlSocialLoss,
      pearlFundingIndex,
      order,
      tick,
      nonce,
      order.size.sub(tLeft),
      record
    );
  }
  return pic;
}
function tally(amm, position, mark) {
  let fundingFee = math_1.ZERO;
  const value = (0, math_1.wmul)(mark, position.size.abs());
  const socialLoss = (0, math_1.wmulUp)(
    (position.size.gt(math_1.ZERO)
      ? amm.longSocialLossIndex
      : amm.shortSocialLossIndex
    ).sub(position.entrySocialLossIndex),
    position.size.abs()
  );
  if (amm.expiry === constants_1.PERP_EXPIRY)
    fundingFee = calcFundingFee(amm, position);
  const pnl = (
    position.size.gt(math_1.ZERO)
      ? value.sub(position.entryNotional)
      : position.entryNotional.sub(value)
  )
    .add(fundingFee)
    .sub(socialLoss);
  const equity = pnl.add(position.balance);
  return { equity: equity, pnl: pnl, socialLoss: socialLoss };
}
function calcLiquidationPrice(amm, position, maintenanceMarginRatio = 500) {
  const socialLoss = (0, math_1.wmulUp)(
    (position.size.gt(math_1.ZERO)
      ? amm.longSocialLossIndex
      : amm.shortSocialLossIndex
    ).sub(position.entrySocialLossIndex),
    position.size.abs()
  );
  const fundingFee = calcFundingFee(amm, position);
  let price;
  if (position.size.gt(math_1.ZERO)) {
    const numerator = position.entryNotional
      .add(socialLoss)
      .sub(position.balance)
      .sub(fundingFee);
    if (numerator.lte(math_1.ZERO)) return math_1.ZERO;
    price = (0, math_1.wdivDown)(
      numerator,
      (0, math_1.wmulUp)(
        position.size.abs(),
        (0, math_1.r2w)(10000 - maintenanceMarginRatio)
      )
    );
  } else {
    const numerator = position.entryNotional
      .sub(socialLoss)
      .add(position.balance)
      .add(fundingFee);
    if (numerator.lte(math_1.ZERO)) return math_1.ZERO;
    price = (0, math_1.wdivUp)(
      numerator,
      (0, math_1.wmulDown)(
        position.size.abs(),
        (0, math_1.r2w)(10000 + maintenanceMarginRatio)
      )
    );
  }
  return price;
}
function calculatePriceFromPnl(amm, position, pnl) {
  const socialLoss = (0, math_1.wmulUp)(
    (position.size.gt(math_1.ZERO)
      ? amm.longSocialLossIndex
      : amm.shortSocialLossIndex
    ).sub(position.entrySocialLossIndex),
    position.size.abs()
  );
  const fundingFee = calcFundingFee(amm, position);
  const value = position.size.gt(math_1.ZERO)
    ? pnl.add(socialLoss).add(position.entryNotional).sub(fundingFee)
    : position.entryNotional.sub(socialLoss).sub(pnl).add(fundingFee);
  return position.size.gt(math_1.ZERO)
    ? (0, math_1.wdivUp)(value, position.size.abs())
    : (0, math_1.wdivDown)(value, position.size.abs());
}
function calcFundingFee(amm, position) {
  return (0, math_1.wmulInt)(
    (position.size.gte(math_1.ZERO)
      ? amm.longFundingIndex
      : amm.shortFundingIndex
    ).sub(position.entryFundingIndex),
    position.size.abs()
  );
}
function calcPnl(amm, position, mark) {
  return tally(amm, position, mark).pnl;
}
function realizeFundingWithPnl(amm, pos) {
  if (pos.size.eq(0)) return { position: pos, pnl: math_1.ZERO };
  const position = Object.assign({}, pos);
  const currentFundingIndex = position.size.gt(math_1.ZERO)
    ? amm.longFundingIndex
    : amm.shortFundingIndex;
  let pnl = math_1.ZERO;
  if (!currentFundingIndex.eq(position.entryFundingIndex)) {
    const funding = (0, math_1.wmulInt)(
      currentFundingIndex.sub(position.entryFundingIndex),
      position.size.abs()
    );
    pnl = funding;
    position.entryFundingIndex = currentFundingIndex;
    position.balance = position.balance.add(funding);
  }
  return { position, pnl };
}
function realizeFundingIncome(amm, pos) {
  return realizeFundingWithPnl(amm, pos).position;
}
function realizeSocialLoss(amm, pos) {
  pos = { ...pos };
  const long = pos.size.gt(math_1.ZERO);
  const usize = pos.size.abs();
  const socialLossIndex = long
    ? amm.longSocialLossIndex
    : amm.shortSocialLossIndex;
  const socialLoss = (0, math_1.wmulUp)(
    socialLossIndex.sub(pos.entrySocialLossIndex),
    usize
  );
  pos.balance = pos.balance.sub(socialLoss);
  pos.entrySocialLossIndex = socialLossIndex;
  return { position: pos, socialLoss };
}
function combine(amm, position_1, position_2) {
  let position1 = Object.assign({}, position_1);
  let position2 = Object.assign({}, position_2);
  let realized = math_1.ZERO;
  if (amm.expiry === constants_1.PERP_EXPIRY) {
    const { position: realizedPosition1, pnl: realizedPnl1 } =
      realizeFundingWithPnl(amm, position1);
    const { position: realizedPosition2, pnl: realizedPnl2 } =
      realizeFundingWithPnl(amm, position2);
    position1 = realizedPosition1;
    position2 = realizedPosition2;
    realized = realized.add(realizedPnl1);
    realized = realized.add(realizedPnl2);
  }
  const { position: realizedPosition1, socialLoss: socialLoss1 } =
    realizeSocialLoss(amm, position1);
  const { position: realizedPosition2, socialLoss: socialLoss2 } =
    realizeSocialLoss(amm, position2);
  position1 = realizedPosition1;
  position2 = realizedPosition2;
  realized = realized.sub(socialLoss1);
  realized = realized.sub(socialLoss2);
  let pic = {
    balance: math_1.ZERO,
    size: math_1.ZERO,
    entryNotional: math_1.ZERO,
    entrySocialLossIndex: math_1.ZERO,
    entryFundingIndex: math_1.ZERO,
  };
  let closedSize = math_1.ZERO;
  if (position1.size.eq(math_1.ZERO) || position2.size.eq(math_1.ZERO)) {
    pic = position1.size.eq(math_1.ZERO) ? position2 : position1;
    pic.balance = position1.balance.add(position2.balance);
    return { position: pic, closedSize: closedSize, realized: realized };
  }
  pic.size = position1.size.add(position2.size);
  if ((0, math_1.oppositeSigns)(position1.size, position2.size)) {
    closedSize = position1.size.abs().lt(position2.size.abs())
      ? position1.size.abs()
      : position2.size.abs();
    const longPic = position1.size.gt(math_1.ZERO) ? position1 : position2;
    const shortPic = position1.size.gt(math_1.ZERO) ? position2 : position1;
    let closedLongNotional = math_1.ZERO;
    let closedShortNotional = math_1.ZERO;
    if (pic.size.gt(math_1.ZERO)) {
      closedLongNotional = (0, math_1.frac)(
        longPic.entryNotional,
        closedSize,
        longPic.size.abs()
      );
      closedShortNotional = shortPic.entryNotional;
      pic.entryNotional = longPic.entryNotional.sub(closedLongNotional);
      pic.entrySocialLossIndex = longPic.entrySocialLossIndex;
      pic.entryFundingIndex = longPic.entryFundingIndex;
    } else if (pic.size.lt(math_1.ZERO)) {
      closedLongNotional = longPic.entryNotional;
      closedShortNotional = (0, math_1.frac)(
        shortPic.entryNotional,
        closedSize,
        shortPic.size.abs()
      );
      pic.entryNotional = shortPic.entryNotional.sub(closedShortNotional);
      pic.entrySocialLossIndex = shortPic.entrySocialLossIndex;
      pic.entryFundingIndex = shortPic.entryFundingIndex;
    } else {
      closedLongNotional = longPic.entryNotional;
      closedShortNotional = shortPic.entryNotional;
    }
    const realizedPnl = closedShortNotional.sub(closedLongNotional);
    pic.balance = pic.balance
      .add(longPic.balance)
      .add(shortPic.balance)
      .add(realizedPnl);
    realized = realized.add(realizedPnl);
  } else {
    pic.entryNotional = position1.entryNotional.add(position2.entryNotional);
    pic.entrySocialLossIndex = pic.size.gt(math_1.ZERO)
      ? amm.longSocialLossIndex
      : amm.shortSocialLossIndex;
    pic.entryFundingIndex = position1.size.gt(math_1.ZERO)
      ? amm.longFundingIndex
      : amm.shortFundingIndex;
    pic.balance = position1.balance.add(position2.balance);
  }
  return { position: pic, closedSize: closedSize, realized: realized };
}
function splitPosition(pos, partSize) {
  const uFullSize = pos.size.abs();
  const uPartSize = partSize.abs();
  const partPos = {};
  const finalPos = pos;
  partPos.size = partSize;
  finalPos.size = pos.size.sub(partSize);
  partPos.balance = (0, math_1.frac)(pos.balance, uPartSize, uFullSize);
  finalPos.balance = pos.balance.sub(partPos.balance);
  partPos.entryNotional = (0, math_1.frac)(
    pos.entryNotional,
    uPartSize,
    uFullSize
  );
  finalPos.entryNotional = pos.entryNotional.sub(partPos.entryNotional);
  partPos.entrySocialLossIndex = pos.entrySocialLossIndex;
  partPos.entryFundingIndex = pos.entryFundingIndex;
  return { partPos, finalPos };
}
function entryDelta(
  sqrtEntryPX96,
  tickLower,
  tickUpper,
  entryMargin,
  initialMarginRatio
) {
  const upperPX96 = math_1.TickMath.getSqrtRatioAtTick(tickUpper);
  const lowerPX96 = math_1.TickMath.getSqrtRatioAtTick(tickLower);
  const liquidityByUpper = getLiquidityFromMarginByUpper(
    sqrtEntryPX96,
    upperPX96,
    entryMargin,
    initialMarginRatio
  );
  const liquidityByLower = getLiquidityFromMarginByLower(
    sqrtEntryPX96,
    lowerPX96,
    entryMargin,
    initialMarginRatio
  );
  const liquidity = liquidityByUpper.lt(liquidityByLower)
    ? liquidityByUpper
    : liquidityByLower;
  const deltaBase = math_1.SqrtPriceMath.getDeltaBaseAutoRoundUp(
    sqrtEntryPX96,
    upperPX96,
    liquidity
  );
  const deltaQuote = math_1.SqrtPriceMath.getDeltaQuoteAutoRoundUp(
    lowerPX96,
    sqrtEntryPX96,
    liquidity
  );
  return { deltaBase: deltaBase, deltaQuote: deltaQuote, liquidity: liquidity };
}
function alignRangeTick(tick, lower) {
  if ((tick > 0 && lower) || (tick < 0 && !lower)) {
    return constants_1.RANGE_SPACING * ~~(tick / constants_1.RANGE_SPACING);
  } else {
    return (
      constants_1.RANGE_SPACING *
      ~~(
        (tick + (tick > 0 ? 1 : -1) * (constants_1.RANGE_SPACING - 1)) /
        constants_1.RANGE_SPACING
      )
    );
  }
}
function getLiquidityFromMarginByUpper(
  sqrtEntryPX96,
  sqrtUpperPX96,
  entryMargin,
  initialMarginRatio
) {
  const numerator = entryMargin
    .mul(sqrtEntryPX96)
    .div(sqrtUpperPX96.sub(sqrtEntryPX96));
  const denominator = sqrtUpperPX96
    .sub(sqrtEntryPX96)
    .add(
      (0, math_1.wmulUp)(sqrtUpperPX96, (0, math_1.r2w)(initialMarginRatio))
    );
  return numerator.mul(math_1.Q96).div(denominator);
}
function getLiquidityFromMarginByLower(
  sqrtEntryPX96,
  sqrtLowerPX96,
  entryMargin,
  initialMarginRatio
) {
  const numerator = entryMargin
    .mul(sqrtEntryPX96)
    .div(sqrtEntryPX96.sub(sqrtLowerPX96));
  const denominator = sqrtEntryPX96
    .sub(sqrtLowerPX96)
    .add(
      (0, math_1.wmulUp)(sqrtLowerPX96, (0, math_1.r2w)(initialMarginRatio))
    );
  return numerator.mul(math_1.Q96).div(denominator);
}
function getMarginFromLiquidity(
  sqrtEntryPX96,
  tickUpper,
  liquidity,
  initialMarginRatio
) {
  const sqrtUpperPX96 = math_1.TickMath.getSqrtRatioAtTick(tickUpper);
  const denominator = (0, math_1.wmulUp)(
    sqrtUpperPX96,
    (0, math_1.r2w)(10000 + initialMarginRatio)
  ).sub(sqrtEntryPX96);
  const temp = liquidity.mul(denominator).div(math_1.Q96);
  return temp.mul(sqrtUpperPX96.sub(sqrtEntryPX96)).div(sqrtEntryPX96);
}
