"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PerpLuanchpadDataSourceModule = void 0;
const ethers_1 = require("ethers");
const lodash_1 = require("lodash");
const context_1 = require("@derivation-tech/context");
const graph_1 = require("@derivation-tech/context/dist/utils/graph");
class PerpLuanchpadDataSourceModule extends graph_1.Graph {
  constructor(ctx, endpoint, retryOption) {
    super(endpoint, retryOption);
    this.ctx = ctx;
  }
  buildQueryEventCondition(param) {
    const fn = (str) => `"${str}"`;
    let accountCondition = "";
    let eventCondition = "";
    if (param.eventNames && param.eventNames.length > 0) {
      eventCondition = `name_in: [${param.eventNames
        .map((e) => fn(e))
        .join(",")}],`;
    }
    if (param.accounts && param.accounts.length > 0) {
      accountCondition = `account_in: [${param.accounts
        .map((t) => fn(t.toLowerCase()))
        .join(",")}],`;
    }
    const startTsCondition = `timestamp_gte: ${param.startTs || 0},`;
    const endTsCondition = `timestamp_lt: ${
      param.endTs || (0, context_1.now)()
    },`;
    const condition = `${eventCondition}${accountCondition}${startTsCondition}${endTsCondition}`;
    return `where: {${condition} id_gt: $lastID}, `;
  }
  async getAllVaultInfo() {
    const graphQL = `query{
            vaults{
                id
                name
                manager
                quote
                stage
                liveThreshold
                minQuoteAmount
            }
        }`;
    const vaults = (await this.query(graphQL, 0, graph_1.GRAPH_PAGE_SIZE))
      .vaults;
    const result = [];
    const quoteAddrs = new Set(vaults.map((v) => v.quote.toLowerCase()));
    const tokenInfos = await Promise.all(
      Array.from(quoteAddrs).map((addr) => this.ctx.getTokenInfo(addr))
    );
    const portfolioValues = await Promise.all(
      vaults.map((v) => this.ctx.perpLaunchpad.getPortfolioValue(v.id))
    );
    for (const vault of vaults) {
      result.push({
        vaultAddr: vault.id,
        vaultName: vault.name,
        managerAddr: vault.manager,
        quoteToken: tokenInfos.find(
          (t) => t.address.toLowerCase() === vault.quote.toLowerCase()
        ),
        stage: vault.stage,
        portfolioValue: portfolioValues.find(
          (_, idx) => vaults[idx].id === vault.id
        ),
        liveThreshold: ethers_1.BigNumber.from(vault.liveThreshold),
        minQuoteAmount: ethers_1.BigNumber.from(vault.minQuoteAmount),
      });
    }
    return result;
  }
  async getUserDepositInfo(account) {
    const graphQL = `query{
            _meta{
                block{
                  number
                  timestamp
                }
            }
            users(where: {address: "${account.toLowerCase()}"}) {
                address
                vault {
                    id
                    totalShare
                }
                share
                entryValue
            }
        }`;
    const result = await this.query(graphQL, 0, graph_1.GRAPH_PAGE_SIZE);
    const depositInfos = [];
    const vaultAddrs = Array.from(new Set(result.users.map((d) => d.vault.id)));
    const portfolioValues = await Promise.all(
      vaultAddrs.map((v) => this.ctx.perpLaunchpad.getPortfolioValue(v))
    );
    const depositWithdraws = await this.getUserDepositWithdrawHistory(account);
    for (const deposit of result.users) {
      const share = ethers_1.BigNumber.from(deposit.share);
      const totalShare = ethers_1.BigNumber.from(deposit.vault.totalShare);
      const entryValue = ethers_1.BigNumber.from(deposit.entryValue);
      const holdingValue = totalShare.eq(context_1.ZERO)
        ? context_1.ZERO
        : portfolioValues
            .find((_, idx) => vaultAddrs[idx] === deposit.vault.id)
            .mul(deposit.share)
            .div(totalShare);
      const allTimeEarned = depositWithdraws
        .filter((d) => d.vaultAddr === deposit.vault.id)
        .reduce(
          (acc, d) =>
            d.type === "WITHDRAW"
              ? acc.add(d.quoteAmount)
              : acc.sub(d.quoteAmount),
          context_1.ZERO
        )
        .add(holdingValue);
      depositInfos.push({
        user: deposit.address,
        vault: deposit.vault.id,
        share,
        entryValue,
        holdingValue,
        allTimeEarned,
      });
    }
    return {
      depositInfos: depositInfos,
      blockInfo: {
        height: Number(result._meta.block.number),
        timestamp: Number(result._meta.block.timestamp),
      },
    };
  }
  async getUserDepositWithdrawHistory(account) {
    const graphQL = `query($skip: Int, $first: Int, $lastID: String){
            depositWithdraws(first: $first, where:{
                user_: {address: "${account.toLowerCase()}"}
                id_gt: $lastID,
            }) {
                type
                txHash
                vault
                user{
                    address
                }
                timestamp
                isNative
                quantity
            }
        }`;
    const depositWithdraws = await this.queryAll(
      graphQL,
      graph_1.GRAPH_PAGE_SIZE,
      true
    );
    const result = [];
    for (const depositWithdraw of depositWithdraws) {
      result.push({
        type: depositWithdraw.type,
        txHash: depositWithdraw.txHash,
        vaultAddr: depositWithdraw.vault,
        userAddr: depositWithdraw.user.address,
        timestamp: Number(depositWithdraw.timestamp),
        isNative: depositWithdraw.isNative,
        quoteAmount: ethers_1.BigNumber.from(depositWithdraw.quantity),
      });
    }
    return result;
  }
  async getArrears(account) {
    const graphQL = `query($skip: Int, $first: Int, $lastID: String){
            arrears(skip: $skip, first: $first, where:{
                user_: {
                    address: "${account.toLowerCase()}"
                }
            }){
                user {
                    id
                }
                vault
                createdTimestamp
                releasedTimestamp
                phase
                share
            }
        }`;
    const arrears = await this.queryAll(graphQL, graph_1.GRAPH_PAGE_SIZE, true);
    const result = [];
    for (const arrear of arrears) {
      result.push({
        userAddr: arrear.user,
        vaultAddr: arrear.vault,
        createdTimestamp: Number(arrear.createdTimestamp),
        releasedTimestamp: Number(arrear.releasedTimestamp),
        share: ethers_1.BigNumber.from(arrear.share),
      });
    }
    return result;
  }
  async getArrear(account, vault) {
    const arrears = await this.getArrears(account);
    return arrears
      .filter((p) => p.vaultAddr === vault)
      .reduce(
        (prev, curr) =>
          prev.createdTimestamp > curr.createdTimestamp ? prev : curr,
        {
          userAddr: account,
          vaultAddr: vault,
          createdTimestamp: 0,
          releasedTimestamp: 0,
          share: context_1.ZERO,
        }
      );
  }
  async getHistoryEvents(param) {
    const queryAll = param.size === undefined && param.page === undefined;
    const first = param.size || 1000;
    const skip = (param.page || 0) * first;
    if (param.eventNames === undefined || param.eventNames.length === 0) {
      param.eventNames = ["Stake", "Unstake", "Release"];
    }
    let condition = this.buildQueryEventCondition(param);
    condition = queryAll
      ? condition
      : condition + "orderBy: timestamp, orderDirection: desc";
    const graphQL = `query($skip: Int, $first: Int, $lastID: String){
            transactionEvents(skip: $skip, first: $first, ${condition}){
                id
                name
                args
                account
                logIndex
                blockNumber
                timestamp
                transaction {
                    id
                }
            }
        }`;
    let transactionEvents;
    if (queryAll) {
      transactionEvents = await this.queryAll(
        graphQL,
        graph_1.GRAPH_PAGE_SIZE,
        true
      );
    } else {
      const resp = await this.query(graphQL, skip, first);
      transactionEvents = resp.transactionEvents;
    }
    let result = [];
    for (const txEvent of transactionEvents) {
      result.push({
        id: txEvent.id,
        txHash: txEvent.transaction.id,
        account: txEvent.account,
        blockNumber: Number(txEvent.blockNumber),
        timestamp: Number(txEvent.timestamp),
        logIndex: Number(txEvent.logIndex),
        name: txEvent.name,
        args: JSON.parse(txEvent.args),
      });
    }
    result = (0, lodash_1.orderBy)(
      result,
      ["blockNumber", "logIndex"],
      ["desc", "desc"]
    );
    return result;
  }
}
exports.PerpLuanchpadDataSourceModule = PerpLuanchpadDataSourceModule;
