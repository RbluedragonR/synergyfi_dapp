"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AirdropModule = void 0;
const typechain_1 = require("./typechain");
class AirdropModule {
  constructor(ctx) {
    this.ctx = ctx;
  }
  getAirdrop(contractAddress) {
    return typechain_1.Airdrop__factory.connect(
      contractAddress,
      this.ctx.provider
    );
  }
  getUniversalRewardsDistributor(contractAddress) {
    return typechain_1.UniversalRewardsDistributor__factory.connect(
      contractAddress,
      this.ctx.provider
    );
  }
  async claim(contractAddress, index, amount, account, proof, txOptions) {
    const airdrop = this.getAirdrop(contractAddress);
    const tx = await airdrop.populateTransaction.claim(
      index,
      account,
      amount,
      proof
    );
    return await this.ctx.tx.sendTx(tx, txOptions);
  }
  async isClaimed(contractAddress, index, overrides) {
    return await this.getAirdrop(contractAddress).isClaimed(
      index,
      overrides ?? {}
    );
  }
  async claimReward(rewardContractAddress, account, proofInputs, txOptions) {
    const rewardsDistributor = this.getUniversalRewardsDistributor(
      rewardContractAddress
    );
    const calls = [];
    for (const proof of proofInputs) {
      calls.push(
        rewardsDistributor.interface.encodeFunctionData("claim", [
          account,
          proof.tokenAddress,
          proof.amount,
          proof.proof,
        ])
      );
    }
    const ptx = await rewardsDistributor.populateTransaction.multicall(calls);
    return await this.ctx.tx.sendTx(ptx, txOptions);
  }
  async populateClaimReward(
    rewardContractAddress,
    account,
    proofInputs,
    fromAddr
  ) {
    const rewardsDistributor = this.getUniversalRewardsDistributor(
      rewardContractAddress
    );
    const calls = [];
    for (const proof of proofInputs) {
      calls.push(
        rewardsDistributor.interface.encodeFunctionData("claim", [
          account,
          proof.tokenAddress,
          proof.amount,
          proof.proof,
        ])
      );
    }
    const ptx = await rewardsDistributor.populateTransaction.multicall(calls, {
      from: fromAddr,
    });
    return ptx;
  }
  async getAlreadyClaimedRewardAmounts(rewardContractAddress, account, tokens) {
    const rewardsDistributor = this.getUniversalRewardsDistributor(
      rewardContractAddress
    );
    const calls = [];
    for (const token of tokens) {
      calls.push({
        target: rewardContractAddress,
        callData: rewardsDistributor.interface.encodeFunctionData("claimed", [
          account,
          token,
        ]),
      });
    }
    const rawData = await this.ctx.multiCall3.callStatic.aggregate(calls);
    const amounts = [];
    for (const data of rawData.returnData) {
      amounts.push(
        rewardsDistributor.interface.decodeFunctionResult("claimed", data)[0]
      );
    }
    return amounts;
  }
}
exports.AirdropModule = AirdropModule;
