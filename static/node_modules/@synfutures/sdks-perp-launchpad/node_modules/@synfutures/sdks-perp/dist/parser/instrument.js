"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InstrumentParser = void 0;
const context_1 = require("@derivation-tech/context");
const typechain_1 = require("../typechain");
const ethers_1 = require("ethers");
const utils_1 = require("../utils");
const utils_2 = require("ethers/lib/utils");
const enum_1 = require("../enum");
const farmat_1 = require("./farmat");
function isTransactionDescription(description) {
  return "functionFragment" in description;
}
function isLogDescription(description) {
  return "eventFragment" in description;
}
function isErrorDescription(description) {
  return "errorFragment" in description;
}
class InstrumentParser extends context_1.ContractParser {
  constructor(addressParser) {
    super(typechain_1.Instrument__factory.createInterface(), addressParser);
  }
  async formatEncodedFundctionArgs(obj) {
    let str = "{ ";
    for (const [k, v] of Object.entries(obj)) {
      if (ethers_1.ethers.utils.isAddress(v)) {
        str += `${k}: ${await this.parseAddress(v)}, `;
        continue;
      }
      if (k === "limitTicks") {
        str += `minTickLower: ${(0, farmat_1.formatTick)(
          Number(BigInt(v.toNumber()) >> BigInt(24))
        )}, maxTickUpper: ${(0, farmat_1.formatTick)(
          v.toNumber() & ((1 << 24) - 1)
        )}, `;
      } else if (k === "ticks") {
        str += `${k}: [${v
          .map((tick) => (0, farmat_1.formatTick)(tick))
          .join(", ")}], `;
      } else {
        str += `${k}: ${this.parseDefaultBaseParam(
          utils_2.ParamType.from({ type: "string", name: k }),
          v
        )}, `;
      }
    }
    str = str.substring(0, str.length - 2) + " }";
    return str;
  }
  async parseBaseArrayParam(description, param, value) {
    if (description.name === "add" && param.name === "args") {
      return this.formatEncodedFundctionArgs(
        (0, utils_1.decodeAddParam)(value)
      );
    } else if (description.name === "remove" && param.name === "args") {
      return this.formatEncodedFundctionArgs(
        (0, utils_1.decodeRemoveParam)(value)
      );
    } else if (description.name === "trade" && param.name === "args") {
      return this.formatEncodedFundctionArgs(
        (0, utils_1.decodeTradeWithStabilityFeeParam)(value)
      );
    } else if (description.name === "place" && param.name === "args") {
      return this.formatEncodedFundctionArgs(
        (0, utils_1.decodePlaceParam)(value)
      );
    } else if (description.name === "batchPlace" && param.name === "args") {
      return this.formatEncodedFundctionArgs(
        (0, utils_1.decodeBatchPlaceParam)(value)
      );
    }
    return await super.parseBaseArrayParam(description, param, value);
  }
  async parseBaseParam(description, param, data) {
    if (isTransactionDescription(description)) {
      return this.parseFunctionBaseParam(description, param, data);
    } else if (isLogDescription(description)) {
      return this.parseEventBaseParam(description, param, data);
    } else if (isErrorDescription(description)) {
      return this.parseErrorBaseParam(description, param, data);
    } else {
      return this.parseDefaultBaseParam(param, data);
    }
  }
  async parseFunctionBaseParam(_description, param, data) {
    switch (param.name) {
      case "arg": {
        switch (_description.functionFragment.name) {
          case "cancel":
            return this.formatEncodedFundctionArgs(
              (0, utils_1.decodeCancelParam)(data)
            );
          case "fill":
            return this.formatEncodedFundctionArgs(
              (0, utils_1.decodeFillParam)(data)
            );
          default:
            return data.toString();
        }
      }
      default:
        return this.parseDefaultBaseParam(param, data);
    }
  }
  parseEventBaseParam(_description, param, data) {
    switch (param.name) {
      default:
        return this.parseDefaultBaseParam(param, data);
    }
  }
  parseErrorBaseParam(_description, param, data) {
    switch (param.name) {
      default:
        return this.parseDefaultBaseParam(param, data);
    }
  }
  parseDefaultBaseParam(param, data) {
    switch (param.name) {
      case "status":
        return enum_1.Status[Number(data)];
      case "condition":
        return enum_1.InstrumentCondition[Number(data)];
      case "expiry":
        return (0, utils_1.formatExpiry)(data);
      case "timestamp":
      case "deadline":
        return (0, farmat_1.formatTimestamp)(data);
      case "feeRatio":
        return (0, farmat_1.formatRatio)(data);
      case "net":
      case "amount":
      case "minAmount":
      case "balance":
      case "tip":
      case "fee":
      case "entryNotional":
      case "deltaQuote":
      case "protocolFee":
      case "involvedFund":
      case "insuranceFund":
      case "funding":
      case "totalLong":
      case "totalShort":
      case "deltaBase":
      case "openInterests":
      case "totalTaken":
      case "taken":
      case "mark":
      case "limitPrice":
      case "settlement":
      case "requested":
        return (0, context_1.formatWad)(data);
      case "size":
      case "requestedSize":
      case "totalSize":
        return (0, context_1.formatWad)(data, 18);
      case "sqrtPX96":
      case "sqrtStrikeLowerPX96":
      case "sqrtStrikeUpperPX96":
      case "sqrtEntryPX96":
        return (0, farmat_1.formatSqrtPX96)(data, 18);
      case "tick":
      case "limitTick":
      case "tickUpper":
      case "tickLower":
      case "minTickLower":
      case "maxTickUpper":
        return (0, farmat_1.formatTick)(Number(data));
      default:
        return data.toString();
    }
  }
}
exports.InstrumentParser = InstrumentParser;
