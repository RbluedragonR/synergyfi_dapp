"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConfigModule = void 0;
const ethers_1 = require("ethers");
const context_1 = require("@derivation-tech/context");
class ConfigModule {
  constructor(context) {
    this.context = context;
  }
  async inWhiteListLps(quoteAddr, traders, overrides) {
    let calls = [];
    let results = [];
    let configInterface = this.context.perp.contracts.config.interface;
    if (
      (this.context.chainId === context_1.CHAIN_ID.BASE ||
        this.context.chainId === context_1.CHAIN_ID.MONADTESTNET ||
        this.context.chainId === context_1.CHAIN_ID.LOCAL) &&
      quoteAddr
    ) {
      for (const trader of traders) {
        calls.push({
          target: this.context.perp.contracts.config.address,
          callData: configInterface.encodeFunctionData("lpWhitelist", [
            quoteAddr,
            trader,
          ]),
        });
      }
      try {
        const rawData = await this.context.multiCall3.callStatic.aggregate(
          calls,
          overrides ?? {}
        );
        for (const data of rawData.returnData) {
          results.push(
            configInterface.decodeFunctionResult("lpWhitelist", data)[0]
          );
        }
        return results;
      } catch (e) {}
    }
    calls = [];
    results = [];
    configInterface = new ethers_1.ethers.utils.Interface([
      "function lpWhitelist(address user) external view returns (bool)",
    ]);
    for (const trader of traders) {
      calls.push({
        target: this.context.perp.contracts.config.address,
        callData: configInterface.encodeFunctionData("lpWhitelist", [trader]),
      });
    }
    const rawData = await this.context.multiCall3.callStatic.aggregate(
      calls,
      overrides ?? {}
    );
    for (const data of rawData.returnData) {
      results.push(
        configInterface.decodeFunctionResult("lpWhitelist", data)[0]
      );
    }
    return results;
  }
  async openLp(quoteAddr, overrides) {
    if (
      (this.context.chainId === context_1.CHAIN_ID.BASE ||
        this.context.chainId === context_1.CHAIN_ID.MONADTESTNET ||
        this.context.chainId === context_1.CHAIN_ID.LOCAL) &&
      quoteAddr
    ) {
      try {
        const restricted = await this.context.perp.contracts.config.restrictLp(
          quoteAddr,
          overrides ?? {}
        );
        return !restricted;
      } catch (e) {}
    }
    return this.context.perp.contracts.config.openLp(overrides ?? {});
  }
}
exports.ConfigModule = ConfigModule;
