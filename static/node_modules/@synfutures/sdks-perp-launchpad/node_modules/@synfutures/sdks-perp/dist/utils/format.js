"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.groupBy = groupBy;
exports.calcPositionLiquidationPrice = calcPositionLiquidationPrice;
exports.formatOrder = formatOrder;
exports.formatRange = formatRange;
exports.formatPosition = formatPosition;
exports.formatPositionWithoutPnL = formatPositionWithoutPnL;
exports.formatAmm = formatAmm;
exports.formatInstrument = formatInstrument;
exports.formatPortfolio = formatPortfolio;
exports.formatSimulateAddLiquidityResult = formatSimulateAddLiquidityResult;
exports.formatSimulateAddLiquidityWithAsymmetricRangeResult =
  formatSimulateAddLiquidityWithAsymmetricRangeResult;
exports.formatSimulateRemoveLiquidityResult =
  formatSimulateRemoveLiquidityResult;
exports.formatSimulateMarketOrderResult = formatSimulateMarketOrderResult;
exports.formatSimulateAdjustMarginByMarginResult =
  formatSimulateAdjustMarginByMarginResult;
exports.formatSimulateAdjustMarginByLeverageResult =
  formatSimulateAdjustMarginByLeverageResult;
exports.formatSimulateLimitOrderResult = formatSimulateLimitOrderResult;
exports.formatSimulateBatchPlaceResult = formatSimulateBatchPlaceResult;
exports.formatSimulateCrossMarketOrderResult =
  formatSimulateCrossMarketOrderResult;
const utils_1 = require("ethers/lib/utils");
const calculation_1 = require("./calculation");
const _1 = require(".");
const math_1 = require("../math");
const enum_1 = require("../enum");
function groupBy(arr, fn) {
  return arr.reduce((map, curr) => {
    const key = fn(curr);
    const group = map.get(key);
    if (group) {
      group.push(curr);
    } else {
      map.set(key, [curr]);
    }
    return map;
  }, new Map());
}
function calcPositionLiquidationPrice(amm, position, maintenanceMarginRatio) {
  if (position.size.isZero() || position.balance.isZero()) return math_1.ZERO;
  return (0, calculation_1.positionLiquidationPrice)(
    position,
    amm,
    maintenanceMarginRatio
  );
}
function _formatOrder(order, amm) {
  const formattedOrder = {
    side: enum_1.Side[order.side],
    size: (0, utils_1.formatEther)(order.size),
    Filled: (0, utils_1.formatEther)(order.taken),
    "Order Price": (0, utils_1.formatEther)(order.limitPrice),
    Margin: (0, utils_1.formatEther)(order.balance),
    Leverage: (0, utils_1.formatEther)(
      (0, calculation_1.orderLeverage)(order, amm)
    ),
  };
  return formattedOrder;
}
function formatOrder(order, amm) {
  return JSON.stringify(_formatOrder(order, amm), null, 2);
}
function _formatRange(range, amm, maintenanceMarginRatio) {
  const upperRawPosition = (0, calculation_1.rangeUpperPositionIfRemove)(
    range,
    amm
  );
  const upperPosition = _1.factory.createPosition({
    ...upperRawPosition,
    instrumentAddr: range.instrumentAddr,
    expiry: range.expiry,
    traderAddr: range.traderAddr,
  });
  const lowerRawPosition = (0, calculation_1.rangeLowerPositionIfRemove)(
    range,
    amm
  );
  const lowerPosition = _1.factory.createPosition({
    ...lowerRawPosition,
    instrumentAddr: range.instrumentAddr,
    expiry: range.expiry,
    traderAddr: range.traderAddr,
  });
  const lowerLiquidationPrice = (0, calculation_1.positionLiquidationPrice)(
    lowerPosition,
    amm,
    maintenanceMarginRatio
  );
  const upperLiquidationPrice = (0, calculation_1.positionLiquidationPrice)(
    upperPosition,
    amm,
    maintenanceMarginRatio
  );
  const formattedRange = {
    "Price Range": `${(0, utils_1.formatEther)(range.lowerPrice)} - ${(0,
    utils_1.formatEther)(range.upperPrice)}`,
    "Fair Price": (0, utils_1.formatEther)(amm.fairPrice),
    "Value Locked": (0, utils_1.formatEther)(
      (0, calculation_1.rangeValueLocked)(range, amm)
    ),
    "Fees Earned": (0, utils_1.formatEther)(
      (0, calculation_1.rangeFeeEarned)(range, amm)
    ),
    "Liquidation Price": `${(0, utils_1.formatEther)(
      lowerLiquidationPrice
    )} - ${(0, utils_1.formatEther)(upperLiquidationPrice)}`,
  };
  return formattedRange;
}
function formatRange(range, amm, maintenanceMarginRatio) {
  return JSON.stringify(
    _formatRange(range, amm, maintenanceMarginRatio),
    null,
    2
  );
}
function _formatPosition(position, amm, maintenanceMarginRatio) {
  const formattedPosition = {
    side: enum_1.Side[position.side],
    size: (0, utils_1.formatEther)(position.size),
    "Avg.Price": (0, utils_1.formatEther)(position.entryPrice),
    Margin: (0, utils_1.formatEther)(
      (0, calculation_1.positionEquity)(position, amm)
    ),
    Leverage: (0, utils_1.formatEther)(
      (0, calculation_1.positionLeverage)(position, amm)
    ),
    "Liq.Price": (0, utils_1.formatEther)(
      calcPositionLiquidationPrice(amm, position, maintenanceMarginRatio)
    ),
    "Mark Price": (0, utils_1.formatEther)(amm.markPrice),
    "Unrealized P&L": (0, utils_1.formatEther)(
      (0, calculation_1.positionUnrealizedPnl)(position, amm)
    ),
    "Unrealized Funding": (0, utils_1.formatEther)(
      (0, calculation_1.positionUnrealizedFundingFee)(position, amm)
    ),
  };
  return formattedPosition;
}
function formatPosition(position, amm, maintenanceMarginRatio) {
  return JSON.stringify(
    _formatPosition(position, amm, maintenanceMarginRatio),
    null,
    2
  );
}
function _formatPositionWithoutPnL(position, amm, maintenanceMarginRatio) {
  const formattedPosition = {
    side: enum_1.Side[position.side],
    size: (0, utils_1.formatEther)(position.size),
    "Avg.Price": (0, utils_1.formatEther)(position.entryPrice),
    Margin: (0, utils_1.formatEther)(
      (0, calculation_1.positionEquity)(position, amm)
    ),
    Leverage: (0, utils_1.formatEther)(
      (0, calculation_1.positionLeverage)(position, amm)
    ),
    "Liq.Price": (0, utils_1.formatEther)(
      calcPositionLiquidationPrice(amm, position, maintenanceMarginRatio)
    ),
    "Mark Price": (0, utils_1.formatEther)(amm.markPrice),
  };
  return formattedPosition;
}
function formatPositionWithoutPnL(position, amm, maintenanceMarginRatio) {
  return JSON.stringify(
    _formatPositionWithoutPnL(position, amm, maintenanceMarginRatio),
    null,
    2
  );
}
function _formatAmm(amm) {
  const formattedAmm = {
    expiry: amm.expiry,
    markPrice: (0, utils_1.formatEther)(amm.markPrice),
    fairPrice: (0, utils_1.formatEther)(amm.fairPrice),
  };
  return formattedAmm;
}
function formatAmm(amm) {
  return JSON.stringify(_formatAmm(amm), null, 2);
}
function _formatInstrument(instrument) {
  const formattedInstrument = {
    instrumentAddr: instrument.instrumentAddr,
    symbol: instrument.symbol,
    spotPrice: (0, utils_1.formatEther)(instrument.spotPrice),
    amms: Object.fromEntries(
      Array.from(instrument.amms).map(([expiry, amm]) => [
        expiry,
        _formatAmm(amm),
      ])
    ),
  };
  return formattedInstrument;
}
function formatInstrument(instrument) {
  return JSON.stringify(_formatInstrument(instrument), null, 2);
}
function formatPortfolio(portfolio, instrument) {
  const maintenanceMarginRatio = instrument.setting.maintenanceMarginRatio;
  const formattedPortfolio = {
    ...portfolio,
    position: portfolio.position.size.isZero()
      ? null
      : formatPosition(
          portfolio.position,
          instrument.amms.get(portfolio.position.expiry),
          instrument.setting.maintenanceMarginRatio
        ),
    orders: Object.fromEntries(
      Array.from(portfolio.orders).map(([oid, order]) => [
        oid,
        formatOrder(order, instrument.amms.get(order.expiry)),
      ])
    ),
    ranges: Object.fromEntries(
      Array.from(portfolio.ranges).map(([rid, range]) => [
        rid,
        formatRange(
          range,
          instrument.amms.get(range.expiry),
          maintenanceMarginRatio
        ),
      ])
    ),
  };
  return JSON.stringify(formattedPortfolio, null, 2);
}
function formatSimulateAddLiquidityResult(result, amm, maintenanceMarginRatio) {
  const formattedResult = {
    "Current Price": (0, utils_1.formatEther)(amm.fairPrice),
    "Capital Efficiency Boost": result.capitalEfficiencyBoost,
    "Removal Price":
      (0, utils_1.formatEther)(result.lowerPrice) +
      " ~ " +
      (0, utils_1.formatEther)(result.upperPrice),
    "Liquidation Price":
      (0, utils_1.formatEther)(
        calcPositionLiquidationPrice(
          amm,
          result.lowerPosition,
          maintenanceMarginRatio
        )
      ) +
      " ~ " +
      (0, utils_1.formatEther)(
        calcPositionLiquidationPrice(
          amm,
          result.upperPosition,
          maintenanceMarginRatio
        )
      ),
    minEffectiveQuoteAmount: (0, utils_1.formatEther)(
      result.minEffectiveQuoteAmount
    ),
    minMargin: (0, utils_1.formatEther)(result.minMargin),
  };
  return JSON.stringify(formattedResult, null, 2);
}
function formatSimulateAddLiquidityWithAsymmetricRangeResult(
  result,
  amm,
  maintenanceMarginRatio
) {
  const formattedResult = {
    "Current Price": (0, utils_1.formatEther)(amm.fairPrice),
    "Capital Efficiency Boost": result.capitalEfficiencyBoost,
    "Removal Price":
      (0, utils_1.formatEther)(result.lowerPrice) +
      " ~ " +
      (0, utils_1.formatEther)(result.upperPrice),
    "Liquidation Price":
      (0, utils_1.formatEther)(
        calcPositionLiquidationPrice(
          amm,
          result.lowerPosition,
          maintenanceMarginRatio
        )
      ) +
      " ~ " +
      (0, utils_1.formatEther)(
        calcPositionLiquidationPrice(
          amm,
          result.upperPosition,
          maintenanceMarginRatio
        )
      ),
    minEffectiveQuoteAmount: (0, utils_1.formatEther)(
      result.minEffectiveQuoteAmount
    ),
    minMargin: (0, utils_1.formatEther)(result.minMargin),
  };
  return JSON.stringify(formattedResult, null, 2);
}
function formatSimulateRemoveLiquidityResult(
  result,
  amm,
  maintenanceMarginRatio
) {
  const formattedResult = {
    "Removed position": _formatPositionWithoutPnL(
      result.removedPosition,
      amm,
      maintenanceMarginRatio
    ),
    "Post position": _formatPositionWithoutPnL(
      result.postPosition,
      amm,
      maintenanceMarginRatio
    ),
  };
  return JSON.stringify(formattedResult, null, 2);
}
function _formatSimulateMarketOrderResult(result, amm, maintenanceMarginRatio) {
  const formattedResult = {
    "Price Impact":
      Number((0, utils_1.formatEther)(result.priceImpact)) * 100 + "%",
    "Est. Trade Value": (0, utils_1.formatEther)(result.tradeValue),
    "Trading Fee": (0, utils_1.formatEther)(result.tradingFee),
    Margin: (0, utils_1.formatEther)(result.margin),
    Leverage: (0, utils_1.formatEther)(result.leverage),
    "Post position": _formatPositionWithoutPnL(
      result.postPosition,
      amm,
      maintenanceMarginRatio
    ),
  };
  return formattedResult;
}
function formatSimulateMarketOrderResult(result, amm, maintenanceMarginRatio) {
  return JSON.stringify(
    _formatSimulateMarketOrderResult(result, amm, maintenanceMarginRatio),
    null,
    2
  );
}
function formatSimulateAdjustMarginByMarginResult(
  result,
  amm,
  maintenanceMarginRatio
) {
  const formattedResult = {
    Leverage: (0, utils_1.formatEther)(result.leverage),
    "Post position": _formatPositionWithoutPnL(
      result.postPosition,
      amm,
      maintenanceMarginRatio
    ),
  };
  return JSON.stringify(formattedResult, null, 2);
}
function formatSimulateAdjustMarginByLeverageResult(
  result,
  amm,
  maintenanceMarginRatio
) {
  const formattedResult = {
    "Transfer In": result.transferIn,
    Margin: (0, utils_1.formatEther)(result.margin),
    "Post position": _formatPositionWithoutPnL(
      result.postPosition,
      amm,
      maintenanceMarginRatio
    ),
  };
  return JSON.stringify(formattedResult, null, 2);
}
function _formatSimulateLimitOrderResult(result) {
  const formattedResult = {
    Margin: (0, utils_1.formatEther)(result.margin),
    "Est. Trade Value": (0, utils_1.formatEther)(result.tradeValue),
    "Fee Rebate": (0, utils_1.formatEther)(result.minFeeRebate),
    limitPrice: (0, utils_1.formatEther)(result.limitPrice),
    leverage: (0, utils_1.formatEther)(result.leverage),
  };
  return formattedResult;
}
function formatSimulateLimitOrderResult(result) {
  return JSON.stringify(_formatSimulateLimitOrderResult(result), null, 2);
}
function formatSimulateBatchPlaceResult(result) {
  const orders = [];
  for (let i = 0; i < result.orders.length; i++) {
    if (result.orders[i]) {
      orders.push({
        "Order Price": (0, utils_1.formatEther)(result.orders[i].limitPrice),
        tick: result.orders[i].tick,
        margin: (0, utils_1.formatEther)(result.orders[i].margin),
        leverage: (0, utils_1.formatEther)(result.orders[i].leverage),
        minFeeRebate: (0, utils_1.formatEther)(result.orders[i].minFeeRebate),
      });
    }
  }
  const formattedResult = {
    orders: orders,
  };
  return JSON.stringify(formattedResult, null, 2);
}
function formatSimulateCrossMarketOrderResult(
  result,
  amm,
  maintenanceMarginRatio
) {
  const formattedResult = {
    "Can Place Order": result.canPlaceOrder,
    minOrderSize: (0, utils_1.formatEther)(result.minOrderSize),
    "Trade Simulation": _formatSimulateMarketOrderResult(
      result.tradeSimulation,
      amm,
      maintenanceMarginRatio
    ),
    "Order Simulation": _formatSimulateLimitOrderResult(result.orderSimulation),
  };
  return JSON.stringify(formattedResult, null, 2);
}
