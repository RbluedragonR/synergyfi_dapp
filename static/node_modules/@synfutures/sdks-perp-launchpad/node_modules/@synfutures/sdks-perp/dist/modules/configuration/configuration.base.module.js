"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConfigurationModuleBase = void 0;
const context_1 = require("@derivation-tech/context");
const typechain_1 = require("../../typechain");
const enum_1 = require("../../enum");
const utils_1 = require("../../utils");
const parser_1 = require("../../parser");
const errors_1 = require("../../errors");
class ConfigurationModuleBase {
  constructor(context) {
    this.instrumentIdentifiers = new Map();
    this.context = context;
  }
  registerContracts() {
    this.context.registerAddress(this.config.contractAddress.gate, "Gate");
    this.context.registerAddress(
      this.config.contractAddress.observer,
      "Observer"
    );
    this.context.registerAddress(this.config.contractAddress.config, "Config");
    this.context.registerContractParser(
      this.config.contractAddress.gate,
      new parser_1.GateParser(this.context)
    );
    this.context.registerContractParser(
      this.config.contractAddress.config,
      new parser_1.ConfigParser()
    );
    if (this.config.contractAddress.guardian) {
      this.context.registerAddress(
        this.config.contractAddress.guardian,
        "Guardian"
      );
      this.context.registerContractParser(
        this.config.contractAddress.guardian,
        new parser_1.GuardianParser()
      );
    }
    for (const marketType in this.config.contractAddress.market) {
      const marketAddress = this.config.contractAddress.market[marketType];
      this.context.registerAddress(
        marketAddress.market,
        `${marketType}-Market`
      );
      this.context.registerAddress(
        marketAddress.beacon,
        `${marketType}-InstrumentBeacon`
      );
      if ((0, utils_1.isCexMarket)(marketType)) {
        this.context.registerContractParser(
          marketAddress.market,
          new parser_1.CexMarketParser()
        );
      } else {
        this.context.registerContractParser(
          marketAddress.market,
          new parser_1.DexV2MarketParser()
        );
      }
    }
    for (const marketType in this.config.contractAddress.feederFactory) {
      const feederFactoryAddress =
        this.config.contractAddress.feederFactory[marketType];
      if (
        feederFactoryAddress.factory !== "" &&
        feederFactoryAddress.beacon !== ""
      ) {
        this.context.registerAddress(
          feederFactoryAddress.factory,
          `${marketType}-FeederFactory`
        );
        this.context.registerAddress(
          feederFactoryAddress.beacon,
          `${marketType}-FeederBeacon`
        );
        if (marketType === enum_1.MarketType.PYTH) {
          this.context.registerContractParser(
            feederFactoryAddress.factory,
            new context_1.ContractParser(
              typechain_1.PythFeederFactory__factory.createInterface()
            )
          );
        } else if (marketType === enum_1.MarketType.EMG) {
          this.context.registerContractParser(
            feederFactoryAddress.factory,
            new context_1.ContractParser(
              typechain_1.EmergingFeederFactory__factory.createInterface()
            )
          );
        }
      }
    }
    if (this.config.tokenInfo) {
      for (const token of this.config.tokenInfo) {
        this.context.perp.registerQuoteInfo(token);
      }
    }
  }
  createContracts(provider) {
    const marketContracts = {};
    for (const marketType in this.config.contractAddress.market) {
      const mType = marketType;
      const marketAddress = this.config.contractAddress.market[mType];
      marketContracts[mType] = {
        market: (0, utils_1.isCexMarket)(mType)
          ? typechain_1.CexMarket__factory.connect(
              marketAddress.market,
              provider
            )
          : typechain_1.DexV2Market__factory.connect(
              marketAddress.market,
              provider
            ),
        beacon: typechain_1.Beacon__factory.connect(
          marketAddress.beacon,
          provider
        ),
      };
    }
    const feederFactoryContracts = {};
    for (const marketType in this.config.contractAddress.feederFactory) {
      const mType = marketType;
      const feederFactoryAddress =
        this.config.contractAddress.feederFactory[mType];
      if (
        feederFactoryAddress.factory !== "" &&
        feederFactoryAddress.beacon !== ""
      ) {
        if (mType === enum_1.MarketType.PYTH) {
          feederFactoryContracts[mType] = {
            factory: typechain_1.PythFeederFactory__factory.connect(
              feederFactoryAddress.factory,
              provider
            ),
            beacon: typechain_1.Beacon__factory.connect(
              feederFactoryAddress.beacon,
              provider
            ),
          };
        } else if (mType === enum_1.MarketType.EMG) {
          feederFactoryContracts[mType] = {
            factory: typechain_1.EmergingFeederFactory__factory.connect(
              feederFactoryAddress.factory,
              provider
            ),
            beacon: typechain_1.Beacon__factory.connect(
              feederFactoryAddress.beacon,
              provider
            ),
          };
        } else {
          throw new errors_1.SynfError(`Invalid market type: ${mType}`);
        }
      }
    }
    return {
      gate: typechain_1.Gate__factory.connect(
        this.config.contractAddress.gate,
        provider
      ),
      observer: typechain_1.Observer__factory.connect(
        this.config.contractAddress.observer,
        provider
      ),
      config: typechain_1.Config__factory.connect(
        this.config.contractAddress.config,
        provider
      ),
      guardian: this.config.contractAddress.guardian
        ? typechain_1.Guardian__factory.connect(
            this.config.contractAddress.guardian,
            provider
          )
        : undefined,
      marketContracts: marketContracts,
      feederFactoryContracts: feederFactoryContracts,
    };
  }
  onSetProvider() {
    if (this.config) {
      this.registerContracts();
      this.context.perp.contracts = this.createContracts(this.context.provider);
    }
  }
  async update() {
    const config = await this.getConfig();
    if (config) {
      this.config = config;
      this.registerContracts();
      this.context.perp.contracts = this.createContracts(this.context.provider);
    }
  }
  async isInverse(instrument) {
    instrument = instrument.toLowerCase();
    let identifier = this.instrumentIdentifiers.get(instrument);
    if (!identifier) {
      const _instrument = await this.context.perp._observer.getInstrument(
        instrument
      );
      if (!_instrument) {
        throw new errors_1.SynfError("Unknown instrument: " + instrument);
      }
      this.instrumentIdentifiers.set(
        instrument,
        (identifier = {
          marketType: _instrument.marketType,
          baseSymbol: _instrument.base,
          quoteSymbol: _instrument.quote,
        })
      );
    }
    return this.isInverseByIdentifier(identifier);
  }
  async isInverseByIdentifier(identifier) {
    const baseSymbol =
      typeof identifier.baseSymbol === "string"
        ? identifier.baseSymbol
        : identifier.baseSymbol.symbol;
    const quoteSymbol =
      typeof identifier.quoteSymbol === "string"
        ? identifier.quoteSymbol
        : identifier.quoteSymbol.symbol;
    const symbol = baseSymbol + "-" + quoteSymbol + "-" + identifier.marketType;
    return !!this.config.inversePairs?.includes(symbol);
  }
}
exports.ConfigurationModuleBase = ConfigurationModuleBase;
