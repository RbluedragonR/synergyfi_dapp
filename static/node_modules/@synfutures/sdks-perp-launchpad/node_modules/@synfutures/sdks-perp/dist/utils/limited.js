"use strict";
var __importDefault =
  (this && this.__importDefault) ||
  function (mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
Object.defineProperty(exports, "__esModule", { value: true });
exports.Limited =
  exports.RequestStatus =
  exports.Token =
  exports.TokenStatus =
  exports.Counter =
    void 0;
exports.getRandomIntInclusive = getRandomIntInclusive;
exports.limitedMap = limitedMap;
const yallist_1 = __importDefault(require("yallist"));
class Counter {
  constructor() {
    this._count = 0;
  }
  get count() {
    return this._count;
  }
  create() {
    this.promise = new Promise((r) => (this.resolve = r));
  }
  destroy() {
    this.resolve();
    this.resolve = undefined;
    this.promise = undefined;
  }
  increase(i = 1) {
    this._count += i;
    if (this._count - i === 0) {
      this.create();
    }
  }
  decrease(i = 1) {
    if (i > this._count) {
      i = this._count;
    }
    this._count -= i;
    if (this._count === 0) {
      this.destroy();
    }
  }
  wait() {
    return this.promise ?? Promise.resolve();
  }
}
exports.Counter = Counter;
var TokenStatus;
(function (TokenStatus) {
  TokenStatus[(TokenStatus["Idle"] = 0)] = "Idle";
  TokenStatus[(TokenStatus["Using"] = 1)] = "Using";
})(TokenStatus || (exports.TokenStatus = TokenStatus = {}));
class Token {
  constructor(limited) {
    this.status = TokenStatus.Idle;
    this.limited = limited;
  }
}
exports.Token = Token;
var RequestStatus;
(function (RequestStatus) {
  RequestStatus[(RequestStatus["Queued"] = 0)] = "Queued";
  RequestStatus[(RequestStatus["Finished"] = 1)] = "Finished";
  RequestStatus[(RequestStatus["Canceled"] = 2)] = "Canceled";
})(RequestStatus || (exports.RequestStatus = RequestStatus = {}));
function toNode(value) {
  return {
    prev: null,
    next: null,
    value,
  };
}
class Limited {
  constructor(maxTokens, maxQueued = Infinity) {
    this.idle = yallist_1.default.create();
    this.queue = yallist_1.default.create();
    this.counter = new Counter();
    for (let i = 0; i < maxTokens; i++) {
      this.idle.push(new Token(this));
    }
    this.maxTokens = maxTokens;
    this.maxQueued = maxQueued;
  }
  get parallels() {
    return this.counter.count;
  }
  get tokens() {
    return this.maxTokens - this.parallels;
  }
  get queued() {
    return this.queue.length;
  }
  get available() {
    return this.maxQueued - this.queued;
  }
  get() {
    if (this.idle.length > 0) {
      const token = this.idle.shift();
      token.status = TokenStatus.Using;
      this.counter.increase();
      return { getToken: Promise.resolve(token) };
    } else if (this.queue.length + 1 <= this.maxQueued) {
      let resolve;
      let reject;
      const getToken = new Promise((_resolve, _reject) => {
        resolve = _resolve;
        reject = _reject;
      });
      const requestValue = {
        status: RequestStatus.Queued,
        resolve,
        reject,
      };
      const request = toNode(requestValue);
      this.queue.pushNode(request);
      return { getToken, request };
    } else {
      throw new Error("too many queued");
    }
  }
  getToken() {
    return this.get().getToken;
  }
  put(token) {
    if (token.limited !== this || token.status !== TokenStatus.Using) {
      throw new Error("invalid token");
    }
    if (this.queue.length > 0) {
      const request = this.queue.shift();
      request.status = RequestStatus.Finished;
      request.resolve(token);
    } else {
      token.status = TokenStatus.Idle;
      this.idle.push(token);
      this.counter.decrease();
    }
  }
  cancel(request, reason) {
    if (request.list !== this.queue) {
      throw new Error("invalid request");
    }
    if (request.value.status !== RequestStatus.Queued) {
      return;
    }
    this.queue.removeNode(request);
    request.value.status = RequestStatus.Canceled;
    request.value.reject(reason);
  }
  wait() {
    return this.counter.wait();
  }
}
exports.Limited = Limited;
function getRandomIntInclusive(min, max) {
  min = Math.ceil(min);
  max = Math.floor(max);
  if (max < min) {
    throw new Error(
      "The maximum value should be greater than the minimum value"
    );
  }
  return Math.floor(Math.random() * (max - min + 1)) + min;
}
function limitedMap(array, fn, limit) {
  return new Promise(async (resolve, reject) => {
    let failed = false;
    const limited = new Limited(limit);
    const promises = [];
    for (const element of array) {
      if (failed) {
        break;
      }
      const token = await limited.getToken();
      if (failed) {
        limited.put(token);
        break;
      }
      promises.push(
        fn(element)
          .catch((err) => {
            failed = true;
            reject(err);
          })
          .finally(() => limited.put(token))
      );
    }
    resolve(await Promise.all(promises));
  });
}
