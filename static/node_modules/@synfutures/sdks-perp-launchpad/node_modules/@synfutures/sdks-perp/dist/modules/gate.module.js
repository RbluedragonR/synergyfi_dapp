"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GateModule = void 0;
const constants_1 = require("../constants");
const utils_1 = require("../utils");
const math_1 = require("../math");
class GateModule {
  constructor(context) {
    this.context = context;
  }
  async deposit(quoteAddr, amount, txOptions) {
    const usingNative =
      quoteAddr.toLowerCase() ===
      constants_1.NATIVE_TOKEN_ADDRESS.toLowerCase();
    const unsignedTx =
      await this.context.perp.contracts.gate.populateTransaction.deposit(
        (0, utils_1.encodeDepositParam)(quoteAddr, amount),
        {
          ...(0, utils_1.toPopulatedTxOverrides)(txOptions),
          ...(usingNative ? { value: amount } : {}),
        }
      );
    return this.context.tx.sendTx(unsignedTx, txOptions);
  }
  async depositWad(quoteAddr, amount, txOptions) {
    const usingNative =
      quoteAddr.toLowerCase() ===
      constants_1.NATIVE_TOKEN_ADDRESS.toLowerCase();
    const quoteInfo = usingNative
      ? this.context.wrappedNativeToken
      : await this.context.getTokenInfo(quoteAddr);
    const decimals = quoteInfo.decimals;
    const amountCover = math_1.NumericConverter.toContractQuoteAmount(
      amount,
      decimals
    );
    return this.deposit(quoteAddr, amountCover, txOptions);
  }
  async withdraw(quoteAddr, amount, txOptions) {
    const unsignedTx =
      await this.context.perp.contracts.gate.populateTransaction.withdraw(
        (0, utils_1.encodeWithdrawParam)(quoteAddr, amount),
        (0, utils_1.toPopulatedTxOverrides)(txOptions)
      );
    return await this.context.tx.sendTx(unsignedTx, txOptions);
  }
  async withdrawWad(quoteAddr, amount, txOptions) {
    const usingNative =
      quoteAddr.toLowerCase() ===
      constants_1.NATIVE_TOKEN_ADDRESS.toLowerCase();
    const quoteInfo = usingNative
      ? this.context.wrappedNativeToken
      : await this.context.getTokenInfo(quoteAddr);
    const decimals = quoteInfo.decimals;
    const amountCover = math_1.NumericConverter.toContractQuoteAmount(
      amount,
      decimals
    );
    return await this.withdraw(quoteAddr, amountCover, txOptions);
  }
  async getPendingParams(quotes, txOptions) {
    const gateInterface = this.context.perp.contracts.gate.interface;
    const calls = quotes.map((quote) => {
      return {
        target: this.context.perp.contracts.gate.address,
        callData: gateInterface.encodeFunctionData("thresholdOf", [quote]),
      };
    });
    calls.push({
      target: this.context.perp.contracts.gate.address,
      callData: gateInterface.encodeFunctionData("pendingDuration"),
    });
    const rawRet = (
      await this.context
        .getMulticall3()
        .callStatic.aggregate(
          calls,
          (0, utils_1.toPopulatedTxOverrides)(txOptions)
        )
    ).returnData;
    const thresholds = rawRet
      .slice(0, quotes.length)
      .map((ret) => gateInterface.decodeFunctionResult("thresholdOf", ret)[0]);
    const pendingDuration = gateInterface.decodeFunctionResult(
      "pendingDuration",
      rawRet[quotes.length]
    )[0];
    return { pendingDuration, thresholds };
  }
  async claimPendingWithdraw(quote, trader, txOptions) {
    const unsignedTx =
      await this.context.perp.contracts.gate.populateTransaction.release(
        quote,
        trader,
        (0, utils_1.toPopulatedTxOverrides)(txOptions)
      );
    return this.context.tx.sendTx(unsignedTx, txOptions);
  }
}
exports.GateModule = GateModule;
