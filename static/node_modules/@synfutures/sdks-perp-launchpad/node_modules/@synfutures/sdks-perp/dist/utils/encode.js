"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkReferralCode = checkReferralCode;
exports.getHexReferral = getHexReferral;
exports.encodeTradeParam = encodeTradeParam;
exports.encodePlaceParam = encodePlaceParam;
exports.encodeDepositParam = encodeDepositParam;
exports.encodeWithdrawParam = encodeWithdrawParam;
exports.encodeAdjustParam = encodeAdjustParam;
exports.encodeAddParam = encodeAddParam;
exports.encodeRemoveParam = encodeRemoveParam;
exports.encodeBatchPlaceParam = encodeBatchPlaceParam;
exports.encodeFillParam = encodeFillParam;
exports.encodeCancelParam = encodeCancelParam;
exports.decodeTradeParam = decodeTradeParam;
exports.decodeTradeWithStabilityFeeParam = decodeTradeWithStabilityFeeParam;
exports.decodeDepositParam = decodeDepositParam;
exports.decodeWithdrawParam = decodeWithdrawParam;
exports.decodeParamForDepositAndWithdraw = decodeParamForDepositAndWithdraw;
exports.decodeAddParam = decodeAddParam;
exports.decodeRemoveParam = decodeRemoveParam;
exports.decodePlaceParam = decodePlaceParam;
exports.decodeBatchPlaceParam = decodeBatchPlaceParam;
exports.decodeFillParam = decodeFillParam;
exports.decodeCancelParam = decodeCancelParam;
const ethers_1 = require("ethers");
const utils_1 = require("ethers/lib/utils");
const constants_1 = require("../constants");
const math_1 = require("../math");
const paramsEncodeError_1 = require("../errors/paramsEncodeError");
const nonceLength = 24;
const tickLength = 24;
const limitTicksLength = tickLength * 2;
const expiryLength = 32;
const sizeLength = 128;
const amountLength = 128;
const quantityLength = 96;
const addressLength = 160;
const deadlineLength = 32;
const limitStabilityFeeRatioLength = 16;
const ratioLength = 16;
const leverageLength = 128;
function bytes32ToBigNumber(str) {
  str = str.startsWith("0x") ? str : "0x" + str;
  if (str.length !== 66) {
    throw new paramsEncodeError_1.ParamsEncodeError("invalid bytes32 string", {
      str,
    });
  }
  return ethers_1.BigNumber.from(str);
}
function pickNumber(value, from, to) {
  return pickBigNumber(value, from, to).toNumber();
}
function pickAddress(value, from, to) {
  return (0, utils_1.hexZeroPad)(
    pickBigNumber(value, from, to).toHexString(),
    20
  );
}
function pickBigNumber(value, from, to) {
  return value.shr(from).and(math_1.ONE.shl(to - from).sub(1));
}
function checkReferralCode(referral) {
  if (referral.length !== 8)
    throw new paramsEncodeError_1.ParamsEncodeError(
      "referral code length must be 8",
      { referral }
    );
}
function getHexReferral(referral) {
  checkReferralCode(referral);
  const platform = referral.charCodeAt(0);
  const wallet = referral.charCodeAt(1);
  const channel = referral.slice(2);
  return ethers_1.ethers.utils.hexConcat([
    ethers_1.BigNumber.from(platform).toHexString(),
    ethers_1.BigNumber.from(wallet).toHexString(),
    ethers_1.ethers.utils.hexlify(ethers_1.ethers.utils.toUtf8Bytes(channel)),
  ]);
}
function encodeParamForTradeAndPlace(param) {
  const usize = (0, math_1.asUint128)(param.size);
  const uAmount = (0, math_1.asUint128)(param.amount);
  const uTick = (0, math_1.asUint24)(param.limitTick);
  const combinedTick = ethers_1.BigNumber.from(uTick)
    .shl(32)
    .add(ethers_1.BigNumber.from(param.expiry));
  const combinedDeadline = ethers_1.BigNumber.from(param.deadline)
    .shl(56)
    .add(combinedTick);
  const combinedSize = ethers_1.BigNumber.from(usize).shl(128).add(uAmount);
  const page0Temp = (0, utils_1.hexZeroPad)(combinedDeadline.toHexString(), 32);
  const page1 = (0, utils_1.hexZeroPad)(combinedSize.toHexString(), 32);
  const page0 = param.referralCode
    ? (0, utils_1.hexZeroPad)(
        ethers_1.BigNumber.from(getHexReferral(param.referralCode))
          .shl(192)
          .add(ethers_1.BigNumber.from(page0Temp))
          .toHexString(),
        32
      )
    : page0Temp;
  return [page0, page1];
}
function encodeTradeParam(param) {
  return encodeParamForTradeAndPlace(param);
}
function encodePlaceParam(param) {
  return encodeParamForTradeAndPlace({
    ...param,
    limitTick: param.tick,
  });
}
function encodeDepositParam(token, quantity) {
  return encodeParamForDepositAndWithdraw(token, quantity);
}
function encodeWithdrawParam(token, quantity) {
  return encodeParamForDepositAndWithdraw(token, quantity);
}
function encodeParamForDepositAndWithdraw(token, quantity) {
  return (0, utils_1.hexZeroPad)(
    ethers_1.BigNumber.from(quantity).shl(160).add(token).toHexString(),
    32
  );
}
function encodeAdjustParam(param) {
  return encodeParamForTradeAndPlace({
    expiry: param.expiry,
    size: math_1.ZERO,
    amount: param.net,
    limitTick: 0,
    deadline: param.deadline,
    referralCode: param.referralCode,
  });
}
function encodeAddParam(addParam) {
  const uTick = (0, math_1.asUint48)(addParam.limitTicks.toNumber());
  const combinedTick = ethers_1.BigNumber.from(uTick)
    .shl(32)
    .add(ethers_1.BigNumber.from(addParam.expiry));
  const combinedDeadline = ethers_1.BigNumber.from(addParam.deadline)
    .shl(80)
    .add(combinedTick);
  const combinedAmount = ethers_1.BigNumber.from(addParam.tickDeltaLower)
    .shl(152)
    .add(ethers_1.BigNumber.from(addParam.tickDeltaUpper).shl(128))
    .add(addParam.amount);
  const page0 = addParam.referralCode
    ? (0, utils_1.hexZeroPad)(
        ethers_1.BigNumber.from(getHexReferral(addParam.referralCode))
          .shl(192)
          .add(combinedDeadline)
          .toHexString(),
        32
      )
    : (0, utils_1.hexZeroPad)(combinedDeadline.toHexString(), 32);
  const page1 = (0, utils_1.hexZeroPad)(combinedAmount.toHexString(), 32);
  return [page0, page1];
}
function encodeRemoveParam(removeParam) {
  const uTick = (0, math_1.asUint48)(removeParam.limitTicks.toNumber());
  const combinedTick = ethers_1.BigNumber.from(uTick)
    .shl(32)
    .add(ethers_1.BigNumber.from(removeParam.expiry));
  const combinedDeadline = ethers_1.BigNumber.from(removeParam.deadline)
    .shl(80)
    .add(combinedTick);
  const uTickLower = (0, math_1.asUint24)(removeParam.tickLower);
  const uTickUpper = (0, math_1.asUint24)(removeParam.tickUpper);
  const combinedTickLower = ethers_1.BigNumber.from(uTickLower)
    .shl(160)
    .add(removeParam.traderAddr);
  const combinedTickUpper = ethers_1.BigNumber.from(uTickUpper)
    .shl(184)
    .add(combinedTickLower);
  const page0 = (0, utils_1.hexZeroPad)(combinedDeadline.toHexString(), 32);
  const page1 = (0, utils_1.hexZeroPad)(combinedTickUpper.toHexString(), 32);
  return [page0, page1];
}
function encodeBatchPlaceParam(
  expiry,
  size,
  leverage,
  ticks,
  ratios,
  deadline,
  referral
) {
  if (ticks.length > 9)
    throw new paramsEncodeError_1.ParamsEncodeError(
      "cannot place more than 9 orders at once",
      { ticks }
    );
  if (ticks.length !== ratios.length)
    throw new paramsEncodeError_1.ParamsEncodeError(
      "ticks and ratios length mismatch",
      { ticks, ratios }
    );
  if (ratios.reduce((a, b) => a + b, 0) !== constants_1.RATIO_BASE)
    throw new paramsEncodeError_1.ParamsEncodeError(
      "ratios sum must be 10000",
      ratios
    );
  const usize = (0, math_1.asUint128)(size);
  const uLeverage = (0, math_1.asUint128)(leverage);
  const combinedSize = ethers_1.BigNumber.from(usize).shl(128).add(uLeverage);
  const page2 = (0, utils_1.hexZeroPad)(combinedSize.toHexString(), 32);
  let tmp0 = ethers_1.BigNumber.from(deadline)
    .shl(32)
    .add(ethers_1.BigNumber.from(expiry));
  for (let i = 0; i < 3; i++) {
    const uTick =
      i < ticks.length ? (0, math_1.asUint24)(ticks[i]) : math_1.EMPTY_TICK;
    const uRatio = i < ratios.length ? (0, math_1.asUint16)(ratios[i]) : 0;
    tmp0 = tmp0
      .add(ethers_1.BigNumber.from(uRatio).shl(64 + 40 * i))
      .add(ethers_1.BigNumber.from(uTick).shl(64 + 40 * i + 16));
  }
  const page0Temp = (0, utils_1.hexZeroPad)(tmp0.toHexString(), 32);
  let tmp1 = math_1.ZERO;
  for (let i = 0; i < 6; i++) {
    const uTick =
      i + 3 < ticks.length
        ? (0, math_1.asUint24)(ticks[i + 3])
        : math_1.EMPTY_TICK;
    const uRatio =
      i + 3 < ratios.length ? (0, math_1.asUint16)(ratios[i + 3]) : 0;
    tmp1 = tmp1
      .add(ethers_1.BigNumber.from(uRatio).shl(40 * i))
      .add(ethers_1.BigNumber.from(uTick).shl(40 * i + 16));
  }
  const page1 = (0, utils_1.hexZeroPad)(tmp1.toHexString(), 32);
  const page0 = referral
    ? (0, utils_1.hexZeroPad)(
        ethers_1.BigNumber.from(getHexReferral(referral))
          .shl(192)
          .add(ethers_1.BigNumber.from(page0Temp))
          .toHexString(),
        32
      )
    : page0Temp;
  return [page0, page1, page2];
}
function encodeFillParam(param) {
  const uTick = (0, math_1.asUint24)(param.tick);
  const combinedTarget = ethers_1.BigNumber.from(param.target)
    .shl(32)
    .add(ethers_1.BigNumber.from(param.expiry));
  const combinedTick = ethers_1.BigNumber.from(uTick)
    .shl(192)
    .add(combinedTarget);
  return (0, utils_1.hexZeroPad)(
    ethers_1.BigNumber.from(param.nonce)
      .shl(216)
      .add(combinedTick)
      .toHexString(),
    32
  );
}
function encodeCancelParam(param) {
  const { ticks, expiry, deadline } = param;
  if (ticks.length < 1 || ticks.length > constants_1.MAX_CANCEL_ORDER_COUNT)
    throw new paramsEncodeError_1.ParamsEncodeError(
      `ticks length must be between 1 and ${constants_1.MAX_CANCEL_ORDER_COUNT}`,
      { ticks }
    );
  let encodedTicks = math_1.ZERO;
  for (let i = 0; i < constants_1.MAX_CANCEL_ORDER_COUNT; i++) {
    const tick = i < ticks.length ? ticks[i] : constants_1.INT24_MAX;
    encodedTicks = encodedTicks.add(
      ethers_1.BigNumber.from((0, math_1.asUint24)(tick)).shl(24 * i)
    );
  }
  const combinedTick = ethers_1.BigNumber.from(encodedTicks)
    .shl(32)
    .add(ethers_1.BigNumber.from(expiry));
  const combinedDeadline = ethers_1.BigNumber.from(deadline)
    .shl(224)
    .add(combinedTick);
  return (0, utils_1.hexZeroPad)(combinedDeadline.toHexString(), 32);
}
function decodeTradeParam(args) {
  return decodeParamForTradeAndPlace(args);
}
function decodeTradeWithStabilityFeeParam(args) {
  const tradeParam = decodeTradeParam(args);
  const value1 = bytes32ToBigNumber(args[0]);
  const offset = expiryLength + tickLength + deadlineLength;
  const limitStabilityFeeRatio = pickNumber(
    value1,
    offset,
    offset + limitStabilityFeeRatioLength
  );
  return { ...tradeParam, limitStabilityFeeRatio };
}
function decodeParamForTradeAndPlace(args) {
  if (args.length !== 2) {
    throw new paramsEncodeError_1.ParamsEncodeError(
      "invalid args length for trade and place",
      { args }
    );
  }
  const [arg1, arg2] = args;
  let offset = 0;
  const value1 = bytes32ToBigNumber(arg1);
  const expiry = pickNumber(value1, offset, (offset += expiryLength));
  const limitTick = (0, math_1.asInt24)(
    pickNumber(value1, offset, (offset += tickLength))
  );
  const deadline = pickNumber(value1, offset, (offset += deadlineLength));
  offset = 0;
  const value2 = bytes32ToBigNumber(arg2);
  const amount = (0, math_1.asInt128)(
    pickBigNumber(value2, offset, (offset += amountLength))
  );
  const size = (0, math_1.asInt128)(
    pickBigNumber(value2, offset, (offset += sizeLength))
  );
  return { expiry, size, amount, limitTick, deadline, referralCode: "" };
}
function decodeDepositParam(arg) {
  return decodeParamForDepositAndWithdraw(arg);
}
function decodeWithdrawParam(arg) {
  return decodeParamForDepositAndWithdraw(arg);
}
function decodeParamForDepositAndWithdraw(arg) {
  let offset = 0;
  const value = bytes32ToBigNumber(arg);
  const token = pickAddress(value, offset, (offset += addressLength));
  const quantity = pickBigNumber(value, offset, (offset += quantityLength));
  return { quantity, token };
}
function decodeAddParam(args) {
  if (args.length !== 2) {
    throw new paramsEncodeError_1.ParamsEncodeError(
      "invalid args length for add",
      { args }
    );
  }
  const [arg1, arg2] = args;
  let offset = 0;
  const value1 = bytes32ToBigNumber(arg1);
  const expiry = pickNumber(value1, offset, (offset += expiryLength));
  const limitTicks = pickBigNumber(
    value1,
    offset,
    (offset += limitTicksLength)
  );
  const deadline = pickNumber(value1, offset, (offset += deadlineLength));
  offset = 0;
  const value2 = bytes32ToBigNumber(arg2);
  const amount = pickBigNumber(value2, offset, (offset += amountLength));
  const tickDeltaUpper = pickNumber(value2, offset, (offset += tickLength));
  const tickDeltaLower = pickNumber(value2, offset, (offset += tickLength));
  return {
    limitTicks,
    amount,
    tickDeltaLower,
    tickDeltaUpper,
    expiry,
    deadline,
    referralCode: "",
  };
}
function decodeRemoveParam(args) {
  if (args.length !== 2) {
    throw new paramsEncodeError_1.ParamsEncodeError(
      "invalid args length for remove",
      { args }
    );
  }
  const [arg1, arg2] = args;
  let offset = 0;
  const value1 = bytes32ToBigNumber(arg1);
  const expiry = pickNumber(value1, offset, (offset += expiryLength));
  const limitTicks = pickBigNumber(
    value1,
    offset,
    (offset += limitTicksLength)
  );
  const deadline = pickNumber(value1, offset, (offset += deadlineLength));
  offset = 0;
  const value2 = bytes32ToBigNumber(arg2);
  const target = pickAddress(value2, offset, (offset += addressLength));
  const tickLower = (0, math_1.asInt24)(
    pickNumber(value2, offset, (offset += tickLength))
  );
  const tickUpper = (0, math_1.asInt24)(
    pickNumber(value2, offset, (offset += tickLength))
  );
  return {
    tickUpper,
    tickLower,
    traderAddr: target,
    expiry,
    limitTicks,
    deadline,
  };
}
function decodePlaceParam(args) {
  const result = decodeParamForTradeAndPlace(args);
  return {
    expiry: result.expiry,
    size: result.size,
    amount: result.amount,
    tick: result.limitTick,
    deadline: result.deadline,
  };
}
function decodeBatchPlaceParam(args) {
  if (args.length !== 3) {
    throw new paramsEncodeError_1.ParamsEncodeError(
      "invalid args length for place",
      { args }
    );
  }
  const [arg1, arg2, arg3] = args;
  const ticks = [];
  const ratios = [];
  let offset = 0;
  const value1 = bytes32ToBigNumber(arg1);
  const expiry = pickNumber(value1, offset, (offset += expiryLength));
  const deadline = pickNumber(value1, offset, (offset += deadlineLength));
  for (let i = 0; i < 3; i++) {
    const ratio = pickNumber(value1, offset, (offset += ratioLength));
    const tick = (0, math_1.asInt24)(
      pickNumber(value1, offset, (offset += tickLength))
    );
    if (ethers_1.BigNumber.from(tick).eq(math_1.EMPTY_TICK)) continue;
    ticks.push(tick);
    ratios.push(ratio);
  }
  offset = 0;
  const value2 = bytes32ToBigNumber(arg2);
  for (let i = 0; i < 6; i++) {
    const ratio = pickNumber(value2, offset, (offset += ratioLength));
    const tick = (0, math_1.asInt24)(
      pickNumber(value2, offset, (offset += tickLength))
    );
    if (ethers_1.BigNumber.from(tick).eq(math_1.EMPTY_TICK)) continue;
    ticks.push(tick);
    ratios.push(ratio);
  }
  offset = 0;
  const value3 = bytes32ToBigNumber(arg3);
  const leverage = (0, math_1.asInt128)(
    pickBigNumber(value3, offset, (offset += leverageLength))
  );
  const size = (0, math_1.asInt128)(
    pickBigNumber(value3, offset, (offset += sizeLength))
  );
  return { expiry, ticks, ratios, size, leverage, deadline };
}
function decodeFillParam(arg) {
  let offset = 0;
  const value = bytes32ToBigNumber(arg);
  const expiry = pickNumber(value, offset, (offset += expiryLength));
  const target = pickAddress(value, offset, (offset += addressLength));
  const tick = (0, math_1.asInt24)(
    pickNumber(value, offset, (offset += tickLength))
  );
  const nonce = pickNumber(value, offset, (offset += nonceLength));
  return { nonce, tick, target, expiry };
}
function decodeCancelParam(arg) {
  let offset = 0;
  const value = bytes32ToBigNumber(arg);
  const expiry = pickNumber(value, offset, (offset += expiryLength));
  const ticks = [];
  for (let i = 0; i < constants_1.MAX_CANCEL_ORDER_COUNT; i++) {
    const tick = (0, math_1.asInt24)(
      pickNumber(value, offset, (offset += tickLength))
    );
    if (tick === math_1.MAX_INT_24.toNumber()) {
      continue;
    }
    ticks.push(tick);
  }
  const deadline = pickNumber(value, offset, (offset += deadlineLength));
  return { ticks, expiry, deadline };
}
