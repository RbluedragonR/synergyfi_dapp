"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SimulateModule = void 0;
const ethers_1 = require("ethers");
const math_1 = require("../math");
const utils_1 = require("../utils");
const lowLevel_1 = require("../utils/lowLevel");
const constants_1 = require("../constants");
const enum_1 = require("../enum");
const synfError_1 = require("../errors/synfError");
const simulationError_1 = require("../errors/simulationError");
class SimulateModule {
  constructor(context) {
    this.context = context;
  }
  get observer() {
    return this.context.perp._observer;
  }
  async getPosition(tradeInfo, overrides) {
    if ((0, utils_1.isPosition)(tradeInfo)) {
      return tradeInfo;
    }
    const portfolio = await this.observer.getPortfolio(
      tradeInfo,
      overrides ?? {}
    );
    return portfolio.position;
  }
  async getPortfolio(traderInfo, overrides) {
    if ((0, utils_1.isPortfolio)(traderInfo)) {
      return traderInfo;
    } else {
      return await this.observer.getPortfolio(traderInfo, overrides ?? {});
    }
  }
  getPriceInfo(priceInfo) {
    let targetTick;
    let targetPrice;
    if (typeof priceInfo === "number") {
      targetTick = priceInfo;
      targetPrice = math_1.TickMath.getWadAtTick(targetTick);
    } else {
      const result = (0, math_1.alignPriceToTick)(priceInfo);
      targetTick = result.tick;
      targetPrice = result.price;
    }
    return { targetTick, targetPrice };
  }
  async mustGetInstrumentAndAmm(anyInfo, instrument, overrides) {
    const result = await this.getInstrumentAndAmm(
      anyInfo,
      instrument,
      overrides ?? {}
    );
    if (result === undefined || result.amm === undefined) {
      throw new synfError_1.SynfError(
        "Instrument or amm not found: " +
          `instrument: ${anyInfo.instrumentAddr}, expiry: ${anyInfo.expiry}`
      );
    }
    return result;
  }
  async getInstrumentAndAmm(anyInfo, instrument, overrides) {
    if (instrument) {
      return { instrument, amm: instrument.amms.get(anyInfo.expiry) };
    }
    instrument = await this.observer.getInstrument(
      {
        instrument: anyInfo.instrumentAddr,
        expiries: [anyInfo.expiry],
      },
      overrides ?? {}
    );
    if (instrument === undefined) {
      return undefined;
    }
    return { instrument, amm: instrument.amms.get(anyInfo.expiry) };
  }
  async inquireByBaseOrQuote(
    params,
    markPrice,
    overrides,
    expectQuotation = false
  ) {
    let baseSize;
    let quoteSize;
    let quotation = null;
    if ((0, utils_1.isByBase)(params.size)) {
      const { quoteAmount, quotation: _quotation } = await this.observer
        .inquireByBase(
          params.tradeInfo.instrumentAddr,
          params.tradeInfo.expiry,
          params.side,
          params.size.base,
          overrides ?? {}
        )
        .catch((err) => {
          if (expectQuotation) {
            throw err;
          }
          return {
            quoteAmount: (0, math_1.wmul)(params.size.base, markPrice),
            quotation: null,
          };
        });
      baseSize = params.size.base;
      quoteSize = quoteAmount;
      quotation = _quotation;
    } else {
      const { baseAmount, quotation: _quotation } = await this.observer
        .inquireByQuote(
          params.tradeInfo.instrumentAddr,
          params.tradeInfo.expiry,
          params.side,
          params.size.quote,
          overrides ?? {}
        )
        .catch((err) => {
          if (expectQuotation) {
            throw err;
          }
          return {
            baseAmount: (0, math_1.wdiv)(params.size.quote, markPrice),
            quotation: null,
          };
        });
      baseSize = baseAmount;
      quoteSize = params.size.quote;
      quotation = _quotation;
    }
    return { baseSize, quoteSize, quotation };
  }
  async simulateCrossMarketOrder(params, overrides) {
    const { instrument, amm } = await this.mustGetInstrumentAndAmm(
      params.tradeInfo,
      params.instrument,
      overrides ?? {}
    );
    const { baseSize, quoteSize } = await this.inquireByBaseOrQuote(
      params,
      amm.markPrice,
      overrides ?? {}
    );
    const sign = (0, utils_1.signOfSide)(params.side);
    const long = sign > 0;
    const { targetTick, targetPrice } = this.getPriceInfo(params.priceInfo);
    const currentTick = amm.tick;
    if (
      (long && targetTick <= currentTick) ||
      (!long && targetTick >= currentTick)
    ) {
      throw new simulationError_1.SimulationError("Please place normal order");
    }
    let swapToTick = long ? targetTick + 1 : targetTick - 1;
    let { size: swapSize, quotation } =
      await this.context.perp.contracts.observer.inquireByTick(
        instrument.instrumentAddr,
        amm.expiry,
        swapToTick,
        overrides ?? {}
      );
    if (
      (long && quotation.postTick <= targetTick) ||
      (!long && quotation.postTick >= targetTick)
    ) {
      swapToTick = long ? swapToTick + 1 : swapToTick - 1;
      const retry = await this.context.perp.contracts.observer.inquireByTick(
        instrument.instrumentAddr,
        amm.expiry,
        swapToTick,
        overrides ?? {}
      );
      swapSize = retry.size;
      quotation = retry.quotation;
    }
    if ((long && swapSize.lt(0)) || (!long && swapSize.gt(0))) {
      throw new simulationError_1.SimulationError("Wrong Side");
    }
    const tradeSimulation = await this._simulateMarketOrderByLeverage(
      {
        tradeInfo: params.tradeInfo,
        side: params.side,
        size: { base: swapSize.abs() },
        slippage: params.slippage,
        strictMode: params.strictMode,
        instrument: instrument,
        leverage: params.leverage,
      },
      overrides ?? {}
    );
    const position = await this.getPosition(params.tradeInfo, overrides ?? {});
    if (
      position.size.isZero() &&
      quotation.entryNotional.lt(instrument.minTradeValue)
    ) {
      throw new simulationError_1.SimulationError("Size to tick is trivial");
    }
    const orderBaseSize = baseSize.sub(swapSize.abs());
    const orderQuoteSize = quoteSize.sub(tradeSimulation.size.quote);
    const orderSimulation = {
      ...this._simulateOrder(
        instrument,
        amm,
        targetPrice,
        orderBaseSize,
        params.leverage
      ),
      tick: targetTick,
      size: { base: orderBaseSize, quote: orderQuoteSize },
    };
    const minOrderValue = instrument.minOrderValue;
    const targetTickPrice = math_1.TickMath.getWadAtTick(targetTick);
    const minOrderSize = (0, math_1.wdivUp)(minOrderValue, targetTickPrice);
    if (swapSize.abs().add(minOrderSize).gt(baseSize)) {
      return {
        canPlaceOrder: false,
        minOrderSize,
        tradeSimulation,
        orderSimulation,
      };
    } else {
      return {
        canPlaceOrder: true,
        minOrderSize,
        tradeSimulation,
        orderSimulation,
      };
    }
  }
  async simulateLimitOrder(params, overrides) {
    const { instrument, amm } = await this.mustGetInstrumentAndAmm(
      params.tradeInfo,
      params.instrument,
      overrides ?? {}
    );
    const { targetTick, targetPrice } = this.getPriceInfo(params.priceInfo);
    const currentTick = amm.tick;
    if (currentTick === targetTick) {
      throw new simulationError_1.SimulationError("Invalid price");
    }
    const isLong = targetTick < currentTick;
    if (
      (params.side === enum_1.Side.LONG && !isLong) ||
      (params.side === enum_1.Side.SHORT && isLong)
    ) {
      throw new simulationError_1.SimulationError("Invalid price");
    }
    const maxLeverage = (0, math_1.getMaxLeverage)(
      instrument.setting.initialMarginRatio
    );
    if (
      params.leverage.gt(ethers_1.ethers.utils.parseEther(maxLeverage + ""))
    ) {
      throw new simulationError_1.SimulationError(
        "Insufficient margin to open position"
      );
    }
    if (
      !(0, lowLevel_1.withinOrderLimit)(
        targetPrice,
        amm.markPrice,
        instrument.setting.initialMarginRatio
      )
    ) {
      throw new simulationError_1.SimulationError(
        "Limit order price is too far away from mark price"
      );
    }
    if (
      !(0, lowLevel_1.withinDeviationLimit)(
        amm.fairPrice,
        amm.markPrice,
        instrument.setting.initialMarginRatio
      )
    ) {
      throw new simulationError_1.SimulationError(
        "Fair price is too far away from mark price"
      );
    }
    const { baseSize, quoteSize } = await this.inquireByBaseOrQuote(
      params,
      amm.markPrice,
      overrides ?? {}
    );
    const res = this._simulateOrder(
      instrument,
      amm,
      targetPrice,
      baseSize,
      params.leverage
    );
    return {
      ...res,
      tick: targetTick,
      size: {
        base: baseSize,
        quote: quoteSize,
      },
    };
  }
  async simulateBatchPlace(params, overrides) {
    const { instrument, amm } = await this.mustGetInstrumentAndAmm(
      params.tradeInfo,
      params.instrument,
      overrides ?? {}
    );
    if (
      params.targetTicks.length < constants_1.MIN_BATCH_ORDER_COUNT ||
      params.targetTicks.length > constants_1.MAX_BATCH_ORDER_COUNT
    ) {
      throw new simulationError_1.SimulationError(
        `Order count should be between ${constants_1.MIN_BATCH_ORDER_COUNT} and ${constants_1.MAX_BATCH_ORDER_COUNT}`
      );
    }
    if (params.targetTicks.length !== params.ratios.length) {
      throw new simulationError_1.SimulationError(
        "Ticks and ratios length not equal"
      );
    }
    if (
      params.ratios.reduce((acc, ratio) => acc + ratio, 0) !==
      constants_1.RATIO_BASE
    ) {
      throw new simulationError_1.SimulationError(
        "Ratios sum not equal to RATIO_BASE: 10000"
      );
    }
    if (new Set(params.targetTicks).size !== params.targetTicks.length) {
      throw new simulationError_1.SimulationError("Duplicated ticks");
    }
    if (
      params.targetTicks.find((tick) => tick % constants_1.PEARL_SPACING !== 0)
    ) {
      throw new simulationError_1.SimulationError("Unaligned ticks");
    }
    const orders = [];
    for (let index = 0; index < params.targetTicks.length; index++) {
      const { targetTick, targetPrice } = this.getPriceInfo(
        params.targetTicks[index]
      );
      try {
        const baseSize = (0, math_1.wmul)(
          params.baseSize,
          (0, math_1.r2w)(params.ratios[index])
        );
        const { quoteAmount: quoteSize } = await this.observer.inquireByBase(
          params.tradeInfo.instrumentAddr,
          params.tradeInfo.expiry,
          params.side,
          baseSize,
          overrides ?? {}
        );
        const res = this._simulateOrder(
          instrument,
          amm,
          targetPrice,
          baseSize,
          params.leverage
        );
        orders.push({
          ...res,
          tick: targetTick,
          size: {
            base: baseSize,
            quote: quoteSize,
          },
        });
      } catch {
        orders.push(null);
      }
    }
    return orders;
  }
  async simulateScaledLimitOrder(params, overrides) {
    if (
      params.priceInfo.length < constants_1.MIN_BATCH_ORDER_COUNT ||
      params.priceInfo.length > constants_1.MAX_BATCH_ORDER_COUNT
    ) {
      throw new simulationError_1.SimulationError(
        `Order count should be between ${constants_1.MIN_BATCH_ORDER_COUNT} and ${constants_1.MAX_BATCH_ORDER_COUNT}`
      );
    }
    const { instrument, amm } = await this.mustGetInstrumentAndAmm(
      params.tradeInfo,
      params.instrument,
      overrides ?? {}
    );
    const { baseSize, quoteSize } = await this.inquireByBaseOrQuote(
      params,
      amm.markPrice,
      overrides ?? {}
    );
    const targetTicks = params.priceInfo.map((p) =>
      typeof p === "number" ? p : math_1.TickMath.getTickAtPWad(p)
    );
    let ratios = (0, lowLevel_1.getBatchOrderRatios)(
      params.sizeDistribution,
      params.priceInfo.length
    );
    const minOrderValue = instrument.minOrderValue;
    const minSizes = targetTicks.map((tick) =>
      (0, math_1.wdivUp)(minOrderValue, math_1.TickMath.getWadAtTick(tick))
    );
    if (params.sizeDistribution === enum_1.BatchOrderSizeDistribution.RANDOM) {
      let needNewRatios = false;
      for (let i = 0; i < minSizes.length; i++) {
        if (
          baseSize.mul(ratios[i]).div(constants_1.RATIO_BASE).lt(minSizes[i])
        ) {
          needNewRatios = true;
          break;
        }
      }
      if (
        needNewRatios &&
        minSizes
          .reduce((acc, minSize) => acc.add(minSize), math_1.ZERO)
          .lt(baseSize)
      ) {
        ratios = (0, lowLevel_1.getBatchOrderRatios)(
          enum_1.BatchOrderSizeDistribution.FLAT,
          params.priceInfo.length
        );
      }
    }
    const sizes = ratios.map((ratio) =>
      baseSize.mul(ratio).div(constants_1.RATIO_BASE)
    );
    const bnMax = (a, b) => (a.gt(b) ? a : b);
    const minSizeToSizeRatio = minSizes
      .map((minSize, i) =>
        bnMax((0, math_1.wdivUp)(minSize, sizes[i]), math_1.ZERO)
      )
      .reduce((acc, ratio) => bnMax(acc, ratio), math_1.ZERO);
    const totalMinSize = (0, math_1.wmulUp)(baseSize, minSizeToSizeRatio);
    const res = await this.simulateBatchPlace(
      {
        tradeInfo: params.tradeInfo,
        targetTicks,
        ratios,
        baseSize,
        side: params.side,
        leverage: params.leverage,
        instrument,
      },
      overrides ?? {}
    );
    return {
      orders: targetTicks.map((tick, index) => {
        return (
          res[index] && {
            ...res[index],
            ratio: ratios[index],
            minOrderSize: minSizes[index],
          }
        );
      }),
      totalMinSize,
      size: {
        base: baseSize,
        quote: quoteSize,
      },
    };
  }
  _simulateOrder(instrument, amm, targetPrice, baseSize, leverage) {
    const markPrice = amm.markPrice;
    const tradeValue = (0, math_1.wmulUp)(targetPrice, baseSize);
    const bnMax = (a, b) => (a.gt(b) ? a : b);
    let margin = (0, math_1.wdivUp)(
      (0, math_1.wmulUp)(bnMax(targetPrice, markPrice), baseSize),
      leverage
    );
    const minMargin = (0, math_1.wmulUp)(
      (0, math_1.r2w)(instrument.setting.initialMarginRatio),
      (0, math_1.wmulUp)(
        (0, math_1.max)(
          markPrice.mul(constants_1.ONE_RATIO + 50).div(constants_1.ONE_RATIO),
          targetPrice
        ),
        baseSize
      )
    );
    if (margin.lt(minMargin)) {
      margin = minMargin;
    }
    return {
      limitPrice: targetPrice,
      tradeValue,
      margin,
      leverage,
      minFeeRebate: (0, math_1.wmul)(
        (0, math_1.wmul)(targetPrice, baseSize),
        (0, math_1.r2w)(instrument.setting.quoteParam.tradingFeeRatio)
      ),
    };
  }
  async simulateTrade(params, simulate, overrides) {
    let { instrument, amm } = await this.mustGetInstrumentAndAmm(
      params.tradeInfo,
      params.instrument,
      overrides ?? {}
    );
    const prePosition = await this.getPosition(
      params.tradeInfo,
      overrides ?? {}
    );
    const { baseSize, quoteSize, quotation } = await this.inquireByBaseOrQuote(
      params,
      amm.markPrice,
      overrides ?? {},
      true
    );
    if (baseSize.lte(0)) {
      throw new simulationError_1.SimulationError("Invalid trade size");
    }
    const sign = (0, utils_1.signOfSide)(params.side);
    const tradePrice = (0, math_1.wdiv)(
      quotation.entryNotional,
      baseSize.abs()
    );
    const limitTick = math_1.TickMath.getLimitTick(
      tradePrice,
      params.slippage,
      params.side
    );
    const markPrice = amm.markPrice;
    if (amm.expiry === constants_1.PERP_EXPIRY) {
      let timestamp;
      if (!overrides || !overrides.blockTag) {
        timestamp = Math.floor(Date.now() / 1000);
      } else {
        const block = await this.context.provider.getBlock(overrides.blockTag);
        timestamp = block.timestamp;
      }
      const { longFundingIndex, shortFundingIndex } = (0,
      lowLevel_1.updateFundingIndex)(amm, amm.markPrice, timestamp);
      amm = {
        ...amm,
        longFundingIndex,
        shortFundingIndex,
      };
    }
    let exceedMaxLeverage = false;
    const limitPrice = math_1.TickMath.getWadAtTick(limitTick);
    const worstNotional = (0, math_1.wmul)(limitPrice, baseSize);
    const tradeLoss =
      sign > 0
        ? worstNotional.sub((0, math_1.wmul)(markPrice, baseSize))
        : (0, math_1.wmul)(markPrice, baseSize).sub(worstNotional);
    const preEquity = (0, utils_1.positionEquity)(prePosition, amm);
    const rawSize = baseSize.mul(sign);
    let { margin, leverage } = simulate(
      markPrice,
      baseSize,
      sign,
      prePosition,
      preEquity,
      tradeLoss,
      quotation
    );
    const { position: rawPosition, realized: realized } = (0,
    lowLevel_1.combine)(amm, prePosition, {
      balance: margin.lt(0) ? quotation.fee.mul(-1) : margin.sub(quotation.fee),
      size: rawSize,
      entryNotional: quotation.entryNotional,
      entrySocialLossIndex:
        sign > 0 ? amm.longSocialLossIndex : amm.shortSocialLossIndex,
      entryFundingIndex:
        sign > 0 ? amm.longFundingIndex : amm.shortFundingIndex,
    });
    const postPosition = utils_1.factory.createPosition({
      ...prePosition,
      ...rawPosition,
    });
    if (!postPosition.size.eq(math_1.ZERO) && margin.lt(math_1.ZERO)) {
      const maxWithdrawableMargin = (0, utils_1.positionMaxWithdrawableMargin)(
        postPosition,
        amm,
        instrument.setting.initialMarginRatio
      );
      if (margin.abs().gt(maxWithdrawableMargin)) {
        if (params.strictMode) {
          throw new simulationError_1.SimulationError("Exceed max leverage");
        }
        margin = maxWithdrawableMargin.mul(-1);
        exceedMaxLeverage = true;
      }
      postPosition.balance = postPosition.balance.add(margin);
    }
    if (
      postPosition.size.eq(math_1.ZERO) ||
      (prePosition.size.mul(sign).lt(math_1.ZERO) &&
        baseSize.abs().lt(prePosition.size.abs()))
    ) {
      if (
        !(0, utils_1.isPositionMMSafe)(
          postPosition,
          amm,
          instrument.setting.maintenanceMarginRatio
        )
      ) {
        throw new simulationError_1.SimulationError(
          "Insufficient margin to open position"
        );
      }
    } else {
      if (
        !(0, utils_1.isPositionIMSafe)(
          postPosition,
          amm,
          instrument.setting.initialMarginRatio,
          true
        )
      ) {
        if (params.strictMode) {
          throw new simulationError_1.SimulationError("Exceed max leverage");
        }
        const additionalMargin = (0, utils_1.positionAdditionMarginToIMRSafe)(
          postPosition,
          amm,
          instrument.setting.initialMarginRatio,
          true,
          params.slippage
        );
        postPosition.balance = postPosition.balance.add(additionalMargin);
        margin = margin.add(additionalMargin);
        leverage = (0, utils_1.positionLeverage)(postPosition, amm);
        exceedMaxLeverage = true;
      }
    }
    const priceImpact = (0, math_1.wdiv)(
      (0, math_1.sqrtX96ToWad)(quotation.sqrtPostFairPX96).sub(
        (0, math_1.sqrtX96ToWad)(quotation.sqrtFairPX96)
      ),
      (0, math_1.sqrtX96ToWad)(quotation.sqrtFairPX96)
    );
    const stabilityFee = math_1.SqrtPriceMath.getStabilityFee(
      quotation,
      instrument.setting.quoteParam
    );
    return {
      tradePrice: tradePrice,
      tradeValue: quotation.entryNotional,
      tradingFee: quotation.fee.sub(stabilityFee),
      stabilityFee,
      margin,
      marginChanged:
        postPosition.size.eq(math_1.ZERO) &&
        postPosition.balance.gt(math_1.ZERO)
          ? postPosition.balance.mul(-1)
          : margin,
      leverage: postPosition.size.eq(math_1.ZERO) ? math_1.ZERO : leverage,
      priceImpact,
      postPosition,
      realized,
      limitTick,
      exceedMaxLeverage,
      size: {
        base: baseSize,
        quote: quoteSize,
      },
    };
  }
  simulateMarketOrderByMargin(params, overrides) {
    return this.simulateTrade(
      params,
      (
        markPrice,
        baseSize,
        sign,
        prePosition,
        preEquity,
        tradeLoss,
        quotation
      ) => {
        const postEquity = preEquity
          .add(params.margin)
          .sub(tradeLoss)
          .sub(quotation.fee);
        const leverage = (0, math_1.wdiv)(
          (0, math_1.wmul)(
            markPrice,
            baseSize.mul(sign).add(prePosition.size)
          ).abs(),
          postEquity
        );
        return { leverage, margin: params.margin };
      },
      overrides ?? {}
    );
  }
  _simulateMarketOrderByLeverage(params, overrides) {
    return this.simulateTrade(
      params,
      (
        markPrice,
        baseSize,
        sign,
        prePosition,
        preEquity,
        tradeLoss,
        quotation
      ) => {
        const postEquity = (0, math_1.wdiv)(
          (0, math_1.wmul)(
            markPrice,
            baseSize.mul(sign).add(prePosition.size)
          ).abs(),
          params.leverage
        );
        const margin = postEquity
          .sub(preEquity)
          .add(tradeLoss)
          .add(quotation.fee);
        return { leverage: params.leverage, margin };
      },
      overrides ?? {}
    );
  }
  simulateMarketOrderByLeverage(params, overrides) {
    return this._simulateMarketOrderByLeverage(params, overrides);
  }
  async simulateClose(params, overrides) {
    const prePosition = await this.getPosition(
      params.tradeInfo,
      overrides ?? {}
    );
    return await this.simulateTrade(
      {
        ...params,
        tradeInfo: prePosition,
        side: (0, utils_1.reverseSide)(prePosition.side),
      },
      (
        markPrice,
        baseSize,
        sign,
        prePosition,
        preEquity,
        tradeLoss,
        quotation
      ) => {
        const margin = math_1.ZERO;
        const postEquity = preEquity
          .add(math_1.ZERO)
          .sub(tradeLoss)
          .sub(quotation.fee);
        const leverage = (0, math_1.wdiv)(
          (0, math_1.wmul)(
            markPrice,
            baseSize.mul(sign).add(prePosition.size)
          ).abs(),
          postEquity
        );
        return { leverage, margin };
      },
      overrides ?? {}
    );
  }
  async simulateAdjustMargin(params, simulate, overrides) {
    const { instrument, amm } = await this.mustGetInstrumentAndAmm(
      params.tradeInfo,
      params.instrument,
      overrides ?? {}
    );
    let postPosition = await this.getPosition(
      params.tradeInfo,
      overrides ?? {}
    );
    const maxWithdrawableMargin = (0, utils_1.positionMaxWithdrawableMargin)(
      postPosition,
      amm,
      instrument.setting.initialMarginRatio
    );
    const { margin, leverage } = simulate(postPosition, amm);
    if (margin.lt(math_1.ZERO) && margin.abs().gt(maxWithdrawableMargin)) {
      throw new simulationError_1.SimulationError("Invalid input");
    }
    postPosition = {
      ...postPosition,
      balance: postPosition.balance.add(margin),
    };
    return {
      postPosition,
      transferIn: margin.gt(0),
      margin: margin.abs(),
      leverage,
    };
  }
  async simulateAdjustMarginByMargin(params, overrides) {
    if (params.margin.lt(0)) {
      throw new simulationError_1.SimulationError("Invalid margin");
    }
    const result = await this.simulateAdjustMargin(
      params,
      (position, amm) => {
        const margin = params.margin.mul(params.transferIn ? 1 : -1);
        const value = (0, math_1.wmul)(amm.markPrice, position.size.abs());
        const equity = (0, utils_1.positionEquity)(position, amm).add(margin);
        const leverage = (0, math_1.wdiv)(value, equity);
        return { leverage, margin };
      },
      overrides ?? {}
    );
    return {
      leverage: result.leverage,
      postPosition: result.postPosition,
    };
  }
  async simulateAdjustMarginByLeverage(params, overrides) {
    const result = await this.simulateAdjustMargin(
      params,
      (position, amm) => {
        const margin = (0, utils_1.inquireTransferAmountFromTargetLeverage)(
          position,
          amm,
          params.leverage
        );
        return { leverage: params.leverage, margin };
      },
      overrides ?? {}
    );
    return {
      transferIn: result.transferIn,
      margin: result.margin,
      postPosition: result.postPosition,
    };
  }
  async simulateBenchmarkPrice(instrumentIdentifier, expiry, overrides) {
    let benchmarkPrice;
    if ((0, utils_1.isCexMarket)(instrumentIdentifier.marketType)) {
      benchmarkPrice = await this.observer.inspectCexMarketBenchmarkPrice(
        instrumentIdentifier,
        expiry,
        overrides ?? {}
      );
    } else {
      benchmarkPrice = await this.observer.inspectDexV2MarketBenchmarkPrice(
        instrumentIdentifier,
        expiry,
        overrides ?? {}
      );
    }
    return benchmarkPrice;
  }
  async simulateAddLiquidity(params, overrides) {
    const res = await this._simulateAddLiquidityWithAsymmetricRange(
      {
        expiry: params.expiry,
        instrument: params.instrument,
        alphaWadLower: params.alphaWad,
        alphaWadUpper: params.alphaWad,
        margin: params.margin,
        slippage: params.slippage,
        currentSqrtPX96: params.currentSqrtPX96,
      },
      overrides ?? {}
    );
    return {
      ...res,
      tickDelta: res.tickDeltaUpper,
      equivalentAlpha: (0, utils_1.tickDeltaToAlphaWad)(
        ~~(
          (math_1.TickMath.getTickAtPWad(res.upperPrice) -
            math_1.TickMath.getTickAtPWad(res.lowerPrice)) /
          2
        )
      ),
    };
  }
  _getMinLiquidity(instrumentAmmSqrtPX96, instrumentMinRangeValue, px96) {
    const sqrtPX96 = px96 ? px96 : instrumentAmmSqrtPX96;
    return instrumentMinRangeValue.mul(math_1.Q96).div(sqrtPX96.mul(2));
  }
  async _simulateAddLiquidityWithAsymmetricRange(params, overrides) {
    const instrumentAddress = (
      (0, utils_1.isInstrument)(params.instrument)
        ? params.instrument.instrumentAddr
        : await this.context.perp.instrument.computeInstrumentAddress(
            params.instrument
          )
    ).toLowerCase();
    const instrumentIdentifier = (0, utils_1.isInstrument)(params.instrument)
      ? {
          marketType: params.instrument.marketType,
          baseSymbol: params.instrument.base,
          quoteSymbol: params.instrument.quote,
        }
      : params.instrument;
    const instruments = (
      await this.context.perp.contracts.gate.getAllInstruments(overrides ?? {})
    ).map((addr) => addr.toLowerCase());
    const info = instruments.includes(instrumentAddress)
      ? (0, utils_1.isInstrument)(params.instrument)
        ? {
            instrument: params.instrument,
            amm: params.instrument.amms.get(params.expiry),
          }
        : await this.getInstrumentAndAmm(
            { expiry: params.expiry, instrumentAddr: instrumentAddress },
            undefined,
            overrides ?? {}
          )
      : undefined;
    let quoteInfo;
    let setting;
    let amm;
    const instrument = info?.instrument;
    if (!instrument || !info?.amm) {
      const benchmarkPrice = await this.simulateBenchmarkPrice(
        instrumentIdentifier,
        params.expiry,
        overrides ?? {}
      );
      const { quoteTokenInfo } = await (0, utils_1.getTokenInfo)(
        instrumentIdentifier,
        this.context
      );
      quoteInfo = quoteTokenInfo;
      if (instrument) {
        setting = instrument.setting;
      } else {
        const quoteParam =
          await this.context.perp.contracts.config.getQuoteParam(
            quoteInfo.address,
            overrides ?? {}
          );
        setting = {
          initialMarginRatio: constants_1.INITIAL_MARGIN_RATIO,
          maintenanceMarginRatio: constants_1.MAINTENANCE_MARGIN_RATIO,
          quoteParam: { ...quoteParam },
        };
      }
      amm = utils_1.factory.createAmm({
        instrumentAddr: instrumentAddress,
        expiry: 0,
        timestamp: 0,
        status: enum_1.Status.TRADING,
        tick: math_1.TickMath.getTickAtPWad(benchmarkPrice),
        sqrtPX96: (0, math_1.wadToSqrtX96)(benchmarkPrice),
        liquidity: math_1.ZERO,
        totalLiquidity: math_1.ZERO,
        involvedFund: math_1.ZERO,
        openInterests: math_1.ZERO,
        feeIndex: math_1.ZERO,
        protocolFee: math_1.ZERO,
        totalLong: math_1.ZERO,
        totalShort: math_1.ZERO,
        longSocialLossIndex: math_1.ZERO,
        shortSocialLossIndex: math_1.ZERO,
        longFundingIndex: math_1.ZERO,
        shortFundingIndex: math_1.ZERO,
        insuranceFund: math_1.ZERO,
        settlementPrice: math_1.ZERO,
        markPrice: math_1.ZERO,
      });
    } else {
      amm = info.amm;
      quoteInfo = instrument.quote;
      setting = instrument.setting;
    }
    const minTradeValue = setting.quoteParam.minMarginAmount
      .mul(constants_1.RATIO_BASE)
      .div(setting.initialMarginRatio);
    const instrumentMinRangeValue = minTradeValue.mul(
      constants_1.MIN_RANGE_MULTIPLIER
    );
    const tickDeltaLower = (0, utils_1.alphaWadToTickDelta)(
      params.alphaWadLower
    );
    const tickDeltaUpper = (0, utils_1.alphaWadToTickDelta)(
      params.alphaWadUpper
    );
    const upperTick = (0, lowLevel_1.alignRangeTick)(
      amm.tick + tickDeltaUpper,
      false
    );
    const lowerTick = (0, lowLevel_1.alignRangeTick)(
      amm.tick - tickDeltaLower,
      true
    );
    const upperPrice = math_1.TickMath.getWadAtTick(upperTick);
    const lowerPrice = math_1.TickMath.getWadAtTick(lowerTick);
    const { liquidity: liquidity } = (0, lowLevel_1.entryDelta)(
      amm.sqrtPX96,
      lowerTick,
      upperTick,
      params.margin,
      setting.initialMarginRatio
    );
    const { tickLower, tickUpper } = (0, utils_1.parseTicks)(
      (0, utils_1.rangeKey)(lowerTick, upperTick)
    );
    const simulationRange = {
      liquidity,
      balance: params.margin,
      sqrtEntryPX96: amm.sqrtPX96,
      entryFeeIndex: amm.feeIndex,
      tickLower,
      tickUpper,
    };
    const rawLowerPosition = (0, utils_1.rangeLowerPositionIfRemove)(
      simulationRange,
      amm
    );
    const rawUpperPosition = (0, utils_1.rangeUpperPositionIfRemove)(
      simulationRange,
      amm
    );
    const minMargin = (0, lowLevel_1.getMarginFromLiquidity)(
      amm.sqrtPX96,
      upperTick,
      this._getMinLiquidity(
        amm.sqrtPX96,
        instrumentMinRangeValue,
        amm.sqrtPX96
      ),
      setting.initialMarginRatio
    );
    const basedPX96 = params.currentSqrtPX96
      ? params.currentSqrtPX96
      : amm.sqrtPX96;
    const sqrtStrikeLowerPX96 = basedPX96.sub(
      (0, math_1.wmulDown)(basedPX96, (0, math_1.r2w)(params.slippage))
    );
    const sqrtStrikeUpperPX96 = basedPX96.add(
      (0, math_1.wmulDown)(basedPX96, (0, math_1.r2w)(params.slippage))
    );
    return {
      tickDeltaLower,
      tickDeltaUpper,
      liquidity,
      upperPrice: math_1.TickMath.getWadAtTick(simulationRange.tickUpper),
      lowerPrice: math_1.TickMath.getWadAtTick(simulationRange.tickLower),
      lowerPosition: utils_1.factory.createPosition({
        instrumentAddr: instrumentAddress,
        expiry: params.expiry,
        traderAddr: math_1.ADDRESS_ZERO,
        ...rawLowerPosition,
      }),
      lowerLeverage: rawLowerPosition.size
        .mul(lowerPrice)
        .div(rawLowerPosition.balance)
        .abs(),
      upperPosition: utils_1.factory.createPosition({
        instrumentAddr: instrumentAddress,
        expiry: params.expiry,
        traderAddr: math_1.ADDRESS_ZERO,
        ...rawUpperPosition,
      }),
      upperLeverage: rawUpperPosition.size
        .mul(upperPrice)
        .div(rawUpperPosition.balance)
        .abs(),
      limitTicks: math_1.TickMath.encodeLimitTicks(
        sqrtStrikeLowerPX96,
        sqrtStrikeUpperPX96
      ),
      minMargin,
      minEffectiveQuoteAmount: instrumentMinRangeValue,
      equivalentAlphaLower: (0, utils_1.tickDeltaToAlphaWad)(
        ~~(upperTick - amm.tick)
      ),
      equivalentAlphaUpper: (0, utils_1.tickDeltaToAlphaWad)(
        ~~(amm.tick - lowerTick)
      ),
      capitalEfficiencyBoost:
        params.alphaWadLower === params.alphaWadUpper
          ? (0, math_1.calcBoost)(
              Number.parseFloat(
                ethers_1.ethers.utils.formatUnits(params.alphaWadLower)
              ),
              setting.initialMarginRatio
            )
          : (0, math_1.calcAsymmetricBoost)(
              Number.parseFloat(
                ethers_1.ethers.utils.formatUnits(params.alphaWadLower)
              ),
              Number.parseFloat(
                ethers_1.ethers.utils.formatUnits(params.alphaWadUpper)
              ),
              setting.initialMarginRatio
            ),
    };
  }
  async simulateAddLiquidityWithAsymmetricRange(params, overrides) {
    return await this._simulateAddLiquidityWithAsymmetricRange(
      params,
      overrides ?? {}
    );
  }
  async simulateRemoveLiquidity(params, overrides) {
    const portfolio = await this.getPortfolio(
      params.tradeInfo,
      overrides ?? {}
    );
    const position = portfolio.position;
    const range = portfolio.ranges.get(
      (0, utils_1.rangeKey)(params.tickLower, params.tickUpper)
    );
    if (!range) {
      throw new simulationError_1.SimulationError("Missing range");
    }
    const { amm } = await this.mustGetInstrumentAndAmm(
      params.tradeInfo,
      params.instrument,
      overrides ?? {}
    );
    const rawPositionRemoved = (0, utils_1.rangeToPosition)(range, amm);
    const rawMainPosition = (0, lowLevel_1.combine)(
      amm,
      rawPositionRemoved,
      position
    ).position;
    const postPosition = utils_1.factory.createPosition({
      ...rawMainPosition,
      instrumentAddr: position.instrumentAddr,
      expiry: position.expiry,
      traderAddr: position.traderAddr,
    });
    const removedPosition = utils_1.factory.createPosition({
      ...rawPositionRemoved,
      instrumentAddr: position.instrumentAddr,
      expiry: position.expiry,
      traderAddr: position.traderAddr,
    });
    const sqrtStrikeLowerPX96 = amm.sqrtPX96.sub(
      (0, math_1.wmulDown)(amm.sqrtPX96, (0, math_1.r2w)(params.slippage))
    );
    const sqrtStrikeUpperPX96 = amm.sqrtPX96.add(
      (0, math_1.wmulDown)(amm.sqrtPX96, (0, math_1.r2w)(params.slippage))
    );
    return {
      removedPosition,
      postPosition,
      limitTicks: math_1.TickMath.encodeLimitTicks(
        sqrtStrikeLowerPX96,
        sqrtStrikeUpperPX96
      ),
      removedPositionEntryPrice: (0, math_1.sqrt)(
        (0, math_1.sqrtX96ToWad)(amm.sqrtPX96).mul(
          (0, math_1.sqrtX96ToWad)(range.sqrtEntryPX96)
        )
      ),
    };
  }
}
exports.SimulateModule = SimulateModule;
