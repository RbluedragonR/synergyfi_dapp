"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InverseInstrumentModule = void 0;
const utils_1 = require("../../utils");
const instrument_module_1 = require("../instrument.module");
class InverseInstrumentModule extends instrument_module_1.InstrumentModule {
  async addLiquidity(param, txOptions) {
    const isInverse =
      typeof param.instrumentAddr === "string"
        ? await this.context.perp.configuration.isInverse(param.instrumentAddr)
        : await this.context.perp.configuration.isInverseByIdentifier(
            param.instrumentAddr
          );
    return isInverse
      ? await super.addLiquidity(
          {
            ...param,
            tickDeltaLower: param.tickDeltaUpper,
            tickDeltaUpper: param.tickDeltaLower,
          },
          txOptions
        )
      : await super.addLiquidity(param, txOptions);
  }
  async removeLiquidity(param, txOptions) {
    const isInverse = await this.context.perp.configuration.isInverse(
      param.instrumentAddr
    );
    return isInverse
      ? await super.removeLiquidity(
          {
            ...param,
            tickLower: param.tickUpper,
            tickUpper: param.tickLower,
          },
          txOptions
        )
      : await super.removeLiquidity(param, txOptions);
  }
  async placeLimitOrder(param, txOptions) {
    const isInverse = await this.context.perp.configuration.isInverse(
      param.instrumentAddr
    );
    return isInverse
      ? await super.placeLimitOrder(
          {
            ...param,
            side: (0, utils_1.reverseSide)(param.side),
          },
          txOptions
        )
      : await super.placeLimitOrder(param, txOptions);
  }
  async placeMarketOrder(param, txOptions) {
    const isInverse = await this.context.perp.configuration.isInverse(
      param.instrumentAddr
    );
    return isInverse
      ? await super.placeMarketOrder(
          {
            ...param,
            side: (0, utils_1.reverseSide)(param.side),
          },
          txOptions
        )
      : await super.placeMarketOrder(param, txOptions);
  }
  async batchPlaceLimitOrder(param, txOptions) {
    const isInverse = await this.context.perp.configuration.isInverse(
      param.instrumentAddr
    );
    return isInverse
      ? await super.batchPlaceLimitOrder(
          {
            ...param,
            side: (0, utils_1.reverseSide)(param.side),
          },
          txOptions
        )
      : await super.batchPlaceLimitOrder(param, txOptions);
  }
  async placeCrossMarketOrder(param, txOptions) {
    const isInverse = await this.context.perp.configuration.isInverse(
      param.instrumentAddr
    );
    return isInverse
      ? await super.placeCrossMarketOrder(
          {
            ...param,
            side: (0, utils_1.reverseSide)(param.side),
          },
          txOptions
        )
      : await super.placeCrossMarketOrder(param, txOptions);
  }
}
exports.InverseInstrumentModule = InverseInstrumentModule;
