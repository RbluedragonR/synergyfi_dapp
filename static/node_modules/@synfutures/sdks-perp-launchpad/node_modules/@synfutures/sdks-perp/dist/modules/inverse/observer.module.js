"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InverseObserverModule = void 0;
const utils_1 = require("../../utils");
const observer_module_1 = require("../observer.module");
class InverseObserverModule extends observer_module_1.ObserverModule {
  async getPortfolio(params, overrides) {
    const result = await super.getPortfolio(params, overrides);
    const portfolios = await Promise.all(
      (Array.isArray(result) ? result : [result]).map((p) =>
        this.context.perp.configuration
          .isInverse(p.instrumentAddr)
          .then((isInverse) =>
            isInverse ? (0, utils_1.reversePortfolio)(p) : p
          )
      )
    );
    return portfolios.length === 1 ? portfolios[0] : portfolios;
  }
  async getAllInstruments(overrides) {
    const instruments = await super.getAllInstruments(overrides);
    return await Promise.all(
      instruments.map((i) =>
        this.context.perp.configuration
          .isInverse(i.instrumentAddr)
          .then((isInverse) =>
            isInverse ? (0, utils_1.reverseInstrument)(i) : i
          )
      )
    );
  }
  async getInstrument(params, overrides) {
    const instrument = await super.getInstrument(params, overrides);
    if (!Array.isArray(instrument)) {
      const isInverse = await this.context.perp.configuration.isInverse(
        instrument.instrumentAddr
      );
      return isInverse
        ? (0, utils_1.reverseInstrument)(instrument)
        : instrument;
    } else {
      return await Promise.all(
        instrument.map((i) =>
          this.context.perp.configuration
            .isInverse(i.instrumentAddr)
            .then((isInverse) =>
              isInverse ? (0, utils_1.reverseInstrument)(i) : i
            )
        )
      );
    }
  }
  async getPositionIfSettle(portfolio, amm) {
    const isInverse = await this.context.perp.configuration.isInverse(
      portfolio.instrumentAddr
    );
    const position = await super.getPositionIfSettle(
      isInverse ? (0, utils_1.reversePortfolio)(portfolio) : portfolio,
      isInverse ? (0, utils_1.reverseAmm)(amm) : amm
    );
    return isInverse ? (0, utils_1.reversePosition)(position) : position;
  }
  async inquireByBase(instrumentAddr, expiry, side, baseAmount, overrides) {
    const isInverse = await this.context.perp.configuration.isInverse(
      instrumentAddr
    );
    return await super.inquireByBase(
      instrumentAddr,
      expiry,
      isInverse ? (0, utils_1.reverseSide)(side) : side,
      baseAmount,
      overrides
    );
  }
  async inquireByQuote(instrumentAddr, expiry, side, quoteAmount, overrides) {
    const isInverse = await this.context.perp.configuration.isInverse(
      instrumentAddr
    );
    return await super.inquireByQuote(
      instrumentAddr,
      expiry,
      isInverse ? (0, utils_1.reverseSide)(side) : side,
      quoteAmount,
      overrides
    );
  }
  async getRawSpotPrice(identifier, overrides) {
    const isInverse =
      await this.context.perp.configuration.isInverseByIdentifier(identifier);
    const result = await super.getRawSpotPrice(identifier, overrides);
    return isInverse ? (0, utils_1.reversePrice)(result) : result;
  }
}
exports.InverseObserverModule = InverseObserverModule;
