"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GuardianParser = void 0;
const ethers_1 = require("ethers");
const context_1 = require("@derivation-tech/context");
const typechain_1 = require("../typechain");
const utils_1 = require("../utils");
const enum_1 = require("../enum");
const farmat_1 = require("./farmat");
class GuardianParser extends context_1.ContractParser {
  constructor() {
    super(typechain_1.Guardian__factory.createInterface());
  }
  async parseBaseParam(_description, param, data) {
    switch (param.name) {
      case "tradingFeeRatio":
      case "protocolFeeRatio":
        return (0, farmat_1.formatRatio)(data);
      case "stabilityFeeRatioParam":
        return (0, farmat_1.extractFeeRatioParams)(
          ethers_1.BigNumber.from(data)
        )
          .map((p) => (0, context_1.formatWad)(p))
          .toString();
      case "tip":
      case "minMarginAmount":
        return (0, context_1.formatWad)(data);
      case "expiry":
        return (0, utils_1.formatExpiry)(data);
      case "qtype":
        return enum_1.QuoteType[Number(data)];
      case "ftype":
        return enum_1.FeederType[Number(data)];
      case "compactEmaParam":
        return (0, farmat_1.formatCompactEmaParam)(
          ethers_1.BigNumber.from(data)
        );
      default:
        return data.toString();
    }
  }
  async parseBaseArrayParam(description, param, value) {
    if (
      description.name === "recycleInsuranceFund" &&
      param.name === "expiries"
    ) {
      return value
        .map((expiry) => (0, utils_1.formatExpiry)(expiry))
        .toString();
    } else if (
      description.name === "claimProtocolFee" &&
      param.name === "expiries"
    ) {
      return value
        .map((expiry) => (0, utils_1.formatExpiry)(expiry))
        .toString();
    }
    return await super.parseBaseArrayParam(description, param, value);
  }
}
exports.GuardianParser = GuardianParser;
