"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PerpLaunchpadModule = void 0;
const ethers_1 = require("ethers");
const utils_1 = require("ethers/lib/utils");
const sdks_perp_1 = require("@synfutures/sdks-perp");
const typechain_1 = require("../typechain");
const context_1 = require("@derivation-tech/context");
const utils_2 = require("../utils");
const factory_1 = require("./factory");
const errors_1 = require("../errors");
const across_plugin_1 = require("@derivation-tech/across-plugin");
class PerpLaunchpadModule {
  constructor(ctx) {
    this.ctx = ctx;
    this.factory = new factory_1.PerpLaunchpadFactory(ctx);
  }
  getVault(vault) {
    return typechain_1.Vault__factory.connect(vault, this.ctx.provider);
  }
  async getQuoteAddr(vault, overrides) {
    return (await this.getVault(vault).getConfiguration(overrides ?? {})).quote;
  }
  async getQuoteToken(vault, overrides) {
    return this.ctx.getTokenInfo(
      await this.getQuoteAddr(vault, overrides ?? {})
    );
  }
  async getPortfolioValue(vault, overrides) {
    return await this.getVault(vault).getPortfolioValue(overrides ?? {});
  }
  async getUserStake(vault, user, overrides) {
    return await this.getVault(vault).getStake(user, overrides ?? {});
  }
  async getOwedQuote(vault, user, overrides) {
    const vaultContract = this.getVault(vault);
    const share = await vaultContract.owedShareOf(user, overrides ?? {});
    if (share.eq(context_1.ZERO)) {
      return {
        netValue: context_1.ZERO,
        commissionFee: context_1.ZERO,
      };
    }
    return await vaultContract.getOwedQuote(user, overrides ?? {});
  }
  async inquireWithdrawal(vault, user, quoteAmount, overrides) {
    const vaultInstance = this.getVault(vault);
    try {
      const [totalValue, totalShares] = await Promise.all([
        vaultInstance.getPortfolioValue(overrides ?? {}),
        vaultInstance.totalShare(overrides ?? {}),
      ]);
      const shares = quoteAmount.mul(totalShares).div(totalValue);
      return await vaultInstance.inquireWithdrawal(
        user,
        shares,
        overrides ?? {}
      );
    } catch (e) {
      throw new errors_1.VaultError(JSON.stringify(e, null, 2));
    }
  }
  async getLiveThreshold(vault, overrides) {
    const vaultInstance = this.getVault(vault);
    const quoteAddr = await this.getQuoteAddr(vault, overrides ?? {});
    const quoteToken = await this.ctx.getTokenInfo(quoteAddr);
    return Number(
      (0, context_1.formatUnits)(
        (await vaultInstance.getConfiguration(overrides ?? {})).liveThreshold,
        quoteToken.decimals
      )
    );
  }
  async deposit(vault, isNative, quoteAmount, txOptions) {
    const quoteToken = await this.getQuoteToken(
      vault,
      sdks_perp_1.utils.toPopulatedTxOverrides(txOptions)
    );
    const vaultInstance = this.getVault(vault);
    const quoteAmountConver =
      sdks_perp_1.NumericConverter.toContractQuoteAmount(
        quoteAmount,
        quoteToken.decimals
      );
    if (isNative) {
      const tx = await vaultInstance.populateTransaction.deposit(
        quoteAmountConver,
        {
          value: quoteAmountConver,
          ...sdks_perp_1.utils.toPopulatedTxOverrides(txOptions),
        }
      );
      return await this.ctx.tx.sendTx(tx, txOptions);
    } else {
      const tx = await vaultInstance.populateTransaction.deposit(
        quoteAmountConver,
        sdks_perp_1.utils.toPopulatedTxOverrides(txOptions)
      );
      return await this.ctx.tx.sendTx(tx, txOptions);
    }
  }
  async withdraw(vault, isNative, shares, txOptions) {
    const vaultInstance = this.getVault(vault);
    const tx = await vaultInstance.populateTransaction.withdraw(
      isNative,
      shares,
      sdks_perp_1.utils.toPopulatedTxOverrides(txOptions)
    );
    return await this.ctx.tx.sendTx(tx, txOptions);
  }
  async withdrawQuote(vault, isNative, quoteAmount, txOptions) {
    const vaultInstance = this.getVault(vault);
    const quoteToken = await this.getQuoteToken(
      vault,
      sdks_perp_1.utils.toPopulatedTxOverrides(txOptions)
    );
    const quoteAmountConver =
      sdks_perp_1.NumericConverter.toContractQuoteAmount(
        quoteAmount,
        quoteToken.decimals
      );
    const traderAddr =
      txOptions?.from ?? (await txOptions?.signer?.getAddress());
    if (!traderAddr) {
      throw new errors_1.VaultError(
        "TxOptions.signer or txOptions.from is required"
      );
    }
    const [totalValue, totalShare, stake] = await Promise.all([
      vaultInstance.getPortfolioValue(
        sdks_perp_1.utils.toPopulatedTxOverrides(txOptions)
      ),
      vaultInstance.totalShare(
        sdks_perp_1.utils.toPopulatedTxOverrides(txOptions)
      ),
      vaultInstance.getStake(
        traderAddr,
        sdks_perp_1.utils.toPopulatedTxOverrides(txOptions)
      ),
    ]);
    const share = quoteAmountConver
      .mul(totalShare)
      .add(totalValue.sub(context_1.ONE))
      .div(totalValue);
    const tx = await vaultInstance.populateTransaction.withdraw(
      isNative,
      share.gt(stake.share) ? stake.share : share,
      sdks_perp_1.utils.toPopulatedTxOverrides(txOptions)
    );
    return await this.ctx.tx.sendTx(tx, txOptions);
  }
  async payoff(vault, addrLists, txOptions) {
    const vaultInstance = this.getVault(vault);
    const tx = await vaultInstance.populateTransaction.payoff(
      addrLists,
      sdks_perp_1.utils.toPopulatedTxOverrides(txOptions)
    );
    return await this.ctx.tx.sendTx(tx, txOptions);
  }
  async launch(vault, baseSymbol, mtype, instrument, addParam, txOptions) {
    const tokenInfo = await this.ctx.getTokenInfo(baseSymbol);
    const abiCoder = new utils_1.AbiCoder();
    const vaultInstance = this.getVault(vault);
    const quoteAddr = await this.getQuoteAddr(
      vault,
      sdks_perp_1.utils.toPopulatedTxOverrides(txOptions)
    );
    const tx = await vaultInstance.populateTransaction.launch(
      mtype,
      instrument,
      abiCoder.encode(
        [mtype === "LINK" ? "string" : "address", "address"],
        [mtype === "LINK" ? baseSymbol : tokenInfo.address, quoteAddr]
      ),
      sdks_perp_1.utils.encodeAddParam(addParam),
      sdks_perp_1.utils.toPopulatedTxOverrides(txOptions)
    );
    return await this.ctx.tx.sendTx(tx, txOptions);
  }
  async add(vault, instrument, addParam, txOptions) {
    const vaultInstance = this.getVault(vault);
    const tx = await vaultInstance.populateTransaction.add(
      instrument,
      sdks_perp_1.utils.encodeAddParam(addParam),
      sdks_perp_1.utils.toPopulatedTxOverrides(txOptions)
    );
    return await this.ctx.tx.sendTx(tx, txOptions);
  }
  async remove(vault, instrument, removeParam, txOptions) {
    const vaultInstance = this.getVault(vault);
    const tx = await vaultInstance.populateTransaction.remove(
      instrument,
      sdks_perp_1.utils.encodeRemoveParam(removeParam),
      sdks_perp_1.utils.toPopulatedTxOverrides(txOptions)
    );
    return await this.ctx.tx.sendTx(tx, txOptions);
  }
  async trade(vault, instrument, tradeParam, txOptions) {
    const vaultInstance = this.getVault(vault);
    const tx = await vaultInstance.populateTransaction.trade(
      instrument,
      sdks_perp_1.utils.encodeTradeParam(tradeParam),
      sdks_perp_1.utils.toPopulatedTxOverrides(txOptions)
    );
    return await this.ctx.tx.sendTx(tx, txOptions);
  }
  async place(vault, instrument, placeParam, txOptions) {
    const vaultInstance = this.getVault(vault);
    const tx = await vaultInstance.populateTransaction.place(
      instrument,
      sdks_perp_1.utils.encodePlaceParam(placeParam),
      sdks_perp_1.utils.toPopulatedTxOverrides(txOptions)
    );
    return await this.ctx.tx.sendTx(tx, txOptions);
  }
  async batchPlace(vault, instrument, batchPlaceParam, txOptions) {
    const vaultInstance = this.getVault(vault);
    const tx = await vaultInstance.populateTransaction.batchPlace(
      instrument,
      sdks_perp_1.utils.encodeBatchPlaceParam(
        batchPlaceParam.expiry,
        batchPlaceParam.size,
        batchPlaceParam.leverage,
        batchPlaceParam.ticks,
        batchPlaceParam.ratios,
        batchPlaceParam.deadline
      ),
      sdks_perp_1.utils.toPopulatedTxOverrides(txOptions)
    );
    return await this.ctx.tx.sendTx(tx, txOptions);
  }
  async fill(vault, instrument, fillParam, txOptions) {
    const vaultInstance = this.getVault(vault);
    const tx = await vaultInstance.populateTransaction.fill(
      instrument,
      sdks_perp_1.utils.encodeFillParam(fillParam),
      sdks_perp_1.utils.toPopulatedTxOverrides(txOptions)
    );
    return await this.ctx.tx.sendTx(tx, txOptions);
  }
  async batchCancel(vault, instrument, expiry, ticks, txOptions) {
    const vaultInstance = this.getVault(vault);
    const tx = await vaultInstance.populateTransaction.batchCancel(
      instrument,
      expiry,
      (0, utils_2.encodeBatchCancelTicks)(ticks),
      sdks_perp_1.utils.toPopulatedTxOverrides(txOptions)
    );
    return await this.ctx.tx.sendTx(tx, txOptions);
  }
  async liquidate(vault, instrument, liquidateParam, txOptions) {
    const vaultInstance = this.getVault(vault);
    const tx = await vaultInstance.populateTransaction.liquidate(
      instrument,
      liquidateParam.expiry,
      liquidateParam.target,
      liquidateParam.size,
      liquidateParam.amount,
      sdks_perp_1.utils.toPopulatedTxOverrides(txOptions)
    );
    return this.ctx.tx.sendTx(tx, txOptions);
  }
  async settle(vault, instrument, expiry, txOptions) {
    const vaultInstance = this.getVault(vault);
    const tx = await vaultInstance.populateTransaction.settle(
      instrument,
      expiry,
      sdks_perp_1.utils.toPopulatedTxOverrides(txOptions)
    );
    return this.ctx.tx.sendTx(tx, txOptions);
  }
  async collectCommission(vault, isNative, amount, txOptions) {
    const vaultInstance = this.getVault(vault);
    const tx = await vaultInstance.populateTransaction.collectCommission(
      isNative,
      amount,
      sdks_perp_1.utils.toPopulatedTxOverrides(txOptions)
    );
    return this.ctx.tx.sendTx(tx, txOptions);
  }
  async acrossDepositFor(
    originChainId,
    destinationChainId,
    fromToken,
    toToken,
    vaultAddress,
    userAddress,
    amount,
    txOptions
  ) {
    const recipient =
      across_plugin_1.MULTICALL_HANDLER_ADDRESS[destinationChainId];
    const preMessage = (0, utils_2.generateMessageForMulticallHandler)(
      userAddress,
      vaultAddress,
      toToken,
      amount
    );
    const suggestedFees = await this.ctx.across.getSuggestedFees({
      originChainId,
      destinationChainId,
      token: fromToken,
      amount,
      recipient,
      message: preMessage,
    });
    const outputAmount = amount.sub(
      ethers_1.BigNumber.from(suggestedFees.totalRelayFee.total)
    );
    const message = (0, utils_2.generateMessageForMulticallHandler)(
      userAddress,
      vaultAddress,
      toToken,
      outputAmount
    );
    return await this.ctx.across.crosschain(
      {
        suggestedFees: suggestedFees,
        fromChainId: originChainId,
        destinationChainId,
        inputToken: fromToken,
        inputAmount: amount,
        recipient,
        message,
      },
      txOptions
    );
  }
}
exports.PerpLaunchpadModule = PerpLaunchpadModule;
