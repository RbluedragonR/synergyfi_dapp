"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PerpLaunchpadFactory = void 0;
const ethers_1 = require("ethers");
const sdks_perp_1 = require("@synfutures/sdks-perp");
const typechain_1 = require("../typechain");
const constants_1 = require("../constants");
const enum_1 = require("../enum");
const errors_1 = require("../errors");
class PerpLaunchpadFactory {
  constructor(ctx) {
    this.ctx = ctx;
    const address = constants_1.VAULT_FACTORY_ADDRESSES[ctx.chainId];
    if (address) {
      this._perpLaunchpadFactory = typechain_1.VaultFactory__factory.connect(
        address,
        ctx.provider
      );
    }
  }
  get vaultFactory() {
    if (!this._perpLaunchpadFactory) {
      throw new Error("Unknown vault network");
    }
    return this._perpLaunchpadFactory;
  }
  async getAllVaults(overrides) {
    return await this.vaultFactory.getAllVaults(overrides ?? {});
  }
  async getVaultAddr(quoteAddr, managerAddr, name, overrides) {
    const index = ethers_1.ethers.utils.keccak256(
      ethers_1.ethers.utils.defaultAbiCoder.encode(
        ["string", "string", "string"],
        [quoteAddr, managerAddr, name]
      )
    );
    return await this.vaultFactory.indexToVault(index, overrides ?? {});
  }
  async getTotalVaults(overrides) {
    return await this.vaultFactory.totalVaults(overrides ?? {});
  }
  async createVault(
    quoteAddr,
    managerAddr,
    name,
    maxRange,
    maxOrder,
    maxPair,
    commissionRatio,
    liveThreshold,
    txOptions
  ) {
    const tokenInfo = await this.ctx.getTokenInfo(quoteAddr);
    const tx = await this.vaultFactory.populateTransaction.createVault(
      managerAddr,
      name,
      {
        stage: 0,
        quote: quoteAddr,
        decimals: tokenInfo.decimals,
        maxPair,
        maxRange,
        maxOrder,
        commissionRatio,
        minQuoteAmount: 0,
        liveThreshold: ethers_1.ethers.utils.parseUnits(
          liveThreshold.toString(),
          tokenInfo.decimals
        ),
      }
    );
    await this.ctx.tx.sendTx(tx, txOptions);
    const vaultAddr = await this.getVaultAddr(
      quoteAddr,
      managerAddr,
      name,
      sdks_perp_1.utils.toPopulatedTxOverrides(txOptions)
    );
    if (vaultAddr === "0x") {
      throw new errors_1.VaultError("Vault not found: " + vaultAddr);
    }
    return vaultAddr;
  }
  async setVaultManager(vaultAddr, managerAddr, txOptions) {
    const ptx = await this.vaultFactory.populateTransaction.setVaultManager(
      vaultAddr,
      managerAddr,
      sdks_perp_1.utils.toPopulatedTxOverrides(txOptions)
    );
    return await this.ctx.tx.sendTx(ptx, txOptions);
  }
  async setVaultStage(vaultAddr, stage, txOptions) {
    let stageNum;
    switch (stage) {
      case enum_1.Stage.UPCOMING:
        stageNum = 0;
        break;
      case enum_1.Stage.LIVE:
        stageNum = 1;
        break;
      case enum_1.Stage.SUSPENDED:
        stageNum = 2;
        break;
      case enum_1.Stage.INVALID:
        stageNum = 3;
        break;
    }
    const ptx = await this.vaultFactory.populateTransaction.setVaultStage(
      vaultAddr,
      stageNum,
      sdks_perp_1.utils.toPopulatedTxOverrides(txOptions)
    );
    return await this.ctx.tx.sendTx(ptx, txOptions);
  }
  async setVaultPortfolioLimit(
    vaultAddr,
    maxPair,
    maxRange,
    maxOrder,
    txOptions
  ) {
    const ptx =
      await this.vaultFactory.populateTransaction.setVaultPortfolioLimit(
        vaultAddr,
        maxPair,
        maxRange,
        maxOrder,
        sdks_perp_1.utils.toPopulatedTxOverrides(txOptions)
      );
    return await this.ctx.tx.sendTx(ptx, txOptions);
  }
  async setVaultMinQuoteAmount(vaultAddr, minQuoteAmount, txOptions) {
    const configuration = await typechain_1.Vault__factory.connect(
      vaultAddr,
      this.ctx.provider
    ).getConfiguration(sdks_perp_1.utils.toPopulatedTxOverrides(txOptions));
    const ptx =
      await this.vaultFactory.populateTransaction.setVaultMinQuoteAmount(
        vaultAddr,
        ethers_1.ethers.utils.parseUnits(
          minQuoteAmount.toString(),
          configuration.decimals
        ),
        sdks_perp_1.utils.toPopulatedTxOverrides(txOptions)
      );
    return await this.ctx.tx.sendTx(ptx, txOptions);
  }
  async setVaultCommissionRatio(vaultAddr, ratio, txOptions) {
    const ptx =
      await this.vaultFactory.populateTransaction.setVaultCommissionRatio(
        vaultAddr,
        ratio,
        sdks_perp_1.utils.toPopulatedTxOverrides(txOptions)
      );
    return await this.ctx.tx.sendTx(ptx, txOptions);
  }
  async setVaultLiveThreshold(vaultAddr, liveThreshold, txOptions) {
    const configuration = await typechain_1.Vault__factory.connect(
      vaultAddr,
      this.ctx.provider
    ).getConfiguration(sdks_perp_1.utils.toPopulatedTxOverrides(txOptions));
    const ptx =
      await this.vaultFactory.populateTransaction.setVaultLiveThreshold(
        vaultAddr,
        ethers_1.ethers.utils.parseUnits(
          liveThreshold.toString(),
          configuration.decimals
        ),
        sdks_perp_1.utils.toPopulatedTxOverrides(txOptions)
      );
    return await this.ctx.tx.sendTx(ptx, txOptions);
  }
}
exports.PerpLaunchpadFactory = PerpLaunchpadFactory;
