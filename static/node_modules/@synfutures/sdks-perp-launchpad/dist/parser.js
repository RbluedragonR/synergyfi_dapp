"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VaultParser = void 0;
const context_1 = require("@derivation-tech/context");
const ethers_1 = require("ethers");
const utils_1 = require("ethers/lib/utils");
const typechain_1 = require("./typechain");
const utils_2 = require("./utils");
const sdks_perp_1 = require("@synfutures/sdks-perp");
function formatArg(obj) {
  let str = "";
  for (const [k, v] of Object.entries(obj)) {
    if (v instanceof ethers_1.BigNumber) {
      if (k === "limitTicks") {
        str += `minTickLower: ${v.toNumber() >> 24}, maxTickUpper: ${
          v.toNumber() & ((1 << 24) - 1)
        }, `;
      } else {
        str += `${k}: ${(0, utils_1.formatEther)(v)}, `;
      }
    } else if (typeof v === "number") {
      if (k === "expiry") str += `${k}: ${sdks_perp_1.utils.formatExpiry(v)}, `;
      else if (k.toLowerCase().includes("tick"))
        str += `${k}: ${(0, sdks_perp_1.formatTick)(v)}, `;
      else if (k === "deadline")
        str += `${k}: ${(0, sdks_perp_1.formatTimestamp)(v)}, `;
      else str += `${k}: ${v.toString()}, `;
    } else if (typeof v === "object") {
      str += `${k}: ${formatArg(v)}, `;
    } else {
      str += `${k}: ${v.toString()}, `;
    }
  }
  str =
    "{ " +
    str
      .replace(/\s/g, "")
      .split(",")
      .filter((str) => str !== "")
      .join(", ") +
    " }";
  return str;
}
function isTransactionDescription(description) {
  return "functionFragment" in description;
}
function isLogDescription(description) {
  return "eventFragment" in description;
}
function isErrorDescription(description) {
  return "errorFragment" in description;
}
class VaultParser extends context_1.ContractParser {
  constructor(ctx, addressParser) {
    super(typechain_1.Vault__factory.createInterface(), addressParser);
    this.ctx = ctx;
  }
  async parseBaseArrayParam(description, param, value) {
    if (description.name === "launch" && param.name === "addArgs") {
      return formatArg(sdks_perp_1.utils.decodeAddParam([value[0], value[1]]));
    } else if (description.name === "add" && param.name === "args") {
      return formatArg(sdks_perp_1.utils.decodeAddParam([value[0], value[1]]));
    } else if (description.name === "remove" && param.name === "args") {
      return formatArg(
        sdks_perp_1.utils.decodeRemoveParam([value[0], value[1]])
      );
    } else if (description.name === "trade" && param.name === "args") {
      return formatArg(
        sdks_perp_1.utils.decodeTradeParam([value[0], value[1]])
      );
    } else if (description.name === "place" && param.name === "args") {
      return formatArg(
        sdks_perp_1.utils.decodePlaceParam([value[0], value[1]])
      );
    } else if (description.name === "batchPlace" && param.name === "args") {
      return formatArg(
        sdks_perp_1.utils.decodeBatchPlaceParam([value[0], value[1], value[2]])
      );
    } else if (
      description.name === "batchPlace" &&
      param.name === "encodedTicks"
    ) {
      return formatArg(
        (0, utils_2.decodeBatchCancelTicks)([value[0], value[1], value[2]])
      );
    }
    return await super.parseBaseArrayParam(description, param, value);
  }
  async parseBaseParam(description, param, data) {
    if (isTransactionDescription(description)) {
      return this.parseFunctionBaseParam(description, param, data);
    } else if (isLogDescription(description)) {
      return this.parseEventBaseParam(description, param, data);
    } else if (isErrorDescription(description)) {
      return this.parseErrorBaseParam(description, param, data);
    } else {
      return this.parseDefaultBaseParam(description, param, data);
    }
  }
  async parseFunctionBaseParam(description, param, data) {
    switch (param.name) {
      case "arg": {
        switch (description.functionFragment.name) {
          case "fill":
            return formatArg(sdks_perp_1.utils.decodeFillParam(data));
          default:
            return data.toString();
        }
      }
      default:
        return await this.parseDefaultBaseParam(description, param, data);
    }
  }
  async parseEventBaseParam(description, param, data) {
    switch (param.name) {
      default:
        return await this.parseDefaultBaseParam(description, param, data);
    }
  }
  async parseErrorBaseParam(description, param, data) {
    switch (param.name) {
      default:
        return await this.parseDefaultBaseParam(description, param, data);
    }
  }
  async parseDefaultBaseParam(description, param, data) {
    switch (param.name) {
      case "expiry":
        return sdks_perp_1.utils.formatExpiry(data);
      case "amount":
      case "minAmount": {
        const quote = description.args["quote"] || description.args["token"];
        if (!quote) return (0, utils_1.formatEther)(data);
        const tokenInfo = await this.ctx.getTokenInfo(quote);
        return (0, context_1.formatUnits)(data, tokenInfo.decimals);
      }
      case "balance":
      case "tip":
      case "fee":
      case "entryNotional":
      case "deltaQuote":
      case "protocolFee":
      case "involvedFund":
      case "insuranceFund":
      case "funding":
      case "entryFeeIndex":
      case "size":
      case "totalLong":
      case "totalShort":
      case "deltaBase":
      case "openInterests":
      case "totalTaken":
      case "taken":
      case "mark":
      case "limitPrice":
      case "settlement":
      case "entrySocialLossIndex":
      case "entryFundingIndex":
      case "longSocialLossIndex":
      case "shortSocialLossIndex":
      case "longFundingIndex":
      case "shortFundingIndex":
      case "liquidity":
      case "requestedSize":
      case "totalSize":
      case "requested":
      case "tragetLeverage":
      case "defaultLeverage":
      case "leverage":
      case "amountDelta":
        return (0, utils_1.formatEther)(data);
      case "validityRange":
      case "adjustBand":
        return (0, context_1.formatUnits)(data, 4);
      case "tick":
      case "limitTick":
      case "tickUpper":
      case "tickLower":
      case "lowerTick":
      case "upperTick":
      case "minTickLower":
      case "maxTickUpper":
        return (0, sdks_perp_1.formatTick)(Number(data));
      case "deadline":
        return (0, sdks_perp_1.formatTimestamp)(data);
      default:
        return data.toString();
    }
  }
}
exports.VaultParser = VaultParser;
