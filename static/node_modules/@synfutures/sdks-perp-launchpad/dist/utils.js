"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodeBatchCancelTicks = encodeBatchCancelTicks;
exports.decodeBatchCancelTicks = decodeBatchCancelTicks;
exports.getUserDepositInfo = getUserDepositInfo;
exports.generateMessageForMulticallHandler = generateMessageForMulticallHandler;
const utils_1 = require("ethers/lib/utils");
const ethers_1 = require("ethers");
const context_1 = require("@derivation-tech/context");
const contracts_1 = require("@derivation-tech/contracts");
const sdks_perp_1 = require("@synfutures/sdks-perp");
const typechain_1 = require("./typechain");
function encodeBatchCancelTicks(ticks) {
  const ENCODE_TICK_AMOUNT = 3;
  const MAX_TICK_IN_PAGE = 10;
  const EMPTY_TICK = ethers_1.BigNumber.from(1).shl(23).sub(1);
  if (ticks.length > ENCODE_TICK_AMOUNT * MAX_TICK_IN_PAGE)
    throw new Error("order full");
  const uTicks = ticks.map((tick) => (0, sdks_perp_1.asUint24)(tick));
  const res = ["", "", ""];
  for (let i = 0; i < ENCODE_TICK_AMOUNT; i++) {
    let encoded = ethers_1.BigNumber.from(0);
    for (let j = 0; j < MAX_TICK_IN_PAGE; j++) {
      encoded = encoded.shl(24);
      encoded =
        i * MAX_TICK_IN_PAGE + j > uTicks.length - 1
          ? encoded.add(EMPTY_TICK)
          : encoded.add(uTicks[i * MAX_TICK_IN_PAGE + j]);
    }
    res[i] = (0, utils_1.hexZeroPad)(encoded.toHexString(), 32);
  }
  return res;
}
function decodeBatchCancelTicks(encodedTicks) {
  const ENCODE_TICK_AMOUNT = 3;
  const MAX_TICK_IN_PAGE = 10;
  const EMPTY_TICK = ethers_1.BigNumber.from(1).shl(23).sub(1).toNumber();
  const ticks = new Array();
  for (let i = 0; i < ENCODE_TICK_AMOUNT; i++) {
    if (encodedTicks[i] === undefined) continue;
    let encoded = encodedTicks[i].slice(6);
    for (let j = 0; j < MAX_TICK_IN_PAGE; j++) {
      const tick = (0, sdks_perp_1.asInt24)(
        ethers_1.BigNumber.from("0x" + encoded.slice(0, 6)).toNumber()
      );
      if (tick === EMPTY_TICK) return ticks;
      ticks.push(tick);
      encoded = encoded.slice(6);
    }
  }
  return ticks;
}
async function getUserDepositInfo(user, vaultAddrs, ctx, overrides) {
  const vaultInterface = typechain_1.Vault__factory.createInterface();
  const calls = [];
  calls.push(
    ...vaultAddrs.map((vaultAddr) => {
      return {
        target: vaultAddr,
        callData: vaultInterface.encodeFunctionData("getPortfolioValue"),
      };
    })
  );
  calls.push(
    ...vaultAddrs.map((vaultAddr) => {
      return {
        target: vaultAddr,
        callData: vaultInterface.encodeFunctionData("getStake", [user]),
      };
    })
  );
  calls.push(
    ...vaultAddrs.map((vaultAddr) => {
      return {
        target: vaultAddr,
        callData: vaultInterface.encodeFunctionData("totalShare"),
      };
    })
  );
  overrides = overrides ?? { blockTag: await ctx.provider.getBlockNumber() };
  const rawRet = (
    await ctx.getMulticall3().callStatic.aggregate(calls, overrides)
  ).returnData;
  const portfolioValues = rawRet.slice(0, vaultAddrs.length).map((ret) => {
    return vaultInterface.decodeFunctionResult("getPortfolioValue", ret)[0];
  });
  const stakes = rawRet
    .slice(vaultAddrs.length, vaultAddrs.length * 2)
    .map((ret) => {
      return vaultInterface.decodeFunctionResult("getStake", ret)[0];
    });
  const totalShares = rawRet.slice(vaultAddrs.length * 2).map((ret) => {
    return vaultInterface.decodeFunctionResult("totalShare", ret)[0];
  });
  return {
    depositInfos: stakes.map((stake, i) => {
      return {
        user,
        vault: vaultAddrs[i],
        share: stake.share,
        entryValue: stake.entryValue,
        holdingValue: totalShares[i].eq(context_1.ZERO)
          ? context_1.ZERO
          : portfolioValues[i].mul(stakes[i].share).div(totalShares[i]),
      };
    }),
    blockHeight: overrides.blockTag,
  };
}
function generateMessageForMulticallHandler(
  userAddress,
  vaultAddress,
  quoteAddress,
  depositAmount
) {
  const abiCoder = new utils_1.AbiCoder();
  const vaultInterface = typechain_1.Vault__factory.createInterface();
  const quoteInterface = contracts_1.ERC20__factory.createInterface();
  const approveCalldata = quoteInterface.encodeFunctionData("approve", [
    vaultAddress,
    depositAmount,
  ]);
  const depositCalldata = vaultInterface.encodeFunctionData("depositFor", [
    userAddress,
    depositAmount,
  ]);
  return abiCoder.encode(
    [
      "tuple(" +
        "tuple(" +
        "address target," +
        "bytes callData," +
        "uint256 value" +
        ")[]," +
        "address fallbackRecipient" +
        ")",
    ],
    [
      [
        [
          [quoteAddress, approveCalldata, 0],
          [vaultAddress, depositCalldata, 0],
        ],
        userAddress,
      ],
    ]
  );
}
