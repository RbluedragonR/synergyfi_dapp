"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Depth = void 0;
const ethers_1 = require("ethers");
const context_1 = require("@derivation-tech/context");
const sdks_perp_1 = require("@synfutures/sdks-perp");
const utils_1 = require("../../utils");
class Depth {
  constructor(dataSource) {
    this.dataSource = dataSource;
  }
  get ctx() {
    return this.dataSource.ctx;
  }
  _page(currTick, tick, pageAdjustmentDelta, size, right) {
    const adjustedCurrTick = currTick - pageAdjustmentDelta;
    let tmp;
    if (right) {
      tmp = tick - adjustedCurrTick;
    } else {
      tmp = adjustedCurrTick - tick;
    }
    if (tmp <= 0) return 0;
    const page = right
      ? Math.ceil(tmp / size) - 1
      : Math.ceil(tmp / size) - (pageAdjustmentDelta == 0 ? 1 : 0);
    return page;
  }
  buildDepthChartData(
    currPX96,
    currLiquidity,
    currTick,
    tickDelta,
    tick2Pearl,
    size,
    length,
    pageAdjustmentDelta,
    right
  ) {
    const ret = [];
    const page2BaseSize = new Map();
    const lastPageTick = new Map();
    for (
      let tick = currTick;
      right ? tick < currTick + tickDelta : tick > currTick - tickDelta;
      right ? (tick += 1) : (tick -= 1)
    ) {
      const page = this._page(currTick, tick, pageAdjustmentDelta, size, right);
      if (page >= length) break;
      lastPageTick.set(page, tick);
      const pearl = tick2Pearl.get(tick);
      let currBaseSize = page2BaseSize.get(page) ?? context_1.ZERO;
      if (pearl) {
        if (
          (right && pearl.left.isNegative()) ||
          (!right && pearl.left.gt(0))
        ) {
          currBaseSize = pearl.left.abs().add(currBaseSize);
        }
        const targetPX96 = sdks_perp_1.TickMath.getSqrtRatioAtTick(tick);
        currBaseSize = currBaseSize.add(
          sdks_perp_1.SqrtPriceMath.getDeltaBase(
            currPX96,
            targetPX96,
            currLiquidity,
            false
          )
        );
        currPX96 = targetPX96;
        if (!pearl.liquidityNet.isZero()) {
          currLiquidity = currLiquidity.add(
            pearl.liquidityNet.mul(right ? 1 : -1)
          );
        }
        page2BaseSize.set(page, currBaseSize);
      } else if (tick % size === 0) {
        const targetPX96 = sdks_perp_1.TickMath.getSqrtRatioAtTick(tick);
        currBaseSize = currBaseSize.add(
          sdks_perp_1.SqrtPriceMath.getDeltaBase(
            currPX96,
            targetPX96,
            currLiquidity,
            !right
          ).abs()
        );
        currPX96 = targetPX96;
        page2BaseSize.set(page, currBaseSize);
      }
    }
    for (const [page, baseSize] of page2BaseSize) {
      const tick = lastPageTick.get(page);
      const price = (0, utils_1.fromWad)(
        sdks_perp_1.TickMath.getWadAtTick(tick)
      );
      const base = (0, utils_1.fromWad)(baseSize);
      ret.push({ tick, price, base });
    }
    return ret;
  }
  getDepthRangeDataByLiquidityDetails(
    liquidityDetails,
    size,
    stepRatio,
    isInverse = false,
    lowerPrice,
    upperPrice
  ) {
    let pageAdjustmentDelta = 0;
    if (liquidityDetails.amm.tick % size !== 0) {
      pageAdjustmentDelta =
        liquidityDetails.amm.tick > 0
          ? liquidityDetails.amm.tick % size
          : size - (-liquidityDetails.amm.tick % size);
    }
    const maxTick = liquidityDetails.tids.reduce((prev, curr) =>
      prev > curr ? prev : curr
    );
    const minTick = liquidityDetails.tids.reduce((prev, curr) =>
      prev < curr ? prev : curr
    );
    const bnMin = (left, right) => (left.gt(right) ? right : left);
    let minPriceDelta;
    if (!isInverse) {
      minPriceDelta = bnMin(
        sdks_perp_1.TickMath.getWadAtTick(maxTick).sub(
          sdks_perp_1.TickMath.getWadAtTick(liquidityDetails.amm.tick)
        ),
        sdks_perp_1.TickMath.getWadAtTick(liquidityDetails.amm.tick).sub(
          sdks_perp_1.TickMath.getWadAtTick(minTick)
        )
      );
    } else {
      minPriceDelta = bnMin(
        sdks_perp_1.TickMath.getWadAtTick(-liquidityDetails.amm.tick).sub(
          sdks_perp_1.TickMath.getWadAtTick(-maxTick)
        ),
        sdks_perp_1.TickMath.getWadAtTick(-minTick).sub(
          sdks_perp_1.TickMath.getWadAtTick(-liquidityDetails.amm.tick)
        )
      );
      lowerPrice = (0, sdks_perp_1.wdiv)(
        context_1.WAD,
        sdks_perp_1.TickMath.getWadAtTick(-liquidityDetails.amm.tick).add(
          minPriceDelta
        )
      );
      upperPrice = (0, sdks_perp_1.wdiv)(
        context_1.WAD,
        sdks_perp_1.TickMath.getWadAtTick(-liquidityDetails.amm.tick).sub(
          minPriceDelta
        )
      );
    }
    const rightTickDelta = upperPrice
      ? sdks_perp_1.TickMath.getTickAtPWad(upperPrice) -
        liquidityDetails.amm.tick
      : sdks_perp_1.TickMath.getTickAtPWad(
          sdks_perp_1.TickMath.getWadAtTick(liquidityDetails.amm.tick).add(
            minPriceDelta
          )
        ) - liquidityDetails.amm.tick;
    const rightLength = Number(
      sdks_perp_1.TickMath.getWadAtTick(rightTickDelta)
        .div(ethers_1.BigNumber.from(10).pow(14))
        .div(stepRatio)
        .toString()
    );
    const right = this.buildDepthChartData(
      liquidityDetails.amm.sqrtPX96,
      liquidityDetails.amm.liquidity,
      liquidityDetails.amm.tick,
      rightTickDelta,
      liquidityDetails.tick2Pearl,
      size,
      rightLength,
      pageAdjustmentDelta,
      true
    );
    const leftTickDelta = lowerPrice
      ? liquidityDetails.amm.tick -
        sdks_perp_1.TickMath.getTickAtPWad(lowerPrice)
      : liquidityDetails.amm.tick -
        sdks_perp_1.TickMath.getTickAtPWad(
          sdks_perp_1.TickMath.getWadAtTick(liquidityDetails.amm.tick).sub(
            minPriceDelta
          )
        );
    const leftLength = Number(
      sdks_perp_1.TickMath.getWadAtTick(leftTickDelta)
        .div(ethers_1.BigNumber.from(10).pow(14))
        .div(stepRatio)
        .toString()
    );
    const left = this.buildDepthChartData(
      liquidityDetails.amm.sqrtPX96,
      liquidityDetails.amm.liquidity,
      liquidityDetails.amm.tick,
      leftTickDelta,
      liquidityDetails.tick2Pearl,
      size,
      leftLength,
      pageAdjustmentDelta,
      false
    );
    return { left, right };
  }
  async getDepthRangeData(
    instrumentAddr,
    expiry,
    stepRatio,
    isInverse = false,
    lowerPrice,
    upperPrice,
    overrides
  ) {
    const tickDelta = sdks_perp_1.TICK_DELTA_MAX * 2;
    const size = sdks_perp_1.utils.alphaWadToTickDelta(
      (0, sdks_perp_1.r2w)(Math.round(stepRatio + sdks_perp_1.RATIO_BASE))
    );
    const liquidityDetails = await this.ctx.perp._observer.getLiquidityDetails(
      instrumentAddr,
      expiry,
      tickDelta,
      overrides ?? {}
    );
    return this.getDepthRangeDataByLiquidityDetails(
      liquidityDetails,
      size,
      stepRatio,
      isInverse,
      lowerPrice,
      upperPrice
    );
  }
  getDepthDataByLiquidityDetails(
    liquidityDetails,
    size,
    tickDelta,
    length = 10
  ) {
    let pageAdjustmentDelta = 0;
    if (liquidityDetails.amm.tick % size !== 0) {
      pageAdjustmentDelta =
        liquidityDetails.amm.tick > 0
          ? liquidityDetails.amm.tick % size
          : size - (-liquidityDetails.amm.tick % size);
    }
    const right = this.buildDepthChartData(
      liquidityDetails.amm.sqrtPX96,
      liquidityDetails.amm.liquidity,
      liquidityDetails.amm.tick,
      tickDelta,
      liquidityDetails.tick2Pearl,
      size,
      length,
      pageAdjustmentDelta,
      true
    );
    const left = this.buildDepthChartData(
      liquidityDetails.amm.sqrtPX96,
      liquidityDetails.amm.liquidity,
      liquidityDetails.amm.tick,
      tickDelta,
      liquidityDetails.tick2Pearl,
      size,
      length,
      pageAdjustmentDelta,
      false
    );
    return { left, right };
  }
  async getDepthData(
    instrumentAddr,
    expiry,
    stepRatio,
    length = 10,
    overrides
  ) {
    let tickDelta = sdks_perp_1.utils.alphaWadToTickDelta(
      (0, sdks_perp_1.r2w)(
        Math.round(1.1 * stepRatio * length + sdks_perp_1.RATIO_BASE)
      )
    );
    tickDelta = Math.ceil(tickDelta / length) * length;
    const size = sdks_perp_1.utils.alphaWadToTickDelta(
      (0, sdks_perp_1.r2w)(stepRatio + sdks_perp_1.RATIO_BASE)
    );
    const liquidityDetails = await this.ctx.perp._observer.getLiquidityDetails(
      instrumentAddr,
      expiry,
      tickDelta,
      overrides ?? {}
    );
    return this.getDepthDataByLiquidityDetails(
      liquidityDetails,
      size,
      tickDelta,
      length
    );
  }
}
exports.Depth = Depth;
