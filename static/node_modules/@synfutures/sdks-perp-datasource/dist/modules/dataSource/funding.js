"use strict";
var __importDefault =
  (this && this.__importDefault) ||
  function (mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
Object.defineProperty(exports, "__esModule", { value: true });
exports.Funding = void 0;
const ethers_1 = require("ethers");
const async_retry_1 = __importDefault(require("async-retry"));
const node_fetch_1 = __importDefault(require("node-fetch"));
const context_1 = require("@derivation-tech/context");
const sdks_perp_1 = require("@synfutures/sdks-perp");
const utils_1 = require("../../utils");
const constants_1 = require("../../constants");
const errors_1 = require("../../errors");
class Funding {
  constructor(dataSource) {
    this.dataSource = dataSource;
  }
  get ctx() {
    return this.dataSource.ctx;
  }
  async getBlockNumberBefore(timestamp) {
    const blockNumber = await this.ctx.provider.getBlockNumber();
    const key = this.ctx.chainName.toUpperCase();
    return (
      blockNumber -
      Math.ceil(
        ((0, context_1.now)() - timestamp) / constants_1.blockInterval[key]
      )
    );
  }
  async getLastHourFundingRate(amm, ts) {
    const timestamp = ts ?? (0, context_1.now)();
    const latestFundingIndex = sdks_perp_1.utils.lowLevel.updateFundingIndex(
      amm,
      amm.markPrice,
      timestamp
    );
    const timestmapBefore = timestamp - 3600;
    const instrumentBefore = await this.ctx.perp._observer.getInstrument(
      {
        instrument: amm.instrumentAddr,
        expiries: [amm.expiry],
      },
      {
        blockTag: await this.getBlockNumberBefore(timestmapBefore),
      }
    );
    const ammBefore = instrumentBefore?.amms.get(amm.expiry);
    if (!ammBefore) {
      return {
        timestamp,
        longFundingRate: context_1.ZERO,
        shortFundingRate: context_1.ZERO,
      };
    }
    const beforeFundingIndex = sdks_perp_1.utils.lowLevel.updateFundingIndex(
      ammBefore,
      ammBefore.markPrice,
      timestmapBefore
    );
    const longFundingRate = (0, sdks_perp_1.wdiv)(
      latestFundingIndex.longFundingIndex.sub(
        beforeFundingIndex.longFundingIndex
      ),
      amm.markPrice
    );
    const shortFundingRate = (0, sdks_perp_1.wdiv)(
      latestFundingIndex.shortFundingIndex.sub(
        beforeFundingIndex.shortFundingIndex
      ),
      amm.markPrice
    );
    return {
      timestamp,
      longFundingRate,
      shortFundingRate,
    };
  }
  async getHourlyFundingDataList(
    instrumentAddr,
    expiry,
    timestamp = (0, context_1.now)(),
    numDays = 15
  ) {
    const fn = (str) => `"${str}"`;
    const hourId = (0, utils_1.hourIdFromTimestamp)(timestamp);
    const nDaysAgoHourId = hourId - numDays * 24 * context_1.SECS_PER_HOUR;
    const PAYLOAD_SIZE = 20;
    const result = [];
    const temp = [];
    for (
      let i = hourId;
      i >= nDaysAgoHourId;
      i -= PAYLOAD_SIZE * context_1.SECS_PER_HOUR
    ) {
      let graphQL = `{`;
      for (
        let j = 0;
        j < PAYLOAD_SIZE && i - j * context_1.SECS_PER_HOUR >= nDaysAgoHourId;
        j++
      ) {
        const currentHourId = i - j * context_1.SECS_PER_HOUR;
        const ammId = `${fn(
          (0, utils_1.concatId)(
            (0, utils_1.concatId)(instrumentAddr, expiry),
            currentHourId
          ).toLowerCase()
        )}`;
        graphQL += `
                    a${currentHourId}: hourlyAmmData(id: ${ammId}) {
                        id
                        timestamp
                        firstFundingIndex
                        lastFundingIndex
                        firstMarkPrice
                        lastMarkPrice
                    }`;
      }
      graphQL += `}`;
      const graphql = JSON.stringify({
        query: `${graphQL}`,
      });
      const opts = {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: graphql,
        redirect: "follow",
        timeout: 100000,
      };
      const resp = await (0, async_retry_1.default)(async () => {
        const response = await (0, node_fetch_1.default)(
          this.dataSource.endpoint,
          opts
        );
        const json = await response.json();
        if (!json.data || json.errors) {
          throw new errors_1.TheGraphError(
            "Subgraph query error" + JSON.stringify(json.errors)
          );
        }
        return json.data;
      }, this.dataSource.retryOption);
      for (const key in resp) {
        if (Object.prototype.hasOwnProperty.call(resp, key)) {
          const data = resp[key];
          if (data !== null) {
            temp.push(data);
          }
        }
      }
    }
    for (let i = 0; i < temp.length; i++) {
      const hourlyData = temp[i];
      let lastMarkPrice = ethers_1.BigNumber.from(hourlyData.lastMarkPrice);
      let offset = 1;
      while (
        lastMarkPrice.eq(0) &&
        (i + offset < temp.length || i - offset >= 0)
      ) {
        if (i + offset < temp.length) {
          lastMarkPrice = ethers_1.BigNumber.from(
            temp[i + offset].lastMarkPrice
          );
        }
        if (lastMarkPrice.eq(0) && i - offset >= 0) {
          lastMarkPrice = ethers_1.BigNumber.from(
            temp[i - offset].lastMarkPrice
          );
        }
        offset++;
      }
      result.push({
        timestamp: Number(hourlyData.timestamp),
        lastFundingIndex: ethers_1.BigNumber.from(hourlyData.lastFundingIndex),
        lastMarkPrice,
      });
    }
    return result;
  }
  async getFundingRateData(amm, interval, ts) {
    const intervalSeconds = (0, utils_1.getFundingChartIntervalSeconds)(
      interval
    );
    const endTs = (0, utils_1.roundFundingChartTimestamp)(
      interval,
      ts ?? (0, context_1.now)()
    );
    const startTs =
      endTs -
      intervalSeconds * constants_1.fundingChartDataLength.get(interval);
    let fundingSnapshotAtTs = [];
    let timestamp = endTs;
    const hourlyDataList = await this.getHourlyFundingDataList(
      amm.instrumentAddr,
      amm.expiry,
      ts
    );
    const markPriceNow = amm.markPrice;
    for (const hourlyData of hourlyDataList) {
      if (hourlyData.lastMarkPrice.eq(0)) {
        hourlyData.lastMarkPrice = markPriceNow;
      }
    }
    const lastHourlyData = hourlyDataList[0];
    while (hourlyDataList.length > 0 && hourlyDataList[0].timestamp > startTs) {
      while (
        hourlyDataList.length > 0 &&
        hourlyDataList[0].timestamp > timestamp
      ) {
        hourlyDataList.shift();
      }
      if (hourlyDataList.length === 0) break;
      const fundingIndex = hourlyDataList[0].lastFundingIndex;
      const longFundingIndex = (0, sdks_perp_1.asInt128)(
        ethers_1.BigNumber.from(fundingIndex).mask(128)
      );
      const shortFundingIndex = (0, sdks_perp_1.asInt128)(
        ethers_1.BigNumber.from(fundingIndex).shr(128).mask(128)
      );
      fundingSnapshotAtTs.push({
        timestamp,
        longFundingIndex,
        shortFundingIndex,
        markPrice: hourlyDataList[0].lastMarkPrice,
      });
      timestamp -= intervalSeconds;
    }
    fundingSnapshotAtTs = fundingSnapshotAtTs.reverse();
    const fundingRates = [];
    for (let i = 1; i < fundingSnapshotAtTs.length; i++) {
      const longFundingRate = (0, sdks_perp_1.wdiv)(
        fundingSnapshotAtTs[i].longFundingIndex.sub(
          fundingSnapshotAtTs[i - 1].longFundingIndex
        ),
        fundingSnapshotAtTs[i].markPrice
      );
      const shortFundingRate = (0, sdks_perp_1.wdiv)(
        fundingSnapshotAtTs[i].shortFundingIndex.sub(
          fundingSnapshotAtTs[i - 1].shortFundingIndex
        ),
        fundingSnapshotAtTs[i].markPrice
      );
      fundingRates.push({
        timestamp: fundingSnapshotAtTs[i].timestamp,
        longFundingRate,
        shortFundingRate,
      });
    }
    const instrumentBefore = await this.ctx.perp._observer.getInstrument(
      {
        instrument: amm.instrumentAddr,
        expiries: [amm.expiry],
      },
      {
        blockTag: await this.getBlockNumberBefore(lastHourlyData.timestamp),
      }
    );
    const ammBefore = instrumentBefore?.amms.get(amm.expiry);
    if (!ammBefore) {
      throw new errors_1.TheGraphError("Missing amm information");
    }
    const latestFundingIndex = sdks_perp_1.utils.lowLevel.updateFundingIndex(
      ammBefore,
      ammBefore.markPrice,
      ts ?? (0, context_1.now)()
    );
    fundingRates.push({
      timestamp: ts ?? (0, context_1.now)(),
      longFundingRate: (0, sdks_perp_1.wdiv)(
        latestFundingIndex.longFundingIndex.sub(
          fundingSnapshotAtTs[fundingSnapshotAtTs.length - 1].longFundingIndex
        ),
        markPriceNow
      ),
      shortFundingRate: (0, sdks_perp_1.wdiv)(
        latestFundingIndex.shortFundingIndex.sub(
          fundingSnapshotAtTs[fundingSnapshotAtTs.length - 1].shortFundingIndex
        ),
        markPriceNow
      ),
    });
    return fundingRates;
  }
}
exports.Funding = Funding;
