"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Liquidity = void 0;
const ethers_1 = require("ethers");
const context_1 = require("@derivation-tech/context");
const graph_1 = require("@derivation-tech/context/dist/utils/graph");
const sdks_perp_1 = require("@synfutures/sdks-perp");
const utils_1 = require("../../utils");
class Liquidity {
  constructor(dataSource) {
    this.dataSource = dataSource;
  }
  async getLiquidityData(
    instrumentAddr,
    expiry,
    spacing = sdks_perp_1.RANGE_SPACING,
    blockNumber
  ) {
    const fn = (str) => `"${str}"`;
    const ammCondition = `amm: ${fn(
      (0, utils_1.concatId)(instrumentAddr, expiry).toLowerCase()
    )},`;
    const blockCondition = blockNumber
      ? `block: {number: ${blockNumber}},`
      : "";
    const graphQL = `
          query($skip: Int, $first: Int, $lastID: String){
            ranges(${blockCondition} first: $first,where: {${ammCondition} status: "OPEN", id_gt: $lastID}){
              id
              liquidity
              tickLower
              tickUpper
              status
            }
          }`;
    const ranges = await this.dataSource.queryAll(
      graphQL,
      graph_1.GRAPH_PAGE_SIZE,
      true
    );
    if (!ranges || ranges.length === 0) {
      return [];
    }
    let tickLowest = sdks_perp_1.MAX_TICK;
    let tickUppest = sdks_perp_1.MIN_TICK;
    const liquidityDeltaMap = {};
    for (const range of ranges) {
      if (Number(range.tickLower) < tickLowest) {
        tickLowest = Number(range.tickLower);
      }
      if (Number(range.tickUpper) > tickUppest) {
        tickUppest = Number(range.tickUpper);
      }
      const liq = ethers_1.BigNumber.from(range.liquidity);
      const liquidityDeltaLower =
        liquidityDeltaMap[range.tickLower] ?? context_1.ZERO;
      liquidityDeltaMap[range.tickLower] = liquidityDeltaLower.add(liq);
      const liquidityDeltaUpper =
        liquidityDeltaMap[range.tickUpper + 1] ?? context_1.ZERO;
      liquidityDeltaMap[range.tickUpper + 1] = liquidityDeltaUpper.sub(liq);
    }
    const result = [];
    let liquidity = context_1.ZERO;
    for (let i = tickLowest; i <= tickUppest; i++) {
      let keyTick = i % spacing === 0;
      if (liquidityDeltaMap[i] !== undefined) {
        liquidity = liquidity.add(liquidityDeltaMap[i]);
        keyTick = true;
      }
      if (keyTick) {
        result.push({
          liquidity: liquidity,
          tick: i,
          price: (0, utils_1.fromWad)(
            (0, sdks_perp_1.sqrtX96ToWad)(
              sdks_perp_1.TickMath.getSqrtRatioAtTick(i)
            )
          ),
        });
      }
    }
    return result;
  }
}
exports.Liquidity = Liquidity;
