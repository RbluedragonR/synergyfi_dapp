"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Statistics = void 0;
const ethers_1 = require("ethers");
const context_1 = require("@derivation-tech/context");
const graph_1 = require("@derivation-tech/context/dist/utils/graph");
const sdks_perp_1 = require("@synfutures/sdks-perp");
const utils_1 = require("../../utils");
class Statistics {
  constructor(dataSource) {
    this.dataSource = dataSource;
  }
  async getPairsData(
    status = [sdks_perp_1.Status.TRADING, sdks_perp_1.Status.SETTLING],
    timestamp = (0, context_1.now)(),
    blockNumber
  ) {
    const statusCondition =
      "status_in: [" +
      status.map((s) => sdks_perp_1.Status[s]).join(",") +
      "],";
    const blockNumberCondition = blockNumber
      ? `block: {number: ${blockNumber}},`
      : "";
    const dayId = (0, utils_1.dayIdFromTimestamp)(timestamp);
    const hourId = (0, utils_1.hourIdFromTimestamp)(timestamp);
    const _7d = dayId - 7 * context_1.SECS_PER_DAY;
    const _24h = hourId - 24 * context_1.SECS_PER_HOUR;
    const nDaysAgoHourId = hourId - 24 * 3 * context_1.SECS_PER_HOUR;
    const graphQL = `
            query($skip: Int, $first: Int, $lastID: String){
              amms(${blockNumberCondition} first: $first, where: {${statusCondition} id_gt: $lastID}){
                id
                symbol
                expiry
                status
                balance
                sqrtPX96
                instrument {
                  id
                }
                data {
                  id
                  totalVolume
                }
                dailyDataList(${blockNumberCondition} where: {timestamp_gt: ${_7d}, timestamp_lte: ${dayId}}, orderBy: timestamp, orderDirection: desc) {
                  id
                  timestamp
                  volume
                }
                hourlyDataList(${blockNumberCondition} where: {timestamp_gt: ${nDaysAgoHourId}, timestamp_lte: ${hourId}}, orderBy: timestamp, orderDirection: desc) {
                  id
                  timestamp
                  poolFee
                  volume
                  open
                  close
                  high
                  low
                }
              }
            }`;
    const result = [];
    const resp = await this.dataSource.query(
      graphQL,
      0,
      graph_1.GRAPH_PAGE_SIZE
    );
    for (const amm of resp.amms) {
      let _7dVolume = context_1.ZERO;
      let _24hVolume = context_1.ZERO;
      let _24hPoolFee = context_1.ZERO;
      let _24hHigh = context_1.ZERO;
      let _24hLow = context_1.ZERO;
      let _24hClose = context_1.ZERO;
      for (const data of amm.dailyDataList) {
        _7dVolume = _7dVolume.add(ethers_1.BigNumber.from(data.volume));
      }
      for (const data of amm.hourlyDataList) {
        if (data.timestamp < _24h) {
          break;
        }
        _24hVolume = _24hVolume.add(ethers_1.BigNumber.from(data.volume));
        _24hPoolFee = _24hPoolFee.add(ethers_1.BigNumber.from(data.poolFee));
      }
      for (const data of amm.hourlyDataList) {
        if (ethers_1.BigNumber.from(data.close).eq(0)) {
          continue;
        }
        _24hClose = ethers_1.BigNumber.from(data.close);
        if (_24hHigh.lt(ethers_1.BigNumber.from(data.high))) {
          _24hHigh = ethers_1.BigNumber.from(data.high);
        }
        if (
          _24hLow.eq(context_1.ZERO) ||
          _24hLow.gt(ethers_1.BigNumber.from(data.low))
        ) {
          _24hLow = ethers_1.BigNumber.from(data.low);
        }
        if (data.timestamp <= _24h) {
          break;
        }
      }
      const balance = ethers_1.BigNumber.from(amm.balance);
      const data = {
        id: amm.id,
        expiry: Number(amm.expiry),
        instrumentAddr: amm.instrument.id,
        APY24h: balance.eq(0)
          ? context_1.ZERO
          : (0, sdks_perp_1.wdiv)(_24hPoolFee.mul(365), balance),
        poolFee24h: _24hPoolFee,
        volume24h: _24hVolume,
        volume24hUTC0:
          amm.dailyDataList.length > 0
            ? ethers_1.BigNumber.from(amm.dailyDataList[0].volume)
            : context_1.ZERO,
        volume7d: _7dVolume,
        high24h: _24hHigh,
        low24h: _24hLow,
        priceChange24h: _24hClose.eq(context_1.ZERO)
          ? context_1.ZERO
          : (0, sdks_perp_1.wdiv)(
              (0, sdks_perp_1.sqrtX96ToWad)(amm.sqrtPX96),
              _24hClose
            ).sub(context_1.WAD),
      };
      result.push(data);
    }
    return result;
  }
  async getInstrumentsInfo() {
    const graphQL = `query($skip: Int, $first: Int, $lastID: String){
            instruments(skip: $skip, first: $first){
                id
                symbol
                condition
                ammList {
                  expiry
                }
                base {
                  id
                  name
                  symbol
                  decimals
                }
                quote {
                  id
                  name
                  symbol
                  decimals
                }
                dexV2Market {
                  type               
                }
                cexMarket {
                  type                
                }    
            }
        }`;
    const resp = await this.dataSource.queryAll(graphQL);
    return await Promise.all(
      resp.map(async (i) => {
        const marketType = i.dexV2Market?.type ?? i.cexMarket?.type;
        return {
          address: i.id,
          expiries: i.ammList.map(({ expiry }) => Number(expiry)),
          symbol: i.symbol,
          isInverse:
            await this.dataSource.ctx.perp.configuration.isInverseByIdentifier({
              marketType,
              baseSymbol: i.base.symbol,
              quoteSymbol: i.quote.symbol,
            }),
          condition:
            i.condition === "NORMAL"
              ? sdks_perp_1.InstrumentCondition.NORMAL
              : i.condition === "FROZEN"
              ? sdks_perp_1.InstrumentCondition.FROZEN
              : sdks_perp_1.InstrumentCondition.RESOLVED,
          base: {
            address: i.base.id,
            name: i.base.name,
            symbol: i.base.symbol,
            decimals: Number(i.base.decimals),
          },
          quote: {
            address: i.quote.id,
            name: i.quote.name,
            symbol: i.quote.symbol,
            decimals: Number(i.quote.decimals),
          },
          marketType,
        };
      })
    );
  }
}
exports.Statistics = Statistics;
