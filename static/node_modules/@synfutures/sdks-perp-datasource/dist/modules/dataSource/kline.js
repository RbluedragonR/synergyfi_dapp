"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Kline = void 0;
const ethers_1 = require("ethers");
const graph_1 = require("@derivation-tech/context/dist/utils/graph");
const utils_1 = require("../../utils");
const enum_1 = require("../../enum");
class Kline {
  constructor(dataSource) {
    this.dataSource = dataSource;
  }
  async getKlinesDirectly(instrumentAddr, expiry, interval, startTs, endTs) {
    const ammId = (0, utils_1.concatId)(instrumentAddr, expiry).toLowerCase();
    const condition = `amm: "${ammId}", open_gt: 0, id_gt: $lastID, timestamp_gte: ${startTs}, timestamp_lte: ${endTs}`;
    const intervalStatement = (0, utils_1.getKlineIntervalStatement)(interval);
    const graphQL = `
            query($skip: Int, $first: Int, $lastID: String){
              ${intervalStatement}(first: $first, where: {${condition}}, orderBy: timestamp, orderDirection: asc){
                id
                timestamp
                open
                high
                low
                close
                volume
                baseVolume
              }
            }`;
    const candles = await this.dataSource.queryAll(
      graphQL,
      graph_1.GRAPH_PAGE_SIZE,
      true
    );
    const candleMap = {};
    for (const candle of candles) {
      candleMap[Number(candle.timestamp)] = {
        timestamp: Number(candle.timestamp),
        open: (0, utils_1.fromWad)(candle.open),
        high: (0, utils_1.fromWad)(candle.high),
        close: (0, utils_1.fromWad)(candle.close),
        low: (0, utils_1.fromWad)(candle.low),
        baseVolume: (0, utils_1.fromWad)(candle.baseVolume),
        quoteVolume: (0, utils_1.fromWad)(candle.volume),
      };
    }
    return candleMap;
  }
  async getKlinesFromRawEvents(
    instrumentAddr,
    expiry,
    interval,
    startTs,
    endTs,
    minTradeValue
  ) {
    const ammId = (0, utils_1.concatId)(instrumentAddr, expiry).toLowerCase();
    const condition = `type_in: [LIQUIDATION, MARKET], fee_gt: 0, amm: "${ammId}", timestamp_gte: ${startTs}, timestamp_lte: ${endTs}`;
    const graphQL = `query($skip: Int, $first: Int, $lastID: String){
            virtualTrades(first: $first, where: { ${condition}, id_gt: $lastID }){
                id
                price
                size
                timestamp
                tradeValue
            }
        }`;
    const FILTER_RATIO = 10;
    const minTradeValueAccountedInCandles = minTradeValue.div(FILTER_RATIO);
    const events = (await this.dataSource.queryAll(graphQL, 1000, true)).filter(
      (event) =>
        ethers_1.BigNumber.from(event.tradeValue).gt(
          minTradeValueAccountedInCandles
        )
    );
    const candleMap = {};
    for (const event of events) {
      const ts = (0, utils_1.roundKlineTimestamp)(
        interval,
        Number(event.timestamp)
      );
      const candle = candleMap[ts];
      const px = (0, utils_1.fromWad)(event.price);
      const size = Math.abs((0, utils_1.fromWad)(event.size));
      const volume = px * size;
      if (candle) {
        candle.close = px;
        candle.high = Math.max(candle.high, px);
        candle.low = Math.min(candle.low, px);
        candle.baseVolume += size;
        candle.quoteVolume += volume;
      } else {
        candleMap[ts] = {
          timestamp: ts,
          open: px,
          close: px,
          high: px,
          low: px,
          baseVolume: size,
          quoteVolume: volume,
        };
      }
    }
    return candleMap;
  }
  completeKlines(interval, endTs, data) {
    if (Object.keys(data).length === 0) {
      return [];
    }
    const keys = Object.keys(data);
    keys.sort();
    const result = [];
    const startTs = data[Number(keys[0])].timestamp;
    let prev = data[startTs];
    for (
      let i = startTs;
      i <= endTs;
      i += (0, utils_1.getKlineIntervalSeconds)(interval)
    ) {
      if (data[i] && data[i].open > 0) {
        result.push(data[i]);
        prev = data[i];
      } else {
        const px = prev.close;
        const ohlc = {
          timestamp: i,
          open: px,
          high: px,
          close: px,
          low: px,
          baseVolume: 0,
          quoteVolume: 0,
        };
        result.push(ohlc);
        prev = ohlc;
      }
    }
    return result;
  }
  async getKlineData(
    instrumentAddr,
    expiry,
    interval,
    startTs,
    endTs,
    minTradeValue
  ) {
    const _interval = (0, utils_1.getKlineIntervalSeconds)(interval);
    startTs = Math.floor(startTs / _interval) * _interval;
    endTs = Math.ceil(endTs / _interval) * _interval;
    let candles;
    if (
      interval === enum_1.KlineInterval.DAY ||
      interval === enum_1.KlineInterval.WEEK ||
      interval === enum_1.KlineInterval.HOUR ||
      interval === enum_1.KlineInterval.FOUR_HOUR
    ) {
      candles = await this.getKlinesDirectly(
        instrumentAddr,
        expiry,
        interval,
        startTs,
        endTs
      );
    } else {
      candles = await this.getKlinesFromRawEvents(
        instrumentAddr,
        expiry,
        interval,
        startTs,
        endTs,
        minTradeValue
      );
    }
    return this.completeKlines(interval, endTs, candles);
  }
}
exports.Kline = Kline;
