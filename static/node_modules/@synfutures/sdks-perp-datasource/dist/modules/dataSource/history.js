"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.History = void 0;
const ethers_1 = require("ethers");
const lodash_1 = require("lodash");
const context_1 = require("@derivation-tech/context");
const graph_1 = require("@derivation-tech/context/dist/utils/graph");
const sdks_perp_1 = require("@synfutures/sdks-perp");
const utils_1 = require("../../utils");
const enum_1 = require("../../enum");
class History {
  constructor(dataSource) {
    this.dataSource = dataSource;
  }
  buildQueryEventCondition(param, hasInstrumentField = true) {
    const fn = (str) => `"${str}"`;
    let instrumentCondition = "";
    let pairCondition = "";
    let traderCondition = "";
    let eventCondition = "";
    let referralCondition = "";
    if (param.eventNames && param.eventNames.length > 0) {
      eventCondition = `name_in: [${param.eventNames
        .map((e) => fn(e))
        .join(",")}],`;
    }
    if (param.traders && param.traders.length > 0) {
      traderCondition = `trader_in: [${param.traders
        .map((t) => fn(t.toLowerCase()))
        .join(",")}],`;
    }
    if (param.instrumentAddr && param.expiry && param.expiry >= 0) {
      pairCondition = `amm: ${fn(
        (0, utils_1.concatId)(param.instrumentAddr, param.expiry).toLowerCase()
      )},`;
    } else if (param.instrumentAddr) {
      instrumentCondition = hasInstrumentField
        ? `instrument: ${fn(param.instrumentAddr.toLowerCase())},`
        : `amm_:{instrument: ${fn(param.instrumentAddr.toLowerCase())}},`;
    }
    if (param.referralCode) {
      referralCondition = `referralCode_contains: ${fn(param.referralCode)},`;
    }
    const startTsCondition = `timestamp_gte: ${param.startTs || 0},`;
    const endTsCondition = `timestamp_lt: ${
      param.endTs || (0, context_1.now)()
    },`;
    const condition = `${eventCondition}${instrumentCondition}${pairCondition}${traderCondition}${referralCondition}${startTsCondition}${endTsCondition}`;
    return `where: {${condition} id_gt: $lastID}, `;
  }
  async getTransactionEvents(param) {
    const queryAll = param.size === undefined && param.page === undefined;
    const first = param.size || 1000;
    const skip = (param.page || 0) * first;
    let condition = this.buildQueryEventCondition(param);
    condition = queryAll
      ? condition
      : condition + "orderBy: timestamp, orderDirection: desc";
    const graphQL = `query($skip: Int, $first: Int, $lastID: String){
            transactionEvents(skip: $skip, first: $first, ${condition}){
                id
                name
                args
                address
                logIndex
                blockNumber
                timestamp
                trader
                amm {
                    id
                    symbol
                }
                instrument {
                    id
                    symbol
                }
                transaction {
                    id
                }
            }
        }`;
    let transactionEvents;
    if (queryAll) {
      transactionEvents = await this.dataSource.queryAll(
        graphQL,
        graph_1.GRAPH_PAGE_SIZE,
        true
      );
    } else {
      const resp = await this.dataSource.query(graphQL, skip, first);
      transactionEvents = resp.transactionEvents;
    }
    let result = [];
    for (const txEvent of transactionEvents) {
      result.push({
        id: txEvent.id,
        txHash: txEvent.transaction.id,
        address: txEvent.address,
        blockNumber: Number(txEvent.blockNumber),
        timestamp: Number(txEvent.timestamp),
        logIndex: Number(txEvent.logIndex),
        name: txEvent.name,
        args: JSON.parse(txEvent.args),
      });
    }
    result = (0, lodash_1.orderBy)(
      result,
      ["blockNumber", "logIndex"],
      ["desc", "desc"]
    );
    return result;
  }
  async getAccountBalanceHistory(param) {
    const events = await this.getTransactionEvents({
      ...param,
      eventNames: ["Deposit", "Withdraw"],
    });
    return events.map((event) => {
      return {
        timestamp: event.timestamp,
        trader: event.args.trader.toLowerCase(),
        quoteAddr: event.args.quote.toLowerCase(),
        logIndex: event.logIndex,
        amount: ethers_1.BigNumber.from(event.args.quantity),
        type: event.name,
        txHash: event.txHash,
      };
    });
  }
  async getFundingHistory(param) {
    const events = await this.getTransactionEvents({
      ...param,
      eventNames: ["FundingFee"],
    });
    return events.map((event) => {
      const funding = ethers_1.BigNumber.from(event.args.funding);
      return {
        timestamp: event.timestamp,
        instrumentAddr: event.address.toLowerCase(),
        expiry: Number(sdks_perp_1.PERP_EXPIRY),
        trader: event.args.trader.toLowerCase(),
        funding,
        logIndex: event.logIndex,
        type: funding.gt(0) ? "Receive" : "Pay",
        txHash: event.txHash,
      };
    });
  }
  async getTransferHistory(param) {
    const events = await this.getTransactionEvents({
      ...param,
      eventNames: ["Gather", "Scatter"],
    });
    return events.map((event) => {
      return {
        timestamp: event.timestamp,
        instrumentAddr: event.args.instrument.toLowerCase(),
        expiry: Number(event.args.expiry),
        trader: event.args.trader.toLowerCase(),
        quoteAddr: event.args.quote.toLowerCase(),
        amount: ethers_1.BigNumber.from(event.args.quantity),
        type: event.name,
        txHash: event.txHash,
        logIndex: event.logIndex,
      };
    });
  }
  async getOrderHistory(param) {
    const first = param.size ?? 1000;
    const skip = (param.page ?? 0) * first;
    const condition = this.buildQueryEventCondition(param, false);
    const graphQL = `query($skip: Int, $first: Int, $lastID: String){
            orders(skip: $skip, first: $first, ${condition} orderBy: timestamp, orderDirection: desc){
                id
                amm {
                    id
                    symbol
                    instrument{
                        id
                    }
                    expiry
                }
                createdTimestamp
                balance
                fee
                filledSize
                nonce
                price
                size
                status
                tick
                tradeValue
                trader
                timestamp
                placeEvent {
                    logIndex
                    transaction {
                        id
                    }
                }
                fillEvent {
                    logIndex
                    transaction {
                        id
                    }
                }
                cancelEvent {
                    logIndex
                    transaction {
                        id
                    }
                }
                referralCode
            }
        }`;
    const resp = await this.dataSource.query(graphQL, skip, first);
    const result = [];
    for (const order of resp.orders) {
      const size = ethers_1.BigNumber.from(order.size);
      const filledSize = ethers_1.BigNumber.from(order.filledSize);
      const price =
        order.status === enum_1.OrderStatus.CANCELLED
          ? sdks_perp_1.TickMath.getWadAtTick(Number(order.tick))
          : ethers_1.BigNumber.from(order.price);
      result.push({
        trader: order.trader.toLowerCase(),
        instrumentAddr: order.amm.instrument.id,
        expiry: Number(order.amm.expiry),
        tick: Number(order.tick),
        size: size.abs(),
        side: sdks_perp_1.utils.sizeToSide(size),
        filledSize: filledSize,
        price: price,
        tradeValue: (0, sdks_perp_1.wmul)(filledSize.abs(), price),
        fee: ethers_1.BigNumber.from(order.fee),
        createdTimestamp: Number(order.createdTimestamp),
        timestamp: Number(order.timestamp),
        status: order.status,
        placeTxHash: order.placeEvent.transaction.id,
        placeTxLogIndex: order.placeEvent.logIndex,
        fillTxHash: order.fillEvent?.transaction.id,
        fillTxLogIndex: order.fillEvent?.logIndex,
        cancelTxHash: order.cancelEvent?.transaction.id,
        cancelTxLogIndex: order.cancelEvent?.logIndex,
        referralCode: order.referralCode,
      });
    }
    return result;
  }
  async getVirtualTradeHistory(param) {
    const first = param.size ?? 1000;
    const skip = (param.page ?? 0) * first;
    const condition = this.buildQueryEventCondition(param, false);
    const graphQL = `query($skip: Int, $first: Int, $lastID: String){
            virtualTrades(skip: $skip, first: $first, ${condition} orderBy: blockNumber, orderDirection: desc){
                id
                amm {
                    id
                    symbol
                    instrument{
                        id
                    }
                    expiry
                }
                original {
                    transaction {
                        id
                    }
                    logIndex
                    name
                    args
                }
                fee
                price
                size
                timestamp
                blockNumber
                tradeValue
                trader
                type
                referralCode
            }
        }`;
    const resp = await this.dataSource.query(graphQL, skip, first);
    let result = [];
    for (const trade of resp.virtualTrades) {
      let isRangeLiquidated = false;
      if (trade.original.name === "Remove") {
        const args = JSON.parse(trade.original.args);
        isRangeLiquidated = args.trader !== args.operator;
      }
      let stablityFee = ethers_1.BigNumber.from(0);
      if (trade.original.name === "Trade" || trade.original.name === "Sweep") {
        const args = JSON.parse(trade.original.args);
        stablityFee = (0, sdks_perp_1.wmul)(
          ethers_1.BigNumber.from(trade.tradeValue),
          (0, sdks_perp_1.r2w)(
            Number(args.feeRatio) - Number(args.tradingFeeRatio)
          )
        );
      }
      let size = ethers_1.BigNumber.from(trade.size);
      if (trade.original.name === "Sweep") {
        size = size.mul(-1);
      }
      result.push({
        txHash: trade.original.transaction.id,
        logIndex: Number(trade.original.logIndex),
        blockNumber: Number(trade.blockNumber),
        timestamp: Number(trade.timestamp),
        trader: trade.trader,
        instrumentAddr: trade.amm.instrument.id,
        expiry: Number(trade.amm.expiry),
        size: size.abs(),
        side: sdks_perp_1.utils.sizeToSide(size),
        price: ethers_1.BigNumber.from(trade.price),
        fee: ethers_1.BigNumber.from(trade.fee),
        stablityFee,
        tradeValue: ethers_1.BigNumber.from(trade.tradeValue),
        type: trade.type,
        isRangeLiquidated,
        referralCode: trade.referralCode,
      });
    }
    result = (0, lodash_1.orderBy)(
      result,
      ["blockNumber", "logIndex"],
      ["desc", "desc"]
    );
    return result;
  }
  async getLiquidityHistory(param) {
    const events = await this.getTransactionEvents({
      ...param,
      eventNames: ["Add", "Remove"],
    });
    return events.map((event) => {
      return {
        timestamp: event.timestamp,
        instrumentAddr: event.address.toLowerCase(),
        expiry: Number(event.args.expiry),
        trader: event.args.trader.toLowerCase(),
        operator:
          event.name === "Remove"
            ? event.args.operator.toLowerCase()
            : undefined,
        lowerPrice: sdks_perp_1.TickMath.getWadAtTick(
          Number(event.args.tickLower)
        ),
        upperPrice: sdks_perp_1.TickMath.getWadAtTick(
          Number(event.args.tickUpper)
        ),
        amount: ethers_1.BigNumber.from(
          event.name === "Add" ? event.args.range[2] : event.args.pic[0]
        ),
        feeEarned:
          event.name === "Remove"
            ? ethers_1.BigNumber.from(event.args.fee)
            : undefined,
        type: event.name,
        txHash: event.txHash,
        logIndex: Number(event.logIndex),
        fairPrice:
          event.name === "Add"
            ? (0, sdks_perp_1.sqrtX96ToWad)(
                event.args.range[event.args.range.length - 1]
              )
            : (0, sdks_perp_1.sqrtX96ToWad)(event.args.sqrtPX96),
      };
    });
  }
}
exports.History = History;
