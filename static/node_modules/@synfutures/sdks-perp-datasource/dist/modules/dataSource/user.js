"use strict";
var __importDefault =
  (this && this.__importDefault) ||
  function (mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
Object.defineProperty(exports, "__esModule", { value: true });
exports.User = void 0;
const async_retry_1 = __importDefault(require("async-retry"));
const node_fetch_1 = __importDefault(require("node-fetch"));
const errors_1 = require("../../errors");
const graph_1 = require("@derivation-tech/context/dist/utils/graph");
const ethers_1 = require("ethers");
const sdks_perp_1 = require("@synfutures/sdks-perp");
const utils_1 = require("../../utils");
class User {
  constructor(dataSource) {
    this.dataSource = dataSource;
  }
  async getUserAmms(trader) {
    trader = trader.toLowerCase();
    const graphql = `
{
    ranges(where:{status: OPEN, trader: "${trader}"}) {
        amm {
            id
        }
    }
    orders(where:{status: OPEN, trader: "${trader}"}) {
        amm {
            id
        }
    }
    positions(where:{size_not: 0, trader: "${trader}"}) {
        amm {
            id
        }
    }
}
        `;
    const opts = {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ query: graphql }),
      redirect: "follow",
      timeout: 100000,
    };
    const resp = await (0, async_retry_1.default)(async () => {
      const response = await (0, node_fetch_1.default)(
        this.dataSource.endpoint,
        opts
      );
      const json = await response.json();
      if (!json.data || json.errors) {
        throw new errors_1.TheGraphError(
          "Subgraph query error" + JSON.stringify(json.errors)
        );
      }
      return json.data;
    }, this.dataSource.retryOption);
    return Array.from(
      new Set(
        [...resp.ranges, ...resp.orders, ...resp.positions].map(
          ({ amm }) => amm.id
        )
      )
    ).map((id) => {
      return {
        instrument: id.substring(0, 42),
        expiry: Number(id.substring(43)),
      };
    });
  }
  async getUserPnl(address, targetBlock, allInstruments) {
    const [
      assertQueryResult,
      positionQueryResult,
      orderQueryResult,
      rangeQueryResult,
    ] = await Promise.all([
      this.getUserGateAsserts(address, targetBlock),
      this.getUserOpenPositions(address, targetBlock),
      this.getUserOpenOrders(address, targetBlock),
      this.getUserRanges(address, targetBlock),
    ]);
    const pnlMap = new Map();
    const findAmm = (instrumentAddr, expiry) => {
      const instrument = allInstruments.find(
        (instrument) =>
          instrument.instrumentAddr.toLocaleLowerCase() === instrumentAddr
      );
      if (!instrument) {
        throw new Error(`Instrument not found for id: ${instrumentAddr}`);
      }
      const amm = instrument.amms.get(expiry);
      if (!amm) {
        throw new Error(`Amm not found for instrument: ${instrumentAddr}`);
      }
      return amm;
    };
    for (const assert of assertQueryResult) {
      let pnl = ethers_1.ethers.BigNumber.from(0);
      const decimals = Number(assert.quote.decimals);
      const amount = ethers_1.ethers.BigNumber.from(assert.totalWithdraw).sub(
        ethers_1.ethers.BigNumber.from(assert.totalDeposit)
      );
      pnl = pnl.add(amount).add(ethers_1.ethers.BigNumber.from(assert.balance));
      const formattedAmount = (0, sdks_perp_1.d2w)(pnl, decimals);
      const quote = assert.quote.symbol;
      pnlMap.set(quote, formattedAmount);
    }
    for (const position of positionQueryResult) {
      const postionInstance = {
        balance: ethers_1.ethers.BigNumber.from(position.balance),
        size: ethers_1.ethers.BigNumber.from(position.size),
        entryNotional: ethers_1.ethers.BigNumber.from(position.entryNotional),
        entrySocialLossIndex: ethers_1.ethers.BigNumber.from(
          position.entrySocialLossIndex
        ),
        entryFundingIndex: ethers_1.ethers.BigNumber.from(
          position.entryFundingIndex
        ),
      };
      const amm = findAmm(
        position.amm.instrument.id,
        Number(position.amm.expiry)
      );
      const markPrice = amm.markPrice;
      const { pnl } = sdks_perp_1.utils.lowLevel.tally(
        amm,
        postionInstance,
        markPrice
      );
      const quote = (0, utils_1.pickQuoteFromFullSymbol)(position.amm.symbol);
      const pnlInQuote = pnlMap.get(quote) || ethers_1.ethers.BigNumber.from(0);
      pnlMap.set(
        quote,
        pnlInQuote
          .add(pnl)
          .add(ethers_1.ethers.BigNumber.from(position.balance))
      );
    }
    for (const order of orderQueryResult) {
      const quote = (0, utils_1.pickQuoteFromFullSymbol)(order.amm.symbol);
      const pnlInQuote = pnlMap.get(quote) || ethers_1.ethers.BigNumber.from(0);
      pnlMap.set(
        quote,
        pnlInQuote.add(ethers_1.ethers.BigNumber.from(order.balance))
      );
    }
    for (const range of rangeQueryResult) {
      const quote = (0, utils_1.pickQuoteFromFullSymbol)(range.amm.symbol);
      const amm = findAmm(range.amm.instrument.id, Number(range.amm.expiry));
      const markPrice = amm.markPrice;
      const rangeInstance = {
        liquidity: ethers_1.ethers.BigNumber.from(range.liquidity),
        entryFeeIndex: ethers_1.ethers.BigNumber.from(range.entryFeeIndex),
        balance: ethers_1.ethers.BigNumber.from(range.balance),
        sqrtEntryPX96: ethers_1.ethers.BigNumber.from(range.sqrtEntryPX96),
        tickLower: Number(range.tickLower),
        tickUpper: Number(range.tickUpper),
      };
      const position = sdks_perp_1.utils.rangeToPosition(rangeInstance, amm);
      const { equity } = sdks_perp_1.utils.lowLevel.tally(
        amm,
        position,
        markPrice
      );
      const pnlInQuote = pnlMap.get(quote) || ethers_1.ethers.BigNumber.from(0);
      pnlMap.set(quote, pnlInQuote.add(equity));
    }
    return pnlMap;
  }
  async getUserGateAsserts(address, targetBlock) {
    const graphql = `query($skip: Int, $first: Int, $lastID: String){
            userVaults(
                first: $first,
                skip: $skip,
                block: { number: ${targetBlock} },
                where: {
                    user: "${address.toLocaleLowerCase()}",
                    id_gt: $lastID
                }
            ) {
                id
                user {
                    id
                }
                quote {
                    name
                    symbol
                    decimals
                }
                balance
                totalDeposit
                totalWithdraw
            }
        }`;
    const result = this.dataSource.queryAll(
      graphql,
      graph_1.GRAPH_PAGE_SIZE,
      true
    );
    return result;
  }
  async getUserOpenPositions(address, targetBlock) {
    const graphql = `query($skip: Int, $first: Int, $lastID: String){
            positions(
                first: $first,
                skip: $skip,
                block: { number: ${targetBlock} },
                where: {
                    size_not: 0,
                    trader: "${address.toLocaleLowerCase()}",
                    id_gt: $lastID
                }
            ) {
                trader
                balance
                size
                entryNotional
                entrySocialLossIndex
                entryFundingIndex
                amm {
                    instrument {
                        id
                    }
                    symbol
                    expiry
                }
            }
        }`;
    const result = this.dataSource.queryAll(
      graphql,
      graph_1.GRAPH_PAGE_SIZE,
      true
    );
    return result;
  }
  async getUserOpenOrders(address, targetBlock) {
    const graphql = `query($skip: Int, $first: Int, $lastID: String){
            orders(
                first: $first,
                skip: $skip,
                block: { number: ${targetBlock} },
                where: {
                    status: OPEN,
                    trader: "${address.toLocaleLowerCase()}",
                    id_gt: $lastID
                }
            ) {
                trader
                tick
                nonce
                balance
                size
                filledSize
                tradeValue
                createdTimestamp
                fee
                status
                amm {
                    instrument {
                        id
                    }
                    symbol
                    expiry
                }
            }
        }`;
    const result = this.dataSource.queryAll(
      graphql,
      graph_1.GRAPH_PAGE_SIZE,
      true
    );
    return result;
  }
  async getUserRanges(address, targetBlock) {
    const graphql = `query($skip: Int, $first: Int, $lastID: String){
            ranges(
                first: $first,
                skip: $skip,
                block: { number: ${targetBlock} },
                where: {
                    status: OPEN,
                    trader: "${address.toLocaleLowerCase()}",
                    id_gt: $lastID
                }
            ) {
                trader
                tickLower
                tickUpper
                liquidity
                balance
                sqrtEntryPX96
                entryFeeIndex
                amm {
                    instrument {
                        id
                    }
                    symbol
                    expiry
                }
            }
        }`;
    const result = this.dataSource.queryAll(
      graphql,
      graph_1.GRAPH_PAGE_SIZE,
      true
    );
    return result;
  }
}
exports.User = User;
