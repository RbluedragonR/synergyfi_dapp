"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mulDivRoundingUp = mulDivRoundingUp;
exports.mulShift = mulShift;
exports.multiplyIn256 = multiplyIn256;
exports.addIn256 = addIn256;
exports.oppositeSigns = oppositeSigns;
exports.mostSignificantBit = mostSignificantBit;
exports.sqrt = sqrt;
exports.roundHalfUp = roundHalfUp;
exports.neg = neg;
exports.signedDiv = signedDiv;
exports.wdiv = wdiv;
exports.safeWDiv = safeWDiv;
exports.wdivUp = wdivUp;
exports.wdivDown = wdivDown;
exports.wmul = wmul;
exports.wmulInt = wmulInt;
exports.wmulUp = wmulUp;
exports.wmulDown = wmulDown;
exports.fracUp = fracUp;
exports.fracDown = fracDown;
exports.frac = frac;
exports.weightedAverage = weightedAverage;
exports.r2w = r2w;
exports.s2w = s2w;
exports.d2w = d2w;
exports.w2d = w2d;
exports.mulMod = mulMod;
exports.fullMul = fullMul;
exports.fullDiv = fullDiv;
exports.mulDiv = mulDiv;
exports.sqrtX96ToWad = sqrtX96ToWad;
exports.wadToSqrtX96 = wadToSqrtX96;
exports.wadToTick = wadToTick;
exports.leastSignificantBit = leastSignificantBit;
exports.leastNonnegativeRemainder = leastNonnegativeRemainder;
exports.leastNonnegativeComplement = leastNonnegativeComplement;
exports.maxAmongThree = maxAmongThree;
exports.max = max;
exports.min = min;
exports.relativeDiffRatioWadAbs = relativeDiffRatioWadAbs;
exports.getOrderLeverageByMargin = getOrderLeverageByMargin;
exports.getMaxLeverage = getMaxLeverage;
exports.calcMaxWithdrawable = calcMaxWithdrawable;
exports.alignPriceToTick = alignPriceToTick;
exports.calcBoost = calcBoost;
exports.calcAsymmetricBoost = calcAsymmetricBoost;
const ethers_1 = require("ethers");
const utils_1 = require("../utils");
const tickMath_1 = require("./tickMath");
const constants_1 = require("../constants");
const constants_2 = require("./constants");
const calculationError_1 = require("../errors/calculationError");
function mulDivRoundingUp(a, b, denominator) {
  const product = a.mul(b);
  let result = product.div(denominator);
  if (!product.mod(denominator).eq(constants_2.ZERO))
    result = result.add(constants_2.ONE);
  return result;
}
function mulShift(val, mulBy) {
  return val.mul(ethers_1.BigNumber.from(mulBy)).shr(128);
}
function multiplyIn256(x, y) {
  return x.mul(y).and(constants_2.MAX_UINT_256);
}
function addIn256(x, y) {
  return x.add(y).and(constants_2.MAX_UINT_256);
}
function oppositeSigns(x, y) {
  return x.mul(y).lt(constants_2.ZERO) ? true : false;
}
function mostSignificantBit(x) {
  (0, utils_1.solidityRequire)(x.gt(0), "ZERO");
  (0, utils_1.solidityRequire)(x.lte(constants_2.MAX_UINT_256), "MAX");
  let msb = 0;
  for (const [power, min] of constants_2.POWERS_OF_2) {
    if (x.gte(min)) {
      x = x.shr(power);
      msb += power;
    }
  }
  return msb;
}
function sqrt(value) {
  (0, utils_1.solidityRequire)(value.gte(0), "NEGATIVE");
  if (value.lt(constants_2.MAX_SAFE_INTEGER)) {
    return ethers_1.BigNumber.from(Math.floor(Math.sqrt(Number(value))));
  }
  let z;
  let x;
  z = value;
  x = value.div(constants_2.TWO).add(constants_2.ONE);
  while (x.lt(z)) {
    z = x;
    x = value.div(x).add(x).div(constants_2.TWO);
  }
  return z;
}
function roundHalfUp(x, y) {
  const z = y.div(constants_2.TWO);
  if (x.gt(0)) {
    return x.add(z);
  }
  return x.sub(z);
}
function neg(x) {
  return constants_2.ZERO.sub(x);
}
function signedDiv(x, y) {
  return (x - (x % y)) / y;
}
function wdiv(x, y) {
  return frac(x, constants_2.WAD, y);
}
function safeWDiv(x, y) {
  if (y.eq(constants_2.ZERO)) return constants_2.ZERO;
  return frac(x, constants_2.WAD, y);
}
function wdivUp(x, y) {
  return fracUp(x, constants_2.WAD, y);
}
function wdivDown(x, y) {
  return fracDown(x, constants_2.WAD, y);
}
function wmul(x, y) {
  return frac(x, y, constants_2.WAD);
}
function wmulInt(x, y) {
  let product = x.mul(y);
  if (product.isNegative()) {
    product = product.sub(constants_2.WAD.div(2));
  } else {
    product = product.add(constants_2.WAD.div(2));
  }
  return product.div(constants_2.WAD);
}
function wmulUp(x, y) {
  return fracUp(x, y, constants_2.WAD);
}
function wmulDown(x, y) {
  return fracDown(x, y, constants_2.WAD);
}
function fracUp(x, y, w) {
  const prod = x.mul(y).add(w.sub(1));
  return prod.div(w);
}
function fracDown(x, y, w) {
  return x.mul(y).div(w);
}
function frac(x, y, w) {
  const prod = x.mul(y).add(w.div(2));
  return prod.div(w);
}
function weightedAverage(w1, x1, w2, x2) {
  return x1.mul(w1).add(x2.mul(w2)).div(w1.add(w2));
}
function r2w(x) {
  x = ethers_1.BigNumber.from(x);
  return x.mul(ethers_1.BigNumber.from(10).pow(14));
}
function s2w(x) {
  x = ethers_1.BigNumber.from(x);
  return x.mul(ethers_1.BigNumber.from(10).pow(16));
}
function d2w(x, decimals) {
  return x.mul(ethers_1.BigNumber.from(10).pow(18 - decimals));
}
function w2d(x, decimals) {
  return wmul(x, ethers_1.BigNumber.from(10).pow(decimals));
}
function mulMod(x, y, d) {
  return x.mod(d).mul(y.mod(d)).mod(d);
}
function fullMul(x, y) {
  const mm = mulMod(x, y, constants_2.MAX_UINT_256);
  const l = x.mul(y);
  let h = mm.sub(l);
  if (mm.lt(l)) {
    h = h.sub(1);
  }
  return { l, h };
}
function fullDiv(l, h, d) {
  const negd = constants_2.MAX_UINT_256.sub(d).add(1);
  const pow2 = d.and(negd);
  d = d.div(pow2);
  l = l.div(pow2);
  const negPow2 = constants_2.MAX_UINT_256.sub(pow2).add(1);
  l = l.add(h.mul(negPow2.div(pow2).add(1)));
  let r = constants_2.ONE;
  for (let i = 0; i < 8; i++) {
    r = r.mul(constants_2.TWO.sub(d.mul(r)));
  }
  return l.mul(r);
}
function mulDiv(x, y, d) {
  let { l: _l, h: _h } = fullMul(x, y);
  const mm = mulMod(x, y, d);
  if (mm.gt(_l)) {
    _h = _h.sub(1);
  }
  _l = _l.sub(mm);
  return fullDiv(_l, _h, d);
}
function sqrtX96ToWad(sqrtPX96) {
  sqrtPX96 = ethers_1.BigNumber.from(sqrtPX96);
  const px96 = mulDiv(sqrtPX96, sqrtPX96, constants_2.Q96);
  return mulDiv(px96, constants_2.WAD, constants_2.Q96);
}
function wadToSqrtX96(price) {
  const x96 = price.mul(constants_2.Q96).div(constants_2.WAD);
  return sqrt(x96.mul(constants_2.Q96));
}
function wadToTick(price) {
  const sqrtX96 = wadToSqrtX96(price);
  return tickMath_1.TickMath.getTickAtSqrtRatio(sqrtX96);
}
function leastSignificantBit(x) {
  let r = 255;
  if (x.and(constants_2.MAX_UINT_128).gt(constants_2.ZERO)) {
    r -= 128;
  } else {
    x = x.shr(128);
  }
  if (x.and(constants_2.MAX_UINT_64).gt(constants_2.ZERO)) {
    r -= 64;
  } else {
    x = x.shr(64);
  }
  if (x.and(constants_2.MAX_UINT_32).gt(constants_2.ZERO)) {
    r -= 32;
  } else {
    x = x.shr(32);
  }
  if (x.and(constants_2.MAX_UINT_16).gt(constants_2.ZERO)) {
    r -= 16;
  } else {
    x = x.shr(16);
  }
  if (x.and(constants_2.MAX_UINT_8).gt(constants_2.ZERO)) {
    r -= 8;
  } else {
    x = x.shr(8);
  }
  if (x.and(ethers_1.BigNumber.from("0xf")).gt(constants_2.ZERO)) {
    r -= 4;
  } else {
    x = x.shr(4);
  }
  if (x.and(ethers_1.BigNumber.from("0x3")).gt(constants_2.ZERO)) {
    r -= 2;
  } else {
    x = x.shr(2);
  }
  if (x.and(ethers_1.BigNumber.from("0x1")).gt(constants_2.ZERO)) r -= 1;
  return r;
}
function leastNonnegativeRemainder(x, modulus) {
  return ((x % modulus) + modulus) % modulus;
}
function leastNonnegativeComplement(x, modulus) {
  return (modulus - (x % modulus)) % modulus;
}
function maxAmongThree(a, b, c) {
  return (a.gt(b) ? a : b).gt(c) ? (a.gt(b) ? a : b) : c;
}
function max(left, right) {
  return left.gt(right) ? left : right;
}
function min(left, right) {
  return left.gt(right) ? right : left;
}
function relativeDiffRatioWadAbs(wadA, wadB) {
  return wdivUp(wadA.sub(wadB).abs(), wadA.lt(wadB) ? wadA : wadB);
}
function getOrderLeverageByMargin(targetTick, baseSize, margin) {
  return wdiv(
    wmul(tickMath_1.TickMath.getWadAtTick(targetTick), baseSize.abs()),
    margin
  );
}
function getMaxLeverage(imr) {
  return 1 / (imr / 10 ** constants_1.RATIO_DECIMALS);
}
function calcMaxWithdrawable(threshold, pending, fundFlow, reserve) {
  const maxWithdrawable = threshold
    .add(pending.exemption)
    .sub(fundFlow.totalOut)
    .add(fundFlow.totalIn)
    .sub(pending.amount);
  if (maxWithdrawable.lte(0)) return constants_2.ZERO;
  if (maxWithdrawable.gt(reserve)) return reserve;
  return maxWithdrawable;
}
function alignPriceToTick(price) {
  let tick = wadToTick(price);
  tick =
    Math.round(tick / constants_1.PEARL_SPACING) * constants_1.PEARL_SPACING;
  const alignedprice = tickMath_1.TickMath.getWadAtTick(tick);
  return { tick: tick, price: alignedprice };
}
function calcBoost(alpha, imr) {
  if (alpha === 1) {
    throw new calculationError_1.CalculationError("Invalid alpha", { alpha });
  }
  imr = imr / 10 ** constants_1.RATIO_DECIMALS;
  return (
    -2 / (alpha * (imr + 1) - Math.sqrt(alpha)) / (1 / Math.sqrt(alpha) - 1)
  );
}
function calcAsymmetricBoost(alphaLower, alphaUpper, imr) {
  if (alphaLower === 1 && alphaUpper === 1) {
    throw new calculationError_1.CalculationError("Invalid alpha and beta", {
      alphaLower,
      alphaUpper,
      imr,
    });
  }
  imr = imr / 10 ** constants_1.RATIO_DECIMALS;
  const boostLower =
    2 /
    (1 / Math.sqrt(alphaLower) - 1) /
    ((1 / Math.sqrt(alphaLower)) * (1 - imr) - 1);
  const boostUpper = calcBoost(alphaUpper, imr);
  return Math.min(boostLower, boostUpper);
}
