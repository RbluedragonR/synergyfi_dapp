"use strict";
var __createBinding =
  (this && this.__createBinding) ||
  (Object.create
    ? function (o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (
          !desc ||
          ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)
        ) {
          desc = {
            enumerable: true,
            get: function () {
              return m[k];
            },
          };
        }
        Object.defineProperty(o, k2, desc);
      }
    : function (o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
      });
var __setModuleDefault =
  (this && this.__setModuleDefault) ||
  (Object.create
    ? function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      }
    : function (o, v) {
        o["default"] = v;
      });
var __importStar =
  (this && this.__importStar) ||
  (function () {
    var ownKeys = function (o) {
      ownKeys =
        Object.getOwnPropertyNames ||
        function (o) {
          var ar = [];
          for (var k in o)
            if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
          return ar;
        };
      return ownKeys(o);
    };
    return function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null)
        for (var k = ownKeys(mod), i = 0; i < k.length; i++)
          if (k[i] !== "default") __createBinding(result, mod, k[i]);
      __setModuleDefault(result, mod);
      return result;
    };
  })();
var __importDefault =
  (this && this.__importDefault) ||
  function (mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
Object.defineProperty(exports, "__esModule", { value: true });
exports.quickRetry = quickRetry;
exports.getLeverageFromImr = getLeverageFromImr;
exports.alignExpiry = alignExpiry;
exports.alignTick = alignTick;
exports.getMinTick = getMinTick;
exports.getMaxTick = getMaxTick;
exports.getMaxLiquidityPerTick = getMaxLiquidityPerTick;
exports.rangeKey = rangeKey;
exports.orderKey = orderKey;
exports.parseTicks = parseTicks;
exports.parseOrderTickNonce = parseOrderTickNonce;
exports.normalizeTick = normalizeTick;
exports.solidityRequire = solidityRequire;
exports.tickDeltaToAlphaWad = tickDeltaToAlphaWad;
exports.alphaWadToTickDelta = alphaWadToTickDelta;
exports.decomposePbitmap = decomposePbitmap;
exports.trimObj = trimObj;
exports.formatExpiry = formatExpiry;
exports.dateExpiry2Ts = dateExpiry2Ts;
exports.getTokenSymbol = getTokenSymbol;
exports.getTokenInfo = getTokenInfo;
exports.isEmptyPortfolio = isEmptyPortfolio;
exports.isCexMarket = isCexMarket;
exports.sizeToSide = sizeToSide;
exports.signOfSide = signOfSide;
exports.isByBase = isByBase;
exports.isPosition = isPosition;
exports.isPortfolio = isPortfolio;
exports.isInstrument = isInstrument;
exports.toPopulatedTxOverrides = toPopulatedTxOverrides;
exports.toPortfolio = toPortfolio;
const ethers_1 = require("ethers");
const moment_1 = __importDefault(require("moment"));
const constants_1 = require("../constants");
const math_1 = require("../math");
const enum_1 = require("../enum");
const factory = __importStar(require("./factory"));
const calculationError_1 = require("../errors/calculationError");
const synfError_1 = require("../errors/synfError");
async function quickRetry(fn, times = 3, interval = 100) {
  let error;
  for (let i = 0; ; i++) {
    try {
      return await fn();
    } catch (err) {
      error = err;
    }
    if (i === times - 1) {
      break;
    }
    await new Promise((r) => setTimeout(r, (i + 1) * interval));
  }
  throw error;
}
function getLeverageFromImr(imr) {
  if (imr === 1000) return enum_1.Leverage.LOW;
  if (imr === 500) return enum_1.Leverage.MEDIUM;
  if (imr === 300) return enum_1.Leverage.HIGH;
  if (imr === 100) return enum_1.Leverage.RISKY;
  throw new calculationError_1.CalculationError("Invalid IMR value", { imr });
}
function alignExpiry() {
  return (
    Math.floor((Date.now() / 1000 + 259200) / 604800) * 604800 +
    345600 +
    28800 -
    259200
  );
}
function alignTick(tick, tickSpacing) {
  return tick - (tick % tickSpacing);
}
function getMinTick(tickSpacing) {
  return Math.ceil(-math_1.TickMath.MAX_TICK / tickSpacing) * tickSpacing;
}
function getMaxTick(tickSpacing) {
  return Math.floor(math_1.TickMath.MAX_TICK / tickSpacing) * tickSpacing;
}
function getMaxLiquidityPerTick(tickSpacing) {
  return math_1.MAX_UINT_128.div(
    (getMaxTick(tickSpacing) - getMinTick(tickSpacing)) / tickSpacing + 1
  );
}
function rangeKey(tickLower, tickUpper) {
  return (
    shiftLeft((0, math_1.asUint24)(tickLower), 24) +
    (0, math_1.asUint24)(tickUpper)
  );
}
function orderKey(tick, nonce) {
  return shiftLeft((0, math_1.asUint24)(tick), 24) + nonce;
}
function shiftLeft(x, n) {
  return x * Math.pow(2, n);
}
function shiftRight(x, n) {
  return Math.floor(x / Math.pow(2, n));
}
const MAX_UINT_24 = shiftLeft(1, 24) - 1;
const MAX_UINT_48 = shiftLeft(1, 48) - 1;
function parseTicks(key) {
  if (key > MAX_UINT_48) {
    throw new calculationError_1.CalculationError("Not 48-bit key", { key });
  }
  const tickLower = (0, math_1.asInt24)(shiftRight(key, 24));
  const tickUpper = (0, math_1.asInt24)(key & MAX_UINT_24);
  return { tickLower, tickUpper };
}
function parseOrderTickNonce(key) {
  if (key > MAX_UINT_48) {
    throw new calculationError_1.CalculationError("Not 48-bit key", { key });
  }
  const tick = (0, math_1.asInt24)(shiftRight(key, 24));
  const nonce = key & MAX_UINT_24;
  return { tick, nonce };
}
function normalizeTick(originTick, tickSpacing) {
  return ethers_1.BigNumber.from(originTick)
    .div(tickSpacing)
    .mul(tickSpacing)
    .toNumber();
}
function solidityRequire(condition, message) {
  if (!condition) {
    throw new synfError_1.SynfError(message ?? "Solidity require failed");
  }
}
function tickDeltaToAlphaWad(tickDelta) {
  return math_1.TickMath.getWadAtTick(tickDelta);
}
function alphaWadToTickDelta(alphaWad) {
  return math_1.TickMath.getTickAtPWad(alphaWad) + 1;
}
function decomposePbitmap(pbitmap) {
  const bits = [];
  for (let i = 0; i < constants_1.MAX_POSITION_NUM; i++) {
    if (!pbitmap.and(math_1.ONE.shl(i)).isZero()) {
      bits.push(i);
    }
  }
  return bits;
}
function isEthersArray(obj) {
  if (obj instanceof Array) {
    return obj.length === Object.keys(obj).length;
  }
  return false;
}
function isEthersTypeChainStruct(obj) {
  if (obj instanceof Array) {
    return obj.length !== Object.keys(obj).length;
  }
  return false;
}
function trimObj(obj) {
  if (isEthersTypeChainStruct(obj)) {
    const ret = {};
    Object.keys(obj).forEach((key, i) => {
      if (i >= obj.length) {
        ret[key] = trimObj(obj[key]);
      }
    });
    return ret;
  } else if (isEthersArray(obj)) {
    return obj.map((item) => trimObj(item));
  } else {
    return obj;
  }
}
function formatExpiry(expiry) {
  return expiry === constants_1.PERP_EXPIRY
    ? "PERP"
    : moment_1.default.utc(expiry * 1000).format("yyyyMMDD");
}
function dateExpiry2Ts(expiry) {
  if (
    expiry === "0" ||
    expiry.toUpperCase() === "PERPETUAL" ||
    expiry.toUpperCase() === "PERP"
  ) {
    return constants_1.PERP_EXPIRY;
  }
  return moment_1.default.utc(expiry, "YYYYMMDD").unix();
}
function getTokenSymbol(base, quote) {
  const baseSymbol = typeof base === "string" ? base : base.symbol;
  const quoteSymbol = typeof quote === "string" ? quote : quote.symbol;
  return { baseSymbol, quoteSymbol };
}
async function getTokenInfo(instrumentIdentifier, ctx) {
  const call1 =
    typeof instrumentIdentifier.baseSymbol === "string"
      ? ctx.getTokenInfo(instrumentIdentifier.baseSymbol)
      : instrumentIdentifier.baseSymbol;
  const call2 =
    typeof instrumentIdentifier.quoteSymbol === "string"
      ? ctx.getTokenInfo(instrumentIdentifier.quoteSymbol)
      : instrumentIdentifier.quoteSymbol;
  const [baseTokenInfo, quoteTokenInfo] = await Promise.all([call1, call2]);
  return { baseTokenInfo, quoteTokenInfo };
}
function isEmptyPortfolio(portfolio) {
  return (
    portfolio.orders.size === 0 &&
    portfolio.ranges.size === 0 &&
    portfolio.position.size.isZero()
  );
}
function isCexMarket(marketType) {
  return (
    marketType === enum_1.MarketType.LINK ||
    marketType === enum_1.MarketType.EMG ||
    marketType === enum_1.MarketType.PYTH
  );
}
function sizeToSide(size) {
  if (size.isNegative()) {
    return enum_1.Side.SHORT;
  } else if (size.isZero()) {
    return enum_1.Side.FLAT;
  } else {
    return enum_1.Side.LONG;
  }
}
function signOfSide(side) {
  switch (side) {
    case enum_1.Side.LONG:
      return 1;
    case enum_1.Side.SHORT:
      return -1;
    case enum_1.Side.FLAT:
      return 0;
    default:
      throw new synfError_1.SynfError(`Invalid side: ${side}`);
  }
}
function isByBase(size) {
  return "base" in size;
}
function isPosition(info) {
  return "size" in info;
}
function isPortfolio(info) {
  return "position" in info;
}
function isInstrument(instrument) {
  return "instrumentAddr" in instrument;
}
function toPopulatedTxOverrides(txOptions) {
  if (!txOptions) {
    return {};
  }
  const _txOptions = {
    ...txOptions,
  };
  if (_txOptions.signer) {
    if (_txOptions.from === undefined) {
      _txOptions.from = _txOptions.signer.getAddress();
    }
    delete _txOptions["signer"];
  }
  if (_txOptions.blockTag) {
    delete _txOptions["blockTag"];
  }
  if (_txOptions.enableGasPrice) {
    delete _txOptions["enableGasPrice"];
  }
  if (_txOptions.disableGasLimit) {
    delete _txOptions["disableGasLimit"];
  }
  if (_txOptions.gasLimitMultiple) {
    delete _txOptions["gasLimitMultiple"];
  }
  if (_txOptions.gasPriceMultiple) {
    delete _txOptions["gasPriceMultiple"];
  }
  return _txOptions;
}
function toPortfolio(instrumentAddr, expiry, traderAddr, resp) {
  const position = factory.createPosition({
    instrumentAddr,
    expiry,
    traderAddr,
    ...trimObj(resp.portfolio.position),
  });
  const oids = resp.portfolio.oids;
  const rids = resp.portfolio.rids;
  const rawOrdersFromContract = resp.portfolio.orders;
  const rawRangesFromContract = resp.portfolio.ranges;
  const ordersTaken = resp.portfolio.ordersTaken;
  const orders = new Map();
  const ranges = new Map();
  for (let i = 0; i < oids.length; i++) {
    const { tick, nonce } = parseOrderTickNonce(oids[i]);
    const order = factory.createOrder({
      balance: rawOrdersFromContract[i].balance,
      size: rawOrdersFromContract[i].size,
      instrumentAddr,
      expiry,
      taken: ordersTaken[i] ?? math_1.ZERO,
      tick,
      nonce,
      traderAddr,
    });
    orders.set(oids[i], order);
  }
  for (let i = 0; i < rids.length; i++) {
    const { tickLower, tickUpper } = parseTicks(rids[i]);
    const range = factory.createRange({
      liquidity: rawRangesFromContract[i].liquidity,
      entryFeeIndex: rawRangesFromContract[i].entryFeeIndex,
      balance: rawRangesFromContract[i].balance,
      sqrtEntryPX96: rawRangesFromContract[i].sqrtEntryPX96,
      tickLower,
      tickUpper,
      instrumentAddr,
      expiry,
      traderAddr,
    });
    ranges.set(rids[i], range);
  }
  const portfolio = {
    instrumentAddr: instrumentAddr.toLowerCase(),
    traderAddr: traderAddr.toLowerCase(),
    expiry,
    ranges,
    orders,
    isEmpty: position.size.eq(0) && ranges.size === 0 && orders.size === 0,
    blockInfo: trimObj(resp.blockInfo),
    position,
  };
  return portfolio;
}
