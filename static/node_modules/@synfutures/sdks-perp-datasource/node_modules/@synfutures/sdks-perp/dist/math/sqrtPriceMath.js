"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SqrtPriceMath = void 0;
const ethers_1 = require("ethers");
const utils_1 = require("../utils");
const constants_1 = require("./constants");
const basic_1 = require("./basic");
class SqrtPriceMath {
  static getDeltaBaseAutoRoundUp(sqrtRatioAX96, sqrtRatioBX96, liquidity) {
    return liquidity.lt(constants_1.ZERO)
      ? this.getDeltaBase(
          sqrtRatioAX96,
          sqrtRatioBX96,
          liquidity.mul(-1),
          false
        ).mul(-1)
      : this.getDeltaBase(sqrtRatioAX96, sqrtRatioBX96, liquidity, true);
  }
  static getDeltaQuoteAutoRoundUp(sqrtRatioAX96, sqrtRatioBX96, liquidity) {
    return liquidity.lt(constants_1.ZERO)
      ? this.getDeltaQuote(
          sqrtRatioAX96,
          sqrtRatioBX96,
          liquidity.mul(-1),
          false
        ).mul(-1)
      : this.getDeltaQuote(sqrtRatioAX96, sqrtRatioBX96, liquidity, true);
  }
  static getDeltaBase(sqrtRatioAX96, sqrtRatioBX96, liquidity, roundUp) {
    if (sqrtRatioAX96.gt(sqrtRatioBX96)) {
      [sqrtRatioAX96, sqrtRatioBX96] = [sqrtRatioBX96, sqrtRatioAX96];
    }
    const numerator1 = liquidity.shl(96);
    const numerator2 = sqrtRatioBX96.sub(sqrtRatioAX96);
    return roundUp
      ? (0, basic_1.mulDivRoundingUp)(
          (0, basic_1.mulDivRoundingUp)(numerator1, numerator2, sqrtRatioBX96),
          constants_1.ONE,
          sqrtRatioAX96
        )
      : numerator1.mul(numerator2).div(sqrtRatioBX96).div(sqrtRatioAX96);
  }
  static getDeltaQuote(sqrtRatioAX96, sqrtRatioBX96, liquidity, roundUp) {
    if (sqrtRatioAX96.gt(sqrtRatioBX96)) {
      [sqrtRatioAX96, sqrtRatioBX96] = [sqrtRatioBX96, sqrtRatioAX96];
    }
    return roundUp
      ? (0, basic_1.mulDivRoundingUp)(
          liquidity,
          sqrtRatioBX96.sub(sqrtRatioAX96),
          constants_1.Q96
        )
      : sqrtRatioBX96.sub(sqrtRatioAX96).mul(liquidity).div(constants_1.Q96);
  }
  static getNextSqrtPriceFromDeltaBase(sqrtPX96, liquidity, amount, isLong) {
    (0, utils_1.solidityRequire)(sqrtPX96.gt(constants_1.ZERO));
    (0, utils_1.solidityRequire)(liquidity.gt(constants_1.ZERO));
    return this.getNextSqrtPriceFromAmount0RoundingUp(
      sqrtPX96,
      liquidity,
      amount,
      !isLong
    );
  }
  static getNextSqrtPriceFromInput(sqrtPX96, liquidity, amountIn, zeroForOne) {
    (0, utils_1.solidityRequire)(sqrtPX96.gt(constants_1.ZERO));
    (0, utils_1.solidityRequire)(liquidity.gt(constants_1.ZERO));
    return zeroForOne
      ? this.getNextSqrtPriceFromAmount0RoundingUp(
          sqrtPX96,
          liquidity,
          amountIn,
          true
        )
      : this.getNextSqrtPriceFromAmount1RoundingDown(
          sqrtPX96,
          liquidity,
          amountIn,
          true
        );
  }
  static getNextSqrtPriceFromOutput(
    sqrtPX96,
    liquidity,
    amountOut,
    zeroForOne
  ) {
    (0, utils_1.solidityRequire)(sqrtPX96.gt(constants_1.ZERO));
    (0, utils_1.solidityRequire)(liquidity.gt(constants_1.ZERO));
    return zeroForOne
      ? this.getNextSqrtPriceFromAmount1RoundingDown(
          sqrtPX96,
          liquidity,
          amountOut,
          false
        )
      : this.getNextSqrtPriceFromAmount0RoundingUp(
          sqrtPX96,
          liquidity,
          amountOut,
          false
        );
  }
  static getLiquidityFromMargin(
    sqrtEntryPX96,
    sqrtUpperPX96,
    entryMargin,
    initialMarginRatio
  ) {
    (0, utils_1.solidityRequire)(sqrtEntryPX96.gt(constants_1.ZERO));
    (0, utils_1.solidityRequire)(sqrtUpperPX96.gt(constants_1.ZERO));
    const numerator1 = entryMargin.mul(sqrtUpperPX96);
    const numerator2 = sqrtEntryPX96;
    const denominator1 = sqrtUpperPX96.sub(sqrtEntryPX96);
    let temp = numerator1.mul(numerator2).div(denominator1);
    temp = temp.mul(constants_1.Q96).div(sqrtUpperPX96);
    const denominator2 = (0, basic_1.wmulUp)(
      sqrtUpperPX96,
      (0, basic_1.r2w)(initialMarginRatio + 10000)
    ).sub(sqrtEntryPX96);
    return temp.div(denominator2);
  }
  static getNextSqrtPriceFromAmount0RoundingUp(
    sqrtPX96,
    liquidity,
    amount,
    add
  ) {
    if (amount.eq(constants_1.ZERO)) return sqrtPX96;
    const numerator1 = liquidity.shl(96);
    if (add) {
      const product = (0, basic_1.multiplyIn256)(amount, sqrtPX96);
      if (product.div(amount).eq(sqrtPX96)) {
        const denominator = (0, basic_1.addIn256)(numerator1, product);
        if (denominator.gte(numerator1)) {
          return (0, basic_1.mulDivRoundingUp)(
            numerator1,
            sqrtPX96,
            denominator
          );
        }
      }
      return (0, basic_1.mulDivRoundingUp)(
        numerator1,
        constants_1.ONE,
        numerator1.div(sqrtPX96).add(amount)
      );
    } else {
      const product = (0, basic_1.multiplyIn256)(amount, sqrtPX96);
      (0, utils_1.solidityRequire)(product.div(amount).eq(sqrtPX96));
      (0, utils_1.solidityRequire)(numerator1.gt(product));
      return (0, basic_1.mulDivRoundingUp)(
        numerator1,
        sqrtPX96,
        numerator1.sub(product)
      );
    }
  }
  static getNextSqrtPriceFromAmount1RoundingDown(
    sqrtPX96,
    liquidity,
    amount,
    add
  ) {
    if (add) {
      const quotient = amount.lte(constants_1.MAX_UINT_160)
        ? amount.shl(96).div(liquidity)
        : amount.mul(constants_1.Q96).div(liquidity);
      return sqrtPX96.add(quotient);
    } else {
      const quotient = (0, basic_1.mulDivRoundingUp)(
        amount,
        constants_1.Q96,
        liquidity
      );
      (0, utils_1.solidityRequire)(sqrtPX96.gt(quotient));
      return sqrtPX96.sub(quotient);
    }
  }
  static getStabilityFee(quotation, param) {
    const feePaid = quotation.fee;
    const protocolFeePaid = (0, basic_1.wmulUp)(
      quotation.entryNotional,
      (0, basic_1.r2w)(param.protocolFeeRatio)
    );
    const baseFeePaid = (0, basic_1.wmulUp)(
      quotation.entryNotional,
      (0, basic_1.r2w)(param.tradingFeeRatio)
    );
    let stabilityFee = feePaid.sub(protocolFeePaid).sub(baseFeePaid);
    if (stabilityFee.lt(0)) stabilityFee = constants_1.ZERO;
    return stabilityFee;
  }
  getStabilityFeeRatio(quotation, param, maintenanceMarginRatio) {
    void maintenanceMarginRatio;
    const stabilityFee = SqrtPriceMath.getStabilityFee(quotation, param);
    const ratioTemp = (0, basic_1.wdiv)(stabilityFee, quotation.entryNotional);
    const scaler = ethers_1.BigNumber.from(10).pow(14);
    const ratio = ratioTemp.add(scaler.sub(1)).div(scaler);
    return ratio.toNumber();
  }
}
exports.SqrtPriceMath = SqrtPriceMath;
