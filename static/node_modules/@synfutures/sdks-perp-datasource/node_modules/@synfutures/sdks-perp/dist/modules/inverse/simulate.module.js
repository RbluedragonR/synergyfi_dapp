"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InverseSimulateModule = void 0;
const utils_1 = require("../../utils");
const simulate_module_1 = require("../simulate.module");
function reverseSimulateTradeResult(result) {
  return {
    ...result,
    tradePrice: (0, utils_1.reversePrice)(result.tradePrice),
    postPosition: (0, utils_1.reversePosition)(result.postPosition),
    priceImpact: result.priceImpact.mul(-1),
  };
}
class InverseSimulateModule extends simulate_module_1.SimulateModule {
  async simulateCrossMarketOrder(param, overrides) {
    const isInverse = await this.context.perp.configuration.isInverse(
      param.tradeInfo.instrumentAddr
    );
    const result = await super.simulateCrossMarketOrder(
      isInverse
        ? {
            ...param,
            tradeInfo: (0, utils_1.isPosition)(param.tradeInfo)
              ? (0, utils_1.reversePosition)(param.tradeInfo)
              : param.tradeInfo,
            priceInfo: (0, utils_1.reversePriceInfo)(param.priceInfo),
            side: (0, utils_1.reverseSide)(param.side),
            instrument:
              param.instrument &&
              (0, utils_1.reverseInstrument)(param.instrument),
          }
        : param,
      overrides
    );
    return isInverse
      ? {
          ...result,
          tradeSimulation: reverseSimulateTradeResult(result.tradeSimulation),
        }
      : result;
  }
  async simulateLimitOrder(param, overrides) {
    const isInverse = await this.context.perp.configuration.isInverse(
      param.tradeInfo.instrumentAddr
    );
    return await super.simulateLimitOrder(
      isInverse
        ? {
            ...param,
            priceInfo: (0, utils_1.reversePriceInfo)(param.priceInfo),
            side: (0, utils_1.reverseSide)(param.side),
            instrument:
              param.instrument &&
              (0, utils_1.reverseInstrument)(param.instrument),
          }
        : param,
      overrides
    );
  }
  async simulateScaledLimitOrder(param, overrides) {
    const isInverse = await this.context.perp.configuration.isInverse(
      param.tradeInfo.instrumentAddr
    );
    let result = await super.simulateScaledLimitOrder(
      isInverse
        ? {
            ...param,
            priceInfo: param.priceInfo.map((p) =>
              typeof p === "number" ? p : (0, utils_1.reversePrice)(p)
            ),
            side: (0, utils_1.reverseSide)(param.side),
            instrument:
              param.instrument &&
              (0, utils_1.reverseInstrument)(param.instrument),
          }
        : param,
      overrides
    );
    if (isInverse) {
      result = {
        ...result,
        orders: result.orders.map((o) => {
          return (
            o && {
              ...o,
              limitPrice: (0, utils_1.reversePrice)(o.limitPrice),
            }
          );
        }),
      };
    }
    return result;
  }
  async simulateMarketOrderByMargin(param, overrides) {
    const isInverse = await this.context.perp.configuration.isInverse(
      param.tradeInfo.instrumentAddr
    );
    const result = await super.simulateMarketOrderByMargin(
      isInverse
        ? {
            ...param,
            tradeInfo: (0, utils_1.isPosition)(param.tradeInfo)
              ? (0, utils_1.reversePosition)(param.tradeInfo)
              : param.tradeInfo,
            side: (0, utils_1.reverseSide)(param.side),
            instrument:
              param.instrument &&
              (0, utils_1.reverseInstrument)(param.instrument),
          }
        : param,
      overrides
    );
    return isInverse ? reverseSimulateTradeResult(result) : result;
  }
  async simulateMarketOrderByLeverage(param, overrides) {
    const isInverse = await this.context.perp.configuration.isInverse(
      param.tradeInfo.instrumentAddr
    );
    const result = await super.simulateMarketOrderByLeverage(
      isInverse
        ? {
            ...param,
            tradeInfo: (0, utils_1.isPosition)(param.tradeInfo)
              ? (0, utils_1.reversePosition)(param.tradeInfo)
              : param.tradeInfo,
            side: (0, utils_1.reverseSide)(param.side),
            instrument:
              param.instrument &&
              (0, utils_1.reverseInstrument)(param.instrument),
          }
        : param,
      overrides
    );
    return isInverse ? reverseSimulateTradeResult(result) : result;
  }
  async simulateClose(param, overrides) {
    const isInverse = await this.context.perp.configuration.isInverse(
      param.tradeInfo.instrumentAddr
    );
    const result = await super.simulateClose(
      isInverse
        ? {
            ...param,
            tradeInfo: (0, utils_1.isPosition)(param.tradeInfo)
              ? (0, utils_1.reversePosition)(param.tradeInfo)
              : param.tradeInfo,
            instrument:
              param.instrument &&
              (0, utils_1.reverseInstrument)(param.instrument),
          }
        : param,
      overrides
    );
    return isInverse ? reverseSimulateTradeResult(result) : result;
  }
  async simulateAdjustMarginByMargin(param, overrides) {
    const isInverse = await this.context.perp.configuration.isInverse(
      param.tradeInfo.instrumentAddr
    );
    const result = await super.simulateAdjustMarginByMargin(
      isInverse
        ? {
            ...param,
            tradeInfo: (0, utils_1.isPosition)(param.tradeInfo)
              ? (0, utils_1.reversePosition)(param.tradeInfo)
              : param.tradeInfo,
            instrument:
              param.instrument &&
              (0, utils_1.reverseInstrument)(param.instrument),
          }
        : param,
      overrides
    );
    return isInverse
      ? {
          ...result,
          postPosition: (0, utils_1.reversePosition)(result.postPosition),
        }
      : result;
  }
  async simulateAdjustMarginByLeverage(param, overrides) {
    const isInverse = await this.context.perp.configuration.isInverse(
      param.tradeInfo.instrumentAddr
    );
    const result = await super.simulateAdjustMarginByLeverage(
      isInverse
        ? {
            ...param,
            tradeInfo: (0, utils_1.isPosition)(param.tradeInfo)
              ? (0, utils_1.reversePosition)(param.tradeInfo)
              : param.tradeInfo,
            instrument:
              param.instrument &&
              (0, utils_1.reverseInstrument)(param.instrument),
          }
        : param,
      overrides
    );
    return isInverse
      ? {
          ...result,
          postPosition: (0, utils_1.reversePosition)(result.postPosition),
        }
      : result;
  }
  async simulateAddLiquidity(param, overrides) {
    const isInverse = (0, utils_1.isInstrument)(param.instrument)
      ? await this.context.perp.configuration.isInverse(
          param.instrument.instrumentAddr
        )
      : await this.context.perp.configuration.isInverseByIdentifier(
          param.instrument
        );
    const result = await super.simulateAddLiquidity(
      isInverse
        ? {
            ...param,
            instrument: (0, utils_1.isInstrument)(param.instrument)
              ? (0, utils_1.reverseInstrument)(param.instrument)
              : param.instrument,
          }
        : param,
      overrides
    );
    return isInverse
      ? {
          ...result,
          upperPrice: (0, utils_1.reversePrice)(result.lowerPrice),
          lowerPrice: (0, utils_1.reversePrice)(result.upperPrice),
          lowerPosition: (0, utils_1.reversePosition)(result.upperPosition),
          lowerLeverage: result.upperLeverage,
          upperPosition: (0, utils_1.reversePosition)(result.lowerPosition),
          upperLeverage: result.lowerLeverage,
        }
      : result;
  }
  async simulateAddLiquidityWithAsymmetricRange(param, overrides) {
    const isInverse = (0, utils_1.isInstrument)(param.instrument)
      ? await this.context.perp.configuration.isInverse(
          param.instrument.instrumentAddr
        )
      : await this.context.perp.configuration.isInverseByIdentifier(
          param.instrument
        );
    const result = await super.simulateAddLiquidityWithAsymmetricRange(
      isInverse
        ? {
            ...param,
            alphaWadLower: param.alphaWadUpper,
            alphaWadUpper: param.alphaWadLower,
            instrument: (0, utils_1.isInstrument)(param.instrument)
              ? (0, utils_1.reverseInstrument)(param.instrument)
              : param.instrument,
          }
        : param,
      overrides
    );
    return isInverse
      ? {
          ...result,
          tickDeltaLower: result.tickDeltaUpper,
          tickDeltaUpper: result.tickDeltaLower,
          upperPrice: (0, utils_1.reversePrice)(result.lowerPrice),
          lowerPrice: (0, utils_1.reversePrice)(result.upperPrice),
          lowerPosition: (0, utils_1.reversePosition)(result.upperPosition),
          lowerLeverage: result.upperLeverage,
          upperPosition: (0, utils_1.reversePosition)(result.lowerPosition),
          upperLeverage: result.lowerLeverage,
          equivalentAlphaLower: result.equivalentAlphaUpper,
          equivalentAlphaUpper: result.equivalentAlphaLower,
        }
      : result;
  }
  async simulateRemoveLiquidity(param, overrides) {
    const isInverse = await this.context.perp.configuration.isInverse(
      param.tradeInfo.instrumentAddr
    );
    const result = await super.simulateRemoveLiquidity(
      isInverse
        ? {
            ...param,
            tradeInfo: (0, utils_1.isPortfolio)(param.tradeInfo)
              ? (0, utils_1.reversePortfolio)(param.tradeInfo)
              : param.tradeInfo,
            tickUpper: param.tickLower,
            tickLower: param.tickUpper,
            instrument:
              param.instrument &&
              (0, utils_1.reverseInstrument)(param.instrument),
          }
        : param,
      overrides
    );
    return isInverse
      ? {
          ...result,
          removedPosition: (0, utils_1.reversePosition)(result.removedPosition),
          postPosition: (0, utils_1.reversePosition)(result.postPosition),
          removedPositionEntryPrice: (0, utils_1.reversePrice)(
            result.removedPositionEntryPrice
          ),
        }
      : result;
  }
}
exports.InverseSimulateModule = InverseSimulateModule;
