"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InstrumentModule = void 0;
const ethers_1 = require("ethers");
const typechain_1 = require("../typechain");
const enum_1 = require("../enum");
const utils_1 = require("../utils");
const constants_1 = require("../constants");
const parser_1 = require("../parser");
const synfError_1 = require("../errors/synfError");
const simulationError_1 = require("../errors/simulationError");
class InstrumentModule {
  constructor(context) {
    this.context = context;
  }
  getInstrumentContract(address, signerOrProvider) {
    return typechain_1.Instrument__factory.connect(
      address,
      signerOrProvider ?? this.context.provider
    );
  }
  async computeInstrumentAddress(instrumentIdentifier) {
    const gateAddress =
      this.context.perp.configuration.config.contractAddress.gate;
    const marketType = instrumentIdentifier.marketType;
    const beaconAddress =
      this.context.perp.configuration.config.contractAddress.market[marketType]
        .beacon;
    const instrumentProxyByteCode =
      this.context.perp.configuration.config.instrumentProxyByteCode;
    const salt = await this.computeInstrumentSalt(instrumentIdentifier);
    return ethers_1.ethers.utils.getCreate2Address(
      gateAddress,
      ethers_1.ethers.utils.keccak256(salt),
      ethers_1.ethers.utils.keccak256(
        ethers_1.ethers.utils.solidityPack(
          ["bytes", "bytes32"],
          [
            instrumentProxyByteCode,
            ethers_1.ethers.utils.hexZeroPad(beaconAddress, 32),
          ]
        )
      )
    );
  }
  async computeInstrumentSalt(instrumentIdentifier) {
    const { baseTokenInfo, quoteTokenInfo } = await (0, utils_1.getTokenInfo)(
      instrumentIdentifier,
      this.context
    );
    const quoteAddress = quoteTokenInfo.address;
    let data;
    if ((0, utils_1.isCexMarket)(instrumentIdentifier.marketType)) {
      const baseSymbol =
        typeof instrumentIdentifier.baseSymbol === "string"
          ? instrumentIdentifier.baseSymbol
          : instrumentIdentifier.baseSymbol.symbol;
      data = ethers_1.ethers.utils.defaultAbiCoder.encode(
        ["string", "string", "address"],
        [instrumentIdentifier.marketType.toString(), baseSymbol, quoteAddress]
      );
    } else {
      data = ethers_1.ethers.utils.defaultAbiCoder.encode(
        ["string", "address", "address"],
        [
          instrumentIdentifier.marketType.toString(),
          baseTokenInfo.address,
          quoteAddress,
        ]
      );
    }
    return data;
  }
  async computeInitData(instrumentIdentifier) {
    const { baseTokenInfo, quoteTokenInfo } = await (0, utils_1.getTokenInfo)(
      instrumentIdentifier,
      this.context
    );
    const quoteAddress = quoteTokenInfo.address;
    let data;
    if ((0, utils_1.isCexMarket)(instrumentIdentifier.marketType)) {
      const baseSymbol =
        typeof instrumentIdentifier.baseSymbol === "string"
          ? instrumentIdentifier.baseSymbol
          : instrumentIdentifier.baseSymbol.symbol;
      data = ethers_1.ethers.utils.defaultAbiCoder.encode(
        ["string", "address"],
        [baseSymbol, quoteAddress]
      );
    } else {
      data = ethers_1.ethers.utils.defaultAbiCoder.encode(
        ["address", "address"],
        [baseTokenInfo.address, quoteAddress]
      );
    }
    return data;
  }
  async donateInsuranceFund(instrumentAddr, expiry, amount, txOptions) {
    const instrument = this.getInstrumentContract(
      instrumentAddr,
      txOptions?.signer
    );
    const unsignedTx = await instrument.populateTransaction.donateInsuranceFund(
      expiry,
      amount,
      (0, utils_1.toPopulatedTxOverrides)(txOptions)
    );
    return this.context.tx.sendTx(unsignedTx, txOptions);
  }
  async fillLimitOrder(param, txOptions) {
    const instrument = this.getInstrumentContract(
      param.instrumentAddr,
      txOptions?.signer
    );
    const unsignedTx = await instrument.populateTransaction.fill(
      (0, utils_1.encodeFillParam)(param),
      (0, utils_1.toPopulatedTxOverrides)(txOptions)
    );
    return this.context.tx.sendTx(unsignedTx, txOptions);
  }
  async adjustMargin(param, txOptions) {
    const sign = param.transferIn ? 1 : -1;
    const instrument = this.getInstrumentContract(
      param.instrumentAddr,
      txOptions?.signer
    );
    const unsignedTx = await instrument.populateTransaction.trade(
      (0, utils_1.encodeAdjustParam)({
        expiry: param.expiry,
        net: param.margin.mul(sign),
        deadline: param.deadline,
        referralCode: param.referralCode ?? constants_1.DEFAULT_REFERRAL_CODE,
      }),
      (0, utils_1.toPopulatedTxOverrides)(txOptions)
    );
    return this.context.tx.sendTx(unsignedTx, txOptions);
  }
  async addLiquidity(param, txOptions) {
    const addParam = {
      expiry: param.expiry,
      tickDeltaLower: param.tickDeltaLower,
      tickDeltaUpper: param.tickDeltaUpper,
      amount: param.margin,
      limitTicks: param.limitTicks,
      deadline: param.deadline,
      referralCode: param.referralCode ?? constants_1.DEFAULT_REFERRAL_CODE,
    };
    let unsignedTx;
    if (typeof param.instrumentAddr !== "string") {
      const gate = this.context.perp.contracts.gate.connect(
        txOptions?.signer || this.context.provider
      );
      const instrumentIdentifier = param.instrumentAddr;
      const instrumentAddress = await this.computeInstrumentAddress(
        instrumentIdentifier
      );
      const indexOfInstrument = await gate.indexOf(
        instrumentAddress,
        (0, utils_1.toPopulatedTxOverrides)(txOptions)
      );
      if (!ethers_1.BigNumber.from(indexOfInstrument).isZero()) {
        throw new synfError_1.SynfError(
          "Instrument exits: " + instrumentAddress
        );
      }
      this.context.registerContractParser(
        instrumentAddress,
        new parser_1.InstrumentParser()
      );
      this.context.registerAddress(
        instrumentAddress,
        instrumentIdentifier.baseSymbol +
          "-" +
          instrumentIdentifier.quoteSymbol +
          "-" +
          instrumentIdentifier.marketType
      );
      unsignedTx = await gate.populateTransaction.launch(
        instrumentIdentifier.marketType,
        instrumentAddress,
        await this.computeInitData(instrumentIdentifier),
        (0, utils_1.encodeAddParam)(addParam),
        (0, utils_1.toPopulatedTxOverrides)(txOptions)
      );
      return this.context.tx.sendTx(unsignedTx, txOptions);
    } else {
      const instrument = this.getInstrumentContract(
        param.instrumentAddr,
        txOptions?.signer
      );
      const unsignedTx = await instrument.populateTransaction.add(
        (0, utils_1.encodeAddParam)(addParam),
        (0, utils_1.toPopulatedTxOverrides)(txOptions)
      );
      return this.context.tx.sendTx(unsignedTx, txOptions);
    }
  }
  async removeLiquidity(param, txOptions) {
    const instrument = this.getInstrumentContract(
      param.instrumentAddr,
      txOptions?.signer
    );
    const unsignedTx = await instrument.populateTransaction.remove(
      (0, utils_1.encodeRemoveParam)(param),
      (0, utils_1.toPopulatedTxOverrides)(txOptions)
    );
    return this.context.tx.sendTx(unsignedTx, txOptions);
  }
  async placeLimitOrder(addLimitOrderParam, txOptions) {
    const sign = (0, utils_1.signOfSide)(addLimitOrderParam.side);
    const param = {
      expiry: addLimitOrderParam.expiry,
      size: addLimitOrderParam.baseSize.mul(sign),
      amount: addLimitOrderParam.margin,
      tick: addLimitOrderParam.tick,
      deadline: addLimitOrderParam.deadline,
    };
    const instrument = this.getInstrumentContract(
      addLimitOrderParam.instrumentAddr,
      txOptions?.signer
    );
    const unsignedTx = await instrument.populateTransaction.place(
      (0, utils_1.encodePlaceParam)({
        expiry: param.expiry,
        size: param.size,
        amount: param.amount,
        tick: param.tick,
        deadline: param.deadline,
        referralCode:
          addLimitOrderParam.referralCode ?? constants_1.DEFAULT_REFERRAL_CODE,
      }),
      (0, utils_1.toPopulatedTxOverrides)(txOptions)
    );
    return this.context.tx.sendTx(unsignedTx, txOptions);
  }
  async placeMarketOrder(param, txOptions) {
    if (param.side === enum_1.Side.FLAT) {
      throw new simulationError_1.SimulationError("Invalid Price");
    }
    const sign = (0, utils_1.signOfSide)(param.side);
    const tradeParam = {
      expiry: param.expiry,
      size: param.baseSize.mul(sign),
      amount: param.margin,
      tick: param.limitTick,
      deadline: param.deadline,
      referralCode: param.referralCode ?? constants_1.DEFAULT_REFERRAL_CODE,
    };
    const instrument = this.getInstrumentContract(
      param.instrumentAddr,
      txOptions?.signer
    );
    const unsignedTx = await instrument.populateTransaction.trade(
      (0, utils_1.encodePlaceParam)(tradeParam),
      (0, utils_1.toPopulatedTxOverrides)(txOptions)
    );
    return this.context.tx.sendTx(unsignedTx, txOptions);
  }
  async cancelLimitOrder(param, txOptions) {
    const instrument = this.getInstrumentContract(
      param.instrumentAddr,
      txOptions?.signer
    );
    const unsignedTx = await instrument.populateTransaction.cancel(
      (0, utils_1.encodeCancelParam)({
        expiry: param.expiry,
        ticks: [param.tick],
        deadline: param.deadline,
      }),
      (0, utils_1.toPopulatedTxOverrides)(txOptions)
    );
    return this.context.tx.sendTx(unsignedTx, txOptions);
  }
  async batchPlaceLimitOrder(param, txOptions) {
    if (param.side === enum_1.Side.FLAT) {
      throw new simulationError_1.SimulationError("Invalid Price");
    }
    const sign = (0, utils_1.signOfSide)(param.side);
    const instrument = this.getInstrumentContract(
      param.instrumentAddr,
      txOptions?.signer
    );
    const unsignedTx = await instrument.populateTransaction.batchPlace(
      (0, utils_1.encodeBatchPlaceParam)(
        param.expiry,
        param.baseSize.mul(sign),
        param.leverage,
        param.ticks,
        param.ratios,
        param.deadline,
        param.referralCode ?? constants_1.DEFAULT_REFERRAL_CODE
      ),
      (0, utils_1.toPopulatedTxOverrides)(txOptions)
    );
    return this.context.tx.sendTx(unsignedTx, txOptions);
  }
  async batchCancelLimitOrder(param, txOptions) {
    const instrument = this.getInstrumentContract(
      param.instrumentAddr,
      txOptions?.signer
    );
    if (param.orderTicks.length <= constants_1.MAX_CANCEL_ORDER_COUNT) {
      const unsignedTx = await instrument.populateTransaction.cancel(
        (0, utils_1.encodeCancelParam)({
          expiry: param.expiry,
          ticks: param.orderTicks,
          deadline: param.deadline,
        }),
        (0, utils_1.toPopulatedTxOverrides)(txOptions)
      );
      return this.context.tx.sendTx(unsignedTx, txOptions);
    } else {
      const tickGroups = [];
      for (
        let i = 0;
        i < param.orderTicks.length;
        i += constants_1.MAX_CANCEL_ORDER_COUNT
      ) {
        tickGroups.push(
          param.orderTicks.slice(i, i + constants_1.MAX_CANCEL_ORDER_COUNT)
        );
      }
      const calldatas = tickGroups.map((group) => {
        return instrument.interface.encodeFunctionData("cancel", [
          (0, utils_1.encodeCancelParam)({
            expiry: param.expiry,
            ticks: group,
            deadline: param.deadline,
          }),
        ]);
      });
      const unsignedTx = await instrument.populateTransaction.multicall(
        calldatas,
        (0, utils_1.toPopulatedTxOverrides)(txOptions)
      );
      return this.context.tx.sendTx(unsignedTx, txOptions);
    }
  }
  async placeCrossMarketOrder(param, txOptions) {
    const sign = (0, utils_1.signOfSide)(param.side);
    const instrument = this.getInstrumentContract(
      param.instrumentAddr,
      txOptions?.signer
    );
    const callData = [];
    callData.push(
      instrument.interface.encodeFunctionData("trade", [
        (0, utils_1.encodeTradeParam)({
          expiry: param.expiry,
          size: param.tradeSize.mul(sign),
          amount: param.tradeMargin,
          limitTick: param.tradeLimitTick,
          deadline: param.deadline,
          referralCode: param.referralCode ?? constants_1.DEFAULT_REFERRAL_CODE,
        }),
      ])
    );
    callData.push(
      instrument.interface.encodeFunctionData("place", [
        (0, utils_1.encodePlaceParam)({
          expiry: param.expiry,
          size: param.orderSize.mul(sign),
          amount: param.orderMargin,
          tick: param.orderTick,
          deadline: param.deadline,
          referralCode: param.referralCode ?? constants_1.DEFAULT_REFERRAL_CODE,
        }),
      ])
    );
    const unsignedTx = await instrument.populateTransaction.multicall(
      callData,
      (0, utils_1.toPopulatedTxOverrides)(txOptions)
    );
    return this.context.tx.sendTx(unsignedTx, txOptions);
  }
  async settle(param, txOptions) {
    const instrument = this.getInstrumentContract(
      param.instrumentAddr,
      txOptions?.signer
    );
    const unsignedTx = await instrument.populateTransaction.settle(
      param.expiry,
      param.target,
      (0, utils_1.toPopulatedTxOverrides)(txOptions)
    );
    return this.context.tx.sendTx(unsignedTx, txOptions);
  }
  async multicall(instrumentAddr, callData, txOptions) {
    const instrument = this.getInstrumentContract(
      instrumentAddr,
      txOptions?.signer
    );
    const unsignedTx = await instrument.populateTransaction.multicall(
      callData,
      (0, utils_1.toPopulatedTxOverrides)(txOptions)
    );
    return this.context.tx.sendTx(unsignedTx, txOptions);
  }
}
exports.InstrumentModule = InstrumentModule;
