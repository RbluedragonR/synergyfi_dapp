"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.reverseSide = reverseSide;
exports.reversePrice = reversePrice;
exports.reverseOrder = reverseOrder;
exports.reversePosition = reversePosition;
exports.reverseRange = reverseRange;
exports.reversePortfolio = reversePortfolio;
exports.reverseAmm = reverseAmm;
exports.reverseInstrument = reverseInstrument;
exports.reversePriceInfo = reversePriceInfo;
const math_1 = require("../math");
const enum_1 = require("../enum");
function reverseSide(side) {
  return side === enum_1.Side.LONG
    ? enum_1.Side.SHORT
    : side === enum_1.Side.SHORT
    ? enum_1.Side.LONG
    : enum_1.Side.FLAT;
}
function reversePrice(price) {
  return (0, math_1.safeWDiv)(math_1.WAD, price);
}
function reverseOrder(order) {
  return {
    ...order,
    size: order.size.mul(-1),
    side: reverseSide(order.side),
    limitPrice: reversePrice(order.limitPrice),
    isInverse: !order.isInverse,
  };
}
function reversePosition(position) {
  return {
    ...position,
    size: position.size.mul(-1),
    side: reverseSide(position.side),
    entryPrice: reversePrice(position.entryPrice),
    isInverse: !position.isInverse,
  };
}
function reverseRange(range) {
  return {
    ...range,
    tickLower: range.tickUpper,
    tickUpper: range.tickLower,
    lowerPrice: reversePrice(range.upperPrice),
    upperPrice: reversePrice(range.lowerPrice),
    entryPrice: reversePrice(range.entryPrice),
    isInverse: !range.isInverse,
  };
}
function reversePortfolio(portfolio) {
  return {
    ...portfolio,
    orders: new Map(
      Array.from(portfolio.orders.entries()).map(([oid, order]) => [
        oid,
        reverseOrder(order),
      ])
    ),
    ranges: new Map(
      Array.from(portfolio.ranges.entries()).map(([rid, range]) => [
        rid,
        reverseRange(range),
      ])
    ),
    position: reversePosition(portfolio.position),
    isInverse: !portfolio.isInverse,
  };
}
function reverseAmm(amm) {
  return {
    ...amm,
    totalLong: amm.totalShort,
    totalShort: amm.totalLong,
    shortFundingIndex: amm.longFundingIndex,
    longFundingIndex: amm.shortFundingIndex,
    shortSocialLossIndex: amm.longSocialLossIndex,
    longSocialLossIndex: amm.shortSocialLossIndex,
    settlementPrice: reversePrice(amm.settlementPrice),
    markPrice: reversePrice(amm.markPrice),
    fairPrice: reversePrice(amm.fairPrice),
    isInverse: !amm.isInverse,
  };
}
function reverseInstrument(instrument) {
  return {
    ...instrument,
    spotPrice: reversePrice(instrument.spotPrice),
    amms: new Map(
      Array.from(instrument.amms.entries()).map(([expiry, amm]) => [
        expiry,
        reverseAmm(amm),
      ])
    ),
    isInverse: !instrument.isInverse,
    displayBase: instrument.displayQuote,
    displayQuote: instrument.displayBase,
  };
}
function reversePriceInfo(priceInfo) {
  return typeof priceInfo === "number" ? priceInfo : reversePrice(priceInfo);
}
