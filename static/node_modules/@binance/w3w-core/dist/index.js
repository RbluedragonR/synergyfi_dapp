function e(e) {
  if (e === void 0) {
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    );
  }
  return e;
}
function t(e, t, n, s, r, i, o) {
  try {
    var a = e[i](o);
    var c = a.value;
  } catch (e) {
    n(e);
    return;
  }
  if (a.done) {
    t(c);
  } else {
    Promise.resolve(c).then(s, r);
  }
}
function n(e) {
  return function () {
    var n = this,
      s = arguments;
    return new Promise(function (r, i) {
      var o = e.apply(n, s);
      function a(e) {
        t(o, r, i, a, c, "next", e);
      }
      function c(e) {
        t(o, r, i, a, c, "throw", e);
      }
      a(undefined);
    });
  };
}
function s(e, t) {
  if (!(e instanceof t)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function r(e, t) {
  for (var n = 0; n < t.length; n++) {
    var s = t[n];
    s.enumerable = s.enumerable || false;
    s.configurable = true;
    if ("value" in s) s.writable = true;
    Object.defineProperty(e, s.key, s);
  }
}
function i(e, t, n) {
  if (t) r(e.prototype, t);
  if (n) r(e, n);
  return e;
}
function o(e) {
  o = Object.setPrototypeOf
    ? Object.getPrototypeOf
    : function e(e) {
        return e.__proto__ || Object.getPrototypeOf(e);
      };
  return o(e);
}
function a(e, t) {
  if (typeof t !== "function" && t !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  e.prototype = Object.create(t && t.prototype, {
    constructor: { value: e, writable: true, configurable: true },
  });
  if (t) h(e, t);
}
function c(e, t) {
  if (t != null && typeof Symbol !== "undefined" && t[Symbol.hasInstance]) {
    return !!t[Symbol.hasInstance](e);
  } else {
    return e instanceof t;
  }
}
function u(t, n) {
  if (n && (l(n) === "object" || typeof n === "function")) {
    return n;
  }
  return e(t);
}
function h(e, t) {
  h =
    Object.setPrototypeOf ||
    function e(e, t) {
      e.__proto__ = t;
      return e;
    };
  return h(e, t);
}
function l(e) {
  "@swc/helpers - typeof";
  return e && typeof Symbol !== "undefined" && e.constructor === Symbol
    ? "symbol"
    : typeof e;
}
function d() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(
      Reflect.construct(Boolean, [], function () {})
    );
    return true;
  } catch (e) {
    return false;
  }
}
function f(e) {
  var t = d();
  return function n() {
    var n = o(e),
      s;
    if (t) {
      var r = o(this).constructor;
      s = Reflect.construct(n, arguments, r);
    } else {
      s = n.apply(this, arguments);
    }
    return u(this, s);
  };
}
function p(e, t) {
  var n,
    s,
    r,
    i,
    o = {
      label: 0,
      sent: function () {
        if (r[0] & 1) throw r[1];
        return r[1];
      },
      trys: [],
      ops: [],
    };
  return (
    (i = { next: a(0), throw: a(1), return: a(2) }),
    typeof Symbol === "function" &&
      (i[Symbol.iterator] = function () {
        return this;
      }),
    i
  );
  function a(e) {
    return function (t) {
      return c([e, t]);
    };
  }
  function c(i) {
    if (n) throw new TypeError("Generator is already executing.");
    while (o)
      try {
        if (
          ((n = 1),
          s &&
            (r =
              i[0] & 2
                ? s["return"]
                : i[0]
                ? s["throw"] || ((r = s["return"]) && r.call(s), 0)
                : s.next) &&
            !(r = r.call(s, i[1])).done)
        )
          return r;
        if (((s = 0), r)) i = [i[0] & 2, r.value];
        switch (i[0]) {
          case 0:
          case 1:
            r = i;
            break;
          case 4:
            o.label++;
            return { value: i[1], done: false };
          case 5:
            o.label++;
            s = i[1];
            i = [0];
            continue;
          case 7:
            i = o.ops.pop();
            o.trys.pop();
            continue;
          default:
            if (
              !((r = o.trys), (r = r.length > 0 && r[r.length - 1])) &&
              (i[0] === 6 || i[0] === 2)
            ) {
              o = 0;
              continue;
            }
            if (i[0] === 3 && (!r || (i[1] > r[0] && i[1] < r[3]))) {
              o.label = i[1];
              break;
            }
            if (i[0] === 6 && o.label < r[1]) {
              o.label = r[1];
              r = i;
              break;
            }
            if (r && o.label < r[2]) {
              o.label = r[2];
              o.ops.push(i);
              break;
            }
            if (r[2]) o.ops.pop();
            o.trys.pop();
            continue;
        }
        i = t.call(e, o);
      } catch (e) {
        i = [6, e];
        s = 0;
      } finally {
        n = r = 0;
      }
    if (i[0] & 5) throw i[1];
    return { value: i[0] ? i[1] : void 0, done: true };
  }
}
var y = Object.defineProperty;
var v = function (e, t, n) {
  return t in e
    ? y(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n })
    : (e[t] = n);
};
var _ = function (e, t, n) {
  return (
    v(
      e,
      (typeof t === "undefined" ? "undefined" : l(t)) != "symbol" ? t + "" : t,
      n
    ),
    n
  );
};
import m from "@binance/w3w-qrcode-modal";
import { SocketTransport as I } from "@binance/w3w-socket-transport";
import { DisconnectType as k } from "@binance/w3w-types";
import {
  log as g,
  uuid as b,
  encrypt as w,
  decrypt as S,
  MISC_ERR as R,
  RPC_ERROR as E,
  payloadId as T,
  generateKey as C,
  signingMethods as O,
  CONNECTION_ERR as N,
  ProviderRpcError as M,
  getClientMetadata as A,
  convertNumberToHex as P,
  openBinanceDeepLink as D,
  formatJsonRpcRequest as x,
} from "@binance/w3w-utils";
import {
  Events as j,
  convertHexToArrayBuffer as L,
  convertArrayBufferToHex as q,
  getStorage as J,
  removeStorage as B,
  setStorage as G,
  uuid as H,
} from "@binance/w3w-utils";
var Q = "connect-session",
  U = "connect-domains",
  V = "wss://nbstream.binance.com/wallet-connector",
  F = [
    "https://rpc.ankr.com/bsc",
    "https://binance.nodereal.io",
    "https://bscrpc.com",
    "https://bsc-dataseed2.ninicoin.io",
  ];
var W = (function (t) {
    "use strict";
    a(r, t);
    var n = f(r);
    function r() {
      s(this, r);
      var t;
      t = n.call.apply(n, [this].concat(Array.prototype.slice.call(arguments)));
      _(e(t), "pending", !1);
      _(e(t), "callbacks", new Map());
      _(e(t), "clientMeta");
      _(e(t), "relay");
      _(e(t), "_key", null);
      _(e(t), "_clientId", "");
      _(e(t), "_peerId", "");
      _(e(t), "_peerMeta", null);
      _(e(t), "_handshakeId", 0);
      _(e(t), "_handshakeTopic", "");
      _(e(t), "_connected", !1);
      _(e(t), "_accounts", []);
      _(e(t), "_chainId", "0x0");
      return t;
    }
    i(r, [
      {
        key: "key",
        get: function e() {
          return this._key ? q(this._key, !0) : "";
        },
        set: function e(e) {
          if (!e) return;
          var t = L(e);
          this._key = t;
        },
      },
      {
        key: "clientId",
        get: function e() {
          var e = this._clientId;
          return e || (e = this._clientId = H()), this._clientId;
        },
        set: function e(e) {
          e && (this._clientId = e);
        },
      },
      {
        key: "peerId",
        get: function e() {
          return this._peerId;
        },
        set: function e(e) {
          e && (this._peerId = e);
        },
      },
      {
        key: "peerMeta",
        get: function e() {
          return this._peerMeta;
        },
        set: function e(e) {
          this._peerMeta = e;
        },
      },
      {
        key: "handshakeTopic",
        get: function e() {
          return this._handshakeTopic;
        },
        set: function e(e) {
          e && (this._handshakeTopic = e);
        },
      },
      {
        key: "handshakeId",
        get: function e() {
          return this._handshakeId;
        },
        set: function e(e) {
          e && (this._handshakeId = e);
        },
      },
      {
        key: "uri",
        get: function e() {
          return "wc:"
            .concat(this.handshakeTopic, "@1?bridge=")
            .concat(this.relay, "&key=")
            .concat(this.key, "&scene=bid");
        },
      },
      {
        key: "chainId",
        get: function e() {
          return this._chainId;
        },
        set: function e(e) {
          this._chainId = e;
        },
      },
      {
        key: "accounts",
        get: function e() {
          return this._accounts;
        },
        set: function e(e) {
          this._accounts = e;
        },
      },
      {
        key: "connected",
        get: function e() {
          return this._connected;
        },
        set: function e(e) {},
      },
      {
        key: "session",
        get: function e() {
          return {
            connected: this.connected,
            accounts: this.accounts,
            chainId: this.chainId,
            relay: this.relay,
            key: this.key,
            clientId: this.clientId,
            clientMeta: this.clientMeta,
            peerId: this.peerId,
            peerMeta: this.peerMeta,
            handshakeId: this.handshakeId,
            handshakeTopic: this.handshakeTopic,
          };
        },
        set: function e(e) {
          e &&
            ((this._connected = e.connected),
            (this.accounts = e.accounts),
            (this.chainId = e.chainId),
            (this.relay = e.relay),
            (this.key = e.key),
            (this.clientId = e.clientId),
            (this.clientMeta = e.clientMeta),
            (this.peerId = e.peerId),
            (this.peerMeta = e.peerMeta),
            (this.handshakeId = e.handshakeId),
            (this.handshakeTopic = e.handshakeTopic));
        },
      },
    ]);
    return r;
  })(j),
  Y = (function (e) {
    "use strict";
    a(n, e);
    var t = f(n);
    function n() {
      s(this, n);
      return t.apply(this, arguments);
    }
    i(n, [
      {
        key: "getStorageSession",
        value: function e() {
          try {
            return J(Q);
          } catch (e) {}
          return null;
        },
      },
      {
        key: "setStorageSession",
        value: function e() {
          G(Q, this.session);
        },
      },
      {
        key: "removeStorageSession",
        value: function e() {
          B(Q);
        },
      },
      {
        key: "manageStorageSession",
        value: function e() {
          this._connected
            ? this.setStorageSession()
            : this.removeStorageSession();
        },
      },
    ]);
    return n;
  })(W);
import { detectWebSocket as K } from "@binance/w3w-socket-transport";
import {
  isNode as z,
  setStorage as X,
  getStorage as Z,
  removeStorage as $,
} from "@binance/w3w-utils";
import { Interface as ee } from "@ethersproject/abi";
import et from "axios";
import { decode as en } from "js-base64";
function es() {
  return er.apply(this, arguments);
}
function er() {
  er = n(function () {
    var e, t;
    return p(this, function (n) {
      switch (n.label) {
        case 0:
          return [
            4,
            Promise.any(
              F.map(function (e) {
                return et.request({
                  url: e,
                  method: "POST",
                  data: {
                    jsonrpc: "2.0",
                    id: Date.now(),
                    method: "eth_call",
                    params: [
                      {
                        to: "0x76054B318785b588A3164B2A6eA5476F7cBA51e0",
                        data: "0x97b5f450",
                      },
                      "latest",
                    ],
                  },
                });
              })
            ),
          ];
        case 1:
          (e = n.sent()),
            (t = new ee(["function apiDomains() view returns (string)"]));
          return [
            2,
            en(t.decodeFunctionResult("apiDomains", e.data.result)[0]).split(
              ","
            ),
          ];
      }
    });
  });
  return er.apply(this, arguments);
}
function ei(e) {
  return e
    .filter(function (e) {
      return e.ttl > 0;
    })
    .sort(function (e, t) {
      return e.ttl - t.ttl;
    })
    .map(function (e) {
      return e.url;
    });
}
function eo() {
  return ea.apply(this, arguments);
}
function ea() {
  ea = n(function () {
    var e, t;
    return p(this, function (n) {
      switch (n.label) {
        case 0:
          return [4, es()];
        case 1:
          e = n.sent();
          return [
            4,
            Promise.all(
              e.map(function (e) {
                var t = e.split(".").slice(1).join(".");
                return K("wss://nbstream.".concat(t, "/wallet-connector"));
              })
            ),
          ];
        case 2:
          t = n.sent();
          return [2, ei(t)];
      }
    });
  });
  return ea.apply(this, arguments);
}
var ec = Promise.resolve([]);
if (!z()) {
  var eu = Z(U);
  (ec = Promise.resolve(eu)),
    (!eu || eu.length === 0) &&
      (ec = eo()
        .then(function (e) {
          return (
            console.log(
              "\uD83D\uDE80 ~ file: relay.ts:63 ~ .then ~ domains:",
              e
            ),
            X(U, e),
            e
          );
        })
        .catch(function () {
          return [];
        }));
}
function eh() {
  return el.apply(this, arguments);
}
function el() {
  el = n(function () {
    var e;
    return p(this, function (t) {
      switch (t.label) {
        case 0:
          return [4, ec];
        case 1:
          e = t.sent();
          return [2, (e.length === 0 && e.push(V), e)];
      }
    });
  });
  return el.apply(this, arguments);
}
function ed(e) {
  var t = Z(U);
  if (!t) return;
  var n = t.filter(function (t) {
    return t !== e;
  });
  X(U, n);
}
function ef() {
  $(U);
}
import {
  ProviderRpcError as ep,
  RPC_ERROR as ey,
  MISC_ERR as ev,
} from "@binance/w3w-utils";
function e_(e) {
  return e.code === -32050 || e.code === -32e3 || e.code === 1e3
    ? new ep(ey.REJECT_ERR.code, ey.REJECT_ERR.message)
    : e.code === -32603
    ? new ep(ev.INTERNAL_ERR.code, ev.INTERNAL_ERR.message)
    : e.code === -32600 || e.code === -32602
    ? new ep(ey.INVALID_PARAM.code, ey.INVALID_PARAM.message)
    : e;
}
function em(e) {
  var t = e.indexOf("?");
  return t > -1 ? e.slice(0, t) : e;
}
var eI = (function (t) {
  "use strict";
  a(o, t);
  var r = f(o);
  function o() {
    s(this, o);
    var t;
    t = r.call(this);
    _(e(t), "transport");
    _(e(t), "lng");
    t.clientMeta = A();
    var n = t.getStorageSession();
    n && (t.session = n),
      t.handshakeId && t.subscribeToSessionResponse(t.handshakeId),
      t.initTransport(),
      t.subscribeInternalEvent();
    return t;
  }
  i(o, [
    {
      key: "request",
      value: function e(e) {
        var t = this;
        return n(function () {
          return p(this, function (n) {
            if (!t.connected)
              throw new M(
                N.PROVIDER_NOT_READY.code,
                N.PROVIDER_NOT_READY.message
              );
            if (O.indexOf(e.method) < 0)
              throw new M(
                E.METHOD_NOT_SUPPORT.code,
                E.METHOD_NOT_SUPPORT.message
              );
            switch (e.method) {
              case "eth_requestAccounts":
                return [2, t.accounts];
              case "eth_accounts":
                return [2, t.accounts];
              case "eth_chainId":
                return [2, P(t.chainId)];
              case "eth_signTransaction":
              case "eth_sendTransaction":
              case "eth_sign":
              case "personal_sign":
              case "eth_signTypedData":
              case "eth_signTypedData_v1":
              case "eth_signTypedData_v2":
              case "eth_signTypedData_v3":
              case "eth_signTypedData_v4":
              case "wallet_switchEthereumChain":
              case "wallet_watchAsset":
                return [
                  2,
                  new Promise(function (n, s) {
                    e.id || (e.id = T()),
                      t.callbacks.set(
                        "response-".concat(e.id),
                        function (e, t) {
                          e
                            ? s(e_(e))
                            : t
                            ? n(t.result)
                            : s(
                                new M(
                                  E.MISSING_RESPONSE.code,
                                  E.MISSING_RESPONSE.message
                                )
                              );
                        }
                      ),
                      t.sendRequest(e),
                      t.events.emit("call_request_sent");
                  }),
                ];
              default:
                break;
            }
            return [2];
          });
        })();
      },
    },
    {
      key: "killSession",
      value: function e() {
        if (!this.connected) return;
        var e = {
            approved: !1,
            chainId: null,
            networkId: null,
            accounts: null,
          },
          t = { id: T(), method: "wc_sessionUpdate", params: [e] };
        this.sendRequest(t), this.handleSessionDisconnect(k.DisconnectAtClient);
      },
    },
    {
      key: "connect",
      value: function e() {
        var e =
            arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
          t = e.chainId,
          s = e.lng,
          r = e.showQrCodeModal;
        var i = this;
        return n(function () {
          return p(this, function (e) {
            return [
              2,
              ((i.lng = s),
              i.connected
                ? { chainId: i.chainId, accounts: i.accounts }
                : new Promise(function (e, n) {
                    i.on("modal_closed", function (e) {
                      n(e);
                    }),
                      i.on("session_error", function (e) {
                        n(e);
                      }),
                      i.on("connect", function (t) {
                        e(t);
                      }),
                      i.createSession({ chainId: t, showQrCodeModal: r });
                  })),
            ];
          });
        })();
      },
    },
    {
      key: "createSession",
      value: function e(e) {
        var t = e.chainId,
          n = e.showQrCodeModal;
        try {
          if (this.connected)
            throw new M(N.CONNECTED.code, N.CONNECTED.message);
          if (this.pending || this._handshakeTopic)
            throw new M(N.CONNECTING.code, N.CONNECTING.message);
          (this.pending = !0),
            (this._key = C()),
            (this.handshakeId = T()),
            (this.handshakeTopic = b());
          var s = {
            id: this.handshakeId,
            method: "wc_sessionRequest",
            params: [
              {
                peerId: this.clientId,
                peerMeta: this.clientMeta,
                chainId: t ? Number(t) : null,
              },
            ],
          };
          this.sendRequest(s, this.handshakeTopic),
            this.subscribeToSessionResponse(this.handshakeId),
            this.events.emit("display_uri", { showQrCodeModal: n });
        } catch (e) {
          this.pending = !1;
          var r = "response-".concat(this.handshakeId);
          this.callbacks.get(r) && this.callbacks.delete(r);
          var i = e.message,
            o = c(e, M)
              ? e
              : new M(
                  R.INTERNAL_ERR.code,
                  "".concat(R.INTERNAL_ERR.message, ": ").concat(i)
                );
          throw (
            (this.handleRejectSessionConnection(o),
            g.error("[binance-w3w] create connection failed: ".concat(i)),
            o)
          );
        }
      },
    },
    {
      key: "initTransport",
      value: function e() {
        var e = this;
        return n(function () {
          var t, n, s, r;
          return p(this, function (i) {
            switch (i.label) {
              case 0:
                (e.transport = new I({
                  version: 1,
                  subscriptions: [e.clientId],
                })),
                  e.transport.on("message", function (t) {
                    return e.setIncomingMessages(t);
                  }),
                  e.transport.on("open", function (t) {
                    e.events.emit("transport_open", t);
                  }),
                  e.transport.on("close", function () {
                    e.events.emit("transport_close");
                  }),
                  e.transport.on("error", function (t, n) {
                    e.events.emit("transport_error", t, n);
                  });
                i.label = 1;
              case 1:
                i.trys.push([1, 5, , 6]);
                if (!e.session.relay) return [3, 2];
                e.transport.open([e.session.relay]);
                return [3, 4];
              case 2:
                return [4, eh()];
              case 3:
                t = i.sent();
                e.transport.open(t);
                i.label = 4;
              case 4:
                return [3, 6];
              case 5:
                n = i.sent();
                ef();
                (s = n.message),
                  (r = new M(
                    R.INTERNAL_ERR.code,
                    "".concat(R.INTERNAL_ERR.message, ": ").concat(s)
                  ));
                throw (e.handleRejectSessionConnection(r), r);
              case 6:
                return [2];
            }
          });
        })();
      },
    },
    {
      key: "setIncomingMessages",
      value: function e(e) {
        if (![this.clientId, this.handshakeTopic].includes(e.topic)) return;
        var t;
        try {
          t = JSON.parse(e.payload);
        } catch (e) {
          return;
        }
        var n = this.decrypt(t);
        if (!n) return;
        if ("method" in n && n.method) {
          this.events.emit(n.method, null, n);
          return;
        }
        var s = n.id,
          r = "response-".concat(s),
          i = this.callbacks.get(r);
        if (i) {
          if ("error" in n && n.error) {
            var o = new M(n.error.code, n.error.message);
            i(o, null);
          } else "result" in n && n.result && i(null, n);
          this.callbacks.delete(r);
        } else g.error("[binance-w3w] callback id: ".concat(s, " not found"));
      },
    },
    {
      key: "encrypt",
      value: function e(e) {
        var t = this._key;
        return t ? w(e, t) : null;
      },
    },
    {
      key: "decrypt",
      value: function e(e) {
        var t = this._key;
        return t ? S(e, t) : null;
      },
    },
    {
      key: "sendRequest",
      value: function e(e, t) {
        var n = x(e.method, e.params, e.id),
          s = this.encrypt(n),
          r = t || this.peerId,
          i = JSON.stringify(s);
        this.transport.send(i, r, !0);
      },
    },
    {
      key: "subscribeInternalEvent",
      value: function e() {
        var e = this;
        this.on("display_uri", function (t) {
          var n = t.showQrCodeModal;
          n !== !1 &&
            (m.open({
              cb: function () {
                e.events.emit(
                  "modal_closed",
                  new M(N.CLOSE_MODAL.code, N.CLOSE_MODAL.message)
                );
              },
              lng: e.lng,
            }),
            e.transport.connected
              ? (e.events.emit("uri_ready", e.uri), e.key && m.ready(e.uri))
              : e.transport.retryFailed && m.fail());
        }),
          this.on("transport_open", function (t) {
            (e.relay = t),
              e.events.emit("uri_ready", e.uri),
              e.key && m.ready(e.uri);
          }),
          this.on("transport_error", function (e, t) {
            t ? ed(em(t)) : (ef(), m.fail());
          }),
          this.on("modal_closed", function () {
            var t = "response-".concat(e.handshakeId);
            e.callbacks.get(t) && e.callbacks.delete(t),
              e.clearConnectionStatus();
          }),
          this.on("connect", function () {
            (e.pending = !1), m.close();
          }),
          this.on("call_request_sent", function () {
            D();
          }),
          this.on("wc_sessionUpdate", function (t, n) {
            if (t) {
              e.handleSessionResponse();
              return;
            }
            n.params && Array.isArray(n.params)
              ? e.handleSessionResponse(n.params[0])
              : n.error && e.handleSessionResponse();
          });
      },
    },
    {
      key: "subscribeToSessionResponse",
      value: function e(e) {
        var t = this;
        this.callbacks.set("response-".concat(e), function (e, n) {
          if (e) {
            t.handleSessionResponse();
            return;
          }
          n &&
            (n.result
              ? t.handleSessionResponse(n.result)
              : n.error && n.error.message
              ? t.handleSessionResponse()
              : t.handleSessionResponse());
        });
      },
    },
    {
      key: "handleSessionResponse",
      value: function e(e) {
        e
          ? e.approved
            ? (this._connected
                ? (e.chainId && this.setChainId(e.chainId),
                  e.accounts && this.setAddress(e.accounts))
                : ((this._connected = !0),
                  e.chainId && this.setChainId(e.chainId),
                  e.accounts && this.setAddress(e.accounts),
                  e.peerId && !this.peerId && (this.peerId = e.peerId),
                  e.peerMeta && !this.peerMeta && (this.peerMeta = e.peerMeta),
                  this.events.emit("connect", {
                    chainId: this.chainId,
                    accounts: this.accounts,
                  })),
              this.manageStorageSession())
            : this.connected
            ? this.handleSessionDisconnect(k.DisconnectAtWallet)
            : this.handleRejectSessionConnection(
                new M(N.REJECT_SESSION.code, N.REJECT_SESSION.message)
              )
          : this.handleRejectSessionConnection(
              new M(N.REJECT_SESSION.code, N.REJECT_SESSION.message)
            );
      },
    },
    {
      key: "handleRejectSessionConnection",
      value: function e(e) {
        m.close(),
          this.clearConnectionStatus(),
          this.events.emit("session_error", e);
      },
    },
    {
      key: "handleSessionDisconnect",
      value: function e(e) {
        this._connected || m.close(),
          this.events.emit("disconnect", e),
          this.clearConnectionStatus();
      },
    },
    {
      key: "clearConnectionStatus",
      value: function e() {
        this._connected && (this._connected = !1),
          this._handshakeId && (this._handshakeId = 0),
          this._handshakeTopic && (this._handshakeTopic = ""),
          this._peerId && (this._peerId = ""),
          this._clientId && (this._clientId = ""),
          this.pending && (this.pending = !1),
          this.callbacks.clear(),
          (this._peerMeta = null),
          (this._accounts = []),
          (this._chainId = "0x0"),
          this.offConnectEvents(),
          this.removeStorageSession(),
          this.transport.close();
      },
    },
    {
      key: "offConnectEvents",
      value: function e() {
        this.removeListener("connect");
      },
    },
    {
      key: "setChainId",
      value: function e(e) {
        var t = P(e);
        if (t === "0x0") {
          this.chainId = t;
          return;
        }
        l(this.chainId) < "u" &&
          this.chainId !== t &&
          this.events.emit("chainChanged", t),
          (this.chainId = t);
      },
    },
    {
      key: "setAddress",
      value: function e() {
        var e =
          arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
        var t = e
          .filter(function (e) {
            return typeof e == "string";
          })
          .map(function (e) {
            return e.toLowerCase();
          })
          .filter(Boolean);
        JSON.stringify(this.accounts) !== JSON.stringify(t) &&
          this.events.emit("accountsChanged", t),
          (this.accounts = t);
      },
    },
  ]);
  return o;
})(Y);
export { eI as Core };
