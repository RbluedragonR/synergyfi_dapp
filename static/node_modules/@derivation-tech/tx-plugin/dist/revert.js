"use strict";
var __importDefault =
  (this && this.__importDefault) ||
  function (mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRevertReason = getRevertReason;
exports.extractRevertData = extractRevertData;
exports.decodeRevertData = decodeRevertData;
exports.parseServerError = parseServerError;
const ethers_1 = require("ethers");
const async_retry_1 = __importDefault(require("async-retry"));
const context_1 = require("@derivation-tech/context");
async function getRevertReason(
  provider,
  txHashOrResponse,
  abis = [],
  logger = context_1.LoggerFactory.getLogger("Revert")
) {
  try {
    if (typeof txHashOrResponse === "string") {
      txHashOrResponse = await (0, async_retry_1.default)(async () => {
        return provider.getTransaction(txHashOrResponse);
      }, context_1.DEFAULT_RETRY_OPTION);
    }
    if (!txHashOrResponse) {
      logger.error("transaction response is null, try again later");
      return undefined;
    }
    let codeOrMsg;
    await (0, async_retry_1.default)(async () => {
      try {
        codeOrMsg = await extractRevertData(provider, txHashOrResponse);
      } catch (e) {
        if (
          (e.code === "SERVER_ERROR" && e.reason === "missing response") ||
          e.code === "TIMEOUT"
        ) {
          throw e;
        }
        const err = parseServerError(e.error ? e.error : e, abis);
        return err.msg;
      }
    }, context_1.DEFAULT_RETRY_OPTION);
    for (const abi of abis) {
      try {
        return abi.parseError(codeOrMsg);
      } catch (parseErr) {}
    }
    const reason =
      codeOrMsg && codeOrMsg.startsWith("0x")
        ? decodeRevertData(codeOrMsg)
        : codeOrMsg;
    return reason;
  } catch (err) {
    logger.error(err);
    throw new Error("Unable to decode revert reason.");
  }
}
async function extractRevertData(provider, response) {
  const request = {};
  Object.assign(request, response);
  if (request.type === 2) {
    request.gasPrice = undefined;
  } else {
    request.maxFeePerGas = undefined;
    request.maxPriorityFeePerGas = undefined;
  }
  return await provider.call(request, response.blockNumber);
}
function decodeRevertData(code) {
  let codeString;
  codeString = `0x${code.substr(138)}`.replace(/0+$/, "");
  if (codeString.length % 2 === 1) {
    codeString += "0";
  }
  return ethers_1.ethers.utils.toUtf8String(codeString);
}
function parseServerError(e, abis = []) {
  let reason = e.reason;
  let desc;
  if (e.error && e.error.data && e.error.data.message) {
    reason = e.error.data.message;
  }
  if (e.body) {
    const body = JSON.parse(e.body);
    if (body.error && body.error.message) {
      reason = body.error.message;
    }
    if (body.error && body.error.data) {
      for (const abi of abis) {
        try {
          desc = abi.parseError(body.error.data);
          break;
        } catch (parseErr) {}
      }
    }
  }
  if (e.error && e.error.data) {
    for (const abi of abis) {
      try {
        desc = abi.parseError(e.error.data);
        break;
      } catch (parseErr) {}
    }
  }
  return {
    raw: e,
    code: e.code,
    msg: reason,
    description: desc,
    transaction: e.transaction,
  };
}
