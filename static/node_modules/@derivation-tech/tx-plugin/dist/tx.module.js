"use strict";
var __importDefault =
  (this && this.__importDefault) ||
  function (mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
Object.defineProperty(exports, "__esModule", { value: true });
exports.TxModule = void 0;
const ethers_1 = require("ethers");
const context_1 = require("@derivation-tech/context");
const context_2 = require("@derivation-tech/context");
const context_3 = require("@derivation-tech/context");
const utils_1 = require("ethers/lib/utils");
const revert_1 = require("./revert");
const chalk_1 = __importDefault(require("chalk"));
const constants_1 = require("./constants");
class TxModule {
  constructor(core, option = constants_1.DEFAULT_CALL_OPTION) {
    this.core = core;
    this.option = {
      ...constants_1.DEFAULT_CALL_OPTION,
      ...option,
    };
  }
  async sendTx(rawTx, txOptions) {
    const ptx = { ...rawTx };
    if (txOptions?.enableGasPrice ?? this.option?.enableGasPrice) {
      let gasPriceOverrides;
      if (
        !txOptions?.gasPrice &&
        !txOptions?.maxPriorityFeePerGas &&
        !txOptions?.maxFeePerGas
      ) {
        gasPriceOverrides = await this.getGasPrice(
          undefined,
          txOptions?.gasPriceMultiple ?? this.option?.gasPriceMultiple
        );
      } else {
        gasPriceOverrides = txOptions;
      }
      if (gasPriceOverrides.gasPrice) {
        ptx.gasPrice = ethers_1.ethers.BigNumber.from(
          await gasPriceOverrides.gasPrice
        );
      }
      if (gasPriceOverrides.maxPriorityFeePerGas) {
        ptx.maxPriorityFeePerGas = ethers_1.ethers.BigNumber.from(
          await gasPriceOverrides.maxPriorityFeePerGas
        );
      }
      if (gasPriceOverrides.maxFeePerGas) {
        ptx.maxFeePerGas = ethers_1.ethers.BigNumber.from(
          await gasPriceOverrides.maxFeePerGas
        );
      }
    }
    if (!txOptions?.disableGasLimit && !this.option?.disableGasLimit) {
      if (!txOptions?.gasLimit) {
        let gasLimit = await this.provider.estimateGas({
          from: txOptions?.from ?? (await txOptions?.signer?.getAddress()),
          ...rawTx,
        });
        const gasLimitMultiple =
          txOptions?.gasLimitMultiple ?? this.option?.gasLimitMultiple;
        if (gasLimitMultiple) {
          gasLimit = gasLimit.mul(Math.ceil(gasLimitMultiple * 100)).div(100);
        }
        ptx.gasLimit = gasLimit;
      } else {
        ptx.gasLimit = ethers_1.ethers.BigNumber.from(await txOptions.gasLimit);
      }
    }
    if (txOptions?.nonce) {
      ptx.nonce = ethers_1.ethers.BigNumber.from(
        await txOptions.nonce
      ).toNumber();
    }
    if (txOptions?.type !== undefined) {
      ptx.type = ethers_1.ethers.BigNumber.from(
        await txOptions.type
      ).toNumber();
    }
    if (txOptions?.accessList) {
      ptx.accessList = ethers_1.ethers.utils.accessListify(
        txOptions.accessList
      );
    }
    if (txOptions?.customData) {
      ptx.customData = txOptions.customData;
    }
    if (txOptions?.ccipReadEnabled !== undefined) {
      ptx.ccipReadEnabled = txOptions.ccipReadEnabled;
    }
    if (!txOptions?.signer) {
      return ptx;
    }
    return await this._sendTx(txOptions.signer, ptx);
  }
  async _sendTx(signer, rawTx) {
    let response;
    try {
      rawTx = await rawTx;
      rawTx.from = await signer.getAddress();
      await this.handleRequest(rawTx);
      if (
        this.option.estimateGas &&
        !rawTx.maxFeePerGas &&
        !rawTx.maxPriorityFeePerGas &&
        !rawTx.gasPrice
      ) {
        const gasOption = await this.option.gasEstimator.getGasPrice(
          this.chainId,
          this.provider,
          this.info.defaultTxType,
          this.option.gasPriceMultiple
        );
        rawTx = this.setGasPrice(rawTx, gasOption);
      }
      rawTx = await this.setGasLimit(signer, rawTx);
      response = await signer.sendTransaction(rawTx);
      if (!this.option.waitReceipt) {
        return response;
      }
      await this.handleResponse(response);
      const receipt = await this.provider.waitForTransaction(
        response.hash,
        1,
        this.option.waitTimeout * 1000
      );
      if (receipt.status === 0) {
        throw {
          code: ethers_1.ethers.errors.CALL_EXCEPTION,
          reason: "transaction failed",
          transactionHash: receipt.transactionHash,
          receipt: receipt,
        };
      }
      await this.handleReceipt(receipt, rawTx.gasLimit);
      return receipt;
    } catch (err) {
      this.logger.error("sendTx exception:", err);
      const error = await this.normalizeError(err);
      error.response = response;
      error.transactionHash = err.transactionHash;
      throw error;
    }
  }
  async send2Txs(signers, rawTxs) {
    if (rawTxs.length != 2) throw new Error("txs length should be 2");
    return this.batchSendTxs(signers, rawTxs);
  }
  async batchSendTxs(signers, rawTxs) {
    if (signers.length != rawTxs.length)
      throw new Error("signers and txs length mismatched!");
    try {
      const _rawTxs = await Promise.all(
        rawTxs.map(async (rawTx) => await rawTx)
      );
      await Promise.all(
        _rawTxs.map(async (rawTx, i) => {
          rawTx.from = await signers[i].getAddress();
          return await this.handleRequest(rawTx);
        })
      );
      const needsGasPrice = _rawTxs
        .map(
          (rawTx) =>
            !rawTx.maxFeePerGas &&
            !rawTx.maxPriorityFeePerGas &&
            !rawTx.gasPrice
        )
        .reduce((a, b) => a || b, false);
      if (this.option.estimateGas && needsGasPrice) {
        const gasOption = await this.option.gasEstimator.getGasPrice(
          this.chainId,
          this.provider,
          this.info.defaultTxType,
          this.option.gasPriceMultiple
        );
        _rawTxs.forEach(
          (rawTx, i) => (_rawTxs[i] = this.setGasPrice(rawTx, gasOption))
        );
      }
      for (let i = 0; i < _rawTxs.length; i++) {
        _rawTxs[i] = await this.setGasLimit(signers[i], _rawTxs[i]);
      }
      signers.forEach((signer) => signer._checkProvider("sendTransaction"));
      const txs = await Promise.all(
        _rawTxs.map(
          async (rawTx, i) => await signers[i].populateTransaction(rawTx)
        )
      );
      const nonceMap = new Map();
      for (let i = 0; i < txs.length; i++) {
        const signerAddress = await signers[i].getAddress();
        if (!nonceMap.has(signerAddress)) {
          nonceMap.set(
            signerAddress,
            await signers[i].provider?.getTransactionCount(signerAddress)
          );
        }
        txs[i].nonce = ethers_1.ethers.BigNumber.from(
          nonceMap.get(signerAddress)
        );
        nonceMap.set(signerAddress, nonceMap.get(signerAddress) + 1);
      }
      const signedTxs = await Promise.all(
        txs.map(async (tx, i) => await signers[i].signTransaction(tx))
      );
      const responses = await Promise.all(
        signedTxs.map(
          async (tx, i) => await signers[i].provider?.sendTransaction(tx)
        )
      );
      const validResponses = responses.filter((r) => r !== undefined);
      if (!this.option.waitReceipt) {
        return validResponses;
      }
      await Promise.all(
        validResponses.map(async (r) => await this.handleResponse(r))
      );
      const receipts = await Promise.all(
        validResponses.map(
          async (response) =>
            await this.provider.waitForTransaction(
              response.hash,
              1,
              this.option.waitTimeout * 1000
            )
        )
      );
      const errors = receipts
        .filter((r) => r.status === 0)
        .map((r) => {
          return {
            code: ethers_1.ethers.errors.CALL_EXCEPTION,
            reason: "transaction failed",
            transactionHash: r.transactionHash,
            receipt: r,
          };
        });
      if (errors.length > 0) throw errors;
      await Promise.all(
        receipts.map(
          async (receipt, i) =>
            await this.handleReceipt(receipt, (await rawTxs[i]).gasLimit)
        )
      );
      return receipts;
    } catch (errs) {
      const _errs = Array.isArray(errs) ? errs : [errs];
      const errors = await Promise.all(
        _errs.map(async (err) => await this.normalizeError(err))
      );
      errors.forEach((error, i) => {
        this.logger.error("sendTx exception:", _errs[i], error);
      });
      throw errors;
    }
  }
  async getGasPrice(txType = this.info.defaultTxType, scale = 1.1) {
    return this.option.gasEstimator.getGasPrice(
      this.chainId,
      this.provider,
      txType,
      scale
    );
  }
  async handleRequest(rawTx) {
    try {
      const signerName = this.core.getAddressName(rawTx.from);
      if (rawTx.data === undefined) {
        this.logger.info(
          context_3.PREFIX,
          "  request",
          context_2.RIGHT_ARROW,
          chalk_1.default.magenta(this.chainName.toUpperCase()),
          `[${signerName}]${rawTx.from} -> [${this.core.getAddressName(
            rawTx.to
          )}]${rawTx.to}`,
          chalk_1.default.blue((0, utils_1.formatEther)(rawTx.value)) +
            " " +
            this.info.nativeToken.symbol
        );
        return;
      }
      const isDeployment = rawTx.to === null;
      const contractAddr = isDeployment
        ? (0, utils_1.getContractAddress)({
            from: rawTx.from,
            nonce: rawTx.nonce,
          })
        : rawTx.to;
      const parser = this.core.getContractParser(contractAddr);
      if (!parser) {
        return;
      }
      const parsedContractAddr = await parser.parseAddress(contractAddr);
      let parsed;
      if (isDeployment) {
        parsed = [
          await parser.parseDeployment({
            data: rawTx.data,
            value: rawTx.value,
          }),
        ];
        this.logger.info(
          context_3.PREFIX,
          "deploying",
          context_2.RIGHT_ARROW,
          chalk_1.default.magenta(this.chainName.toUpperCase()),
          "contract:",
          parsedContractAddr
        );
      } else {
        parsed = await parser.parseTransaction({
          data: rawTx.data,
          value: rawTx.value,
        });
      }
      if (parsed.length === 1) {
        const idx = parsed[0].indexOf("(");
        this.logger.info(
          context_3.PREFIX,
          "  request",
          context_2.RIGHT_ARROW,
          chalk_1.default.magenta(this.chainName.toUpperCase()),
          `[${signerName}]${rawTx.from}`,
          chalk_1.default.green(
            parsedContractAddr + "::" + parsed[0].substring(0, idx)
          ) + parsed[0].substring(idx)
        );
      } else {
        this.logger.info(
          context_3.PREFIX,
          "  request",
          context_2.RIGHT_ARROW,
          chalk_1.default.magenta(this.chainName.toUpperCase()),
          `[${signerName}]${rawTx.from}`,
          chalk_1.default.green(parsedContractAddr + "::" + "multicall")
        );
        for (let i = 0; i < parsed.length; i++) {
          const idx = parsed[i].indexOf("(");
          this.logger.info(
            context_1.PREFIX_SUB,
            chalk_1.default.green(
              `[subcall-${i}]:` + parsed[i].substring(0, idx)
            ) + parsed[i].substring(idx)
          );
        }
      }
    } catch (err) {
      this.logger.error("handleRequest exception:", err);
    }
  }
  async handleResponse(response) {
    try {
      const overrides = this.formatOverrides({
        gasLimit: response.gasLimit,
        maxPriorityFeePerGas: response.maxPriorityFeePerGas,
        maxFeePerGas: response.maxFeePerGas,
        gasPrice: response.gasPrice,
        type: response.type,
        nonce: response.nonce,
        value: response.value,
      });
      this.logger.info(
        context_3.PREFIX,
        "submitted",
        context_2.RIGHT_ARROW,
        chalk_1.default.magenta(this.chainName.toUpperCase()),
        "txHash:",
        this.core.getExplorerTxLink(response.hash) + ",",
        overrides
      );
    } catch (err) {
      this.logger.error("handleResponse exception:", err);
    }
  }
  static getTransactionFee(receipt) {
    if (receipt.effectiveGasPrice && receipt.gasUsed) {
      const gasPrice = Number(
        ethers_1.ethers.utils.formatUnits(receipt.effectiveGasPrice, "gwei")
      );
      const gasUsed = Number(receipt.gasUsed);
      return Number(
        ethers_1.ethers.utils.formatUnits(
          (gasPrice * gasUsed).toFixed(0),
          "gwei"
        )
      );
    } else {
      return 0;
    }
  }
  async handleReceipt(receipt, gasLimit) {
    const isDeployment = receipt.contractAddress !== null;
    try {
      const fee = TxModule.getTransactionFee(receipt);
      const percentage = gasLimit
        ? "(" +
          ((Number(receipt.gasUsed) * 100) / Number(gasLimit)).toFixed(2) +
          "%)"
        : "";
      this.logger.info(
        context_3.PREFIX,
        "   minted",
        context_2.RIGHT_ARROW,
        chalk_1.default.magenta(this.chainName.toUpperCase()),
        "blockNumber:",
        receipt.blockNumber + ",",
        "confirmations:",
        receipt.confirmations + ",",
        "gasUsed:",
        receipt.gasUsed.toString() + `${percentage},`,
        "gasPrice:",
        this.formatGas(receipt.effectiveGasPrice) + "Gwei,",
        ...(this.info.isOpSdkCompatible
          ? [
              "l1GasUsed:",
              receipt.l1GasUsed.toString() + ",",
              "l1GasPrice:",
              this.formatGas(receipt.l1GasPrice) + "Gwei,",
              "l1 tx fee:",
              Number((0, utils_1.formatEther)(receipt.l1Fee)).toFixed(6) + ",",
              "l2 tx fee:",
              fee.toFixed(6) + ",",
              "total tx fee:",
              (fee + Number((0, utils_1.formatEther)(receipt.l1Fee))).toFixed(
                6
              ),
            ]
          : ["tx fee:", fee.toFixed(6)])
      );
      if (isDeployment) {
        const parser = this.core.getContractParser(receipt.contractAddress);
        const parsedContractAddr = parser
          ? await parser.parseAddress(receipt.contractAddress)
          : receipt.contractAddress;
        this.logger.info(
          context_3.PREFIX,
          " deployed",
          context_2.RIGHT_ARROW,
          chalk_1.default.magenta(this.chainName.toUpperCase()),
          "contract:",
          parsedContractAddr
        );
      }
      const printRawLog = (log) => {
        const addr =
          "[" + this.core.getAddressName(log.address) + "]" + log.address;
        this.logger.info(
          context_3.PREFIX,
          "raw event",
          context_2.RIGHT_ARROW,
          chalk_1.default.cyan("#" + log.logIndex, addr),
          "data:",
          log.data,
          "topics:",
          log.topics
        );
      };
      for (const log of receipt.logs) {
        const parser = this.core.getContractParser(log.address);
        if (!parser) {
          printRawLog(log);
          continue;
        }
        let event;
        try {
          event = parser.interface.parseLog(log);
        } catch (err) {
          printRawLog(log);
          continue;
        }
        const parsedEvent = await parser.parseEvent(event);
        const idx = parsedEvent.indexOf("(");
        this.logger.info(
          context_3.PREFIX,
          "    event",
          context_2.RIGHT_ARROW,
          chalk_1.default.cyan(
            "#" + log.logIndex,
            (await parser.parseAddress(log.address)) +
              "-" +
              parsedEvent.substring(0, idx)
          ) + parsedEvent.substring(idx)
        );
      }
    } catch (err) {
      this.logger.error("handleReceipt exception:", err);
    }
  }
  async setGasLimit(signer, tx) {
    if (!tx.gasLimit) {
      const estimatedGas = await signer.estimateGas(tx);
      const scaler = tx.data ? this.option.gasLimitMultiple : 1;
      const gasLimit = estimatedGas.toNumber() * scaler;
      tx.gasLimit = ethers_1.ethers.BigNumber.from(gasLimit.toFixed(0));
    }
    return tx;
  }
  setGasPrice(tx, gasOption) {
    if (gasOption.gasPrice) {
      tx.gasPrice = gasOption.gasPrice;
    } else {
      tx.maxFeePerGas = gasOption.maxFeePerGas;
      tx.maxPriorityFeePerGas = gasOption.maxPriorityFeePerGas;
    }
    return tx;
  }
  formatOverrides(overrides) {
    if (!overrides) {
      return "";
    }
    const data = {
      nonce: overrides.nonce ? overrides.nonce.toString() : undefined,
      type: overrides.type ? overrides.type.toString() : undefined,
      value: overrides.value
        ? ethers_1.ethers.utils.formatUnits(overrides.value, "ether")
        : undefined,
      maxPriorityFee: this.formatGas(overrides.maxPriorityFeePerGas),
      maxFee: this.formatGas(overrides.maxFeePerGas),
      gasPrice: this.formatGas(overrides.gasPrice),
      gasLimit: overrides.gasLimit ? overrides.gasLimit.toString() : undefined,
    };
    let str = "";
    for (const key of Object.keys(data)) {
      if (!data[key]) {
        continue;
      }
      if (key === "value" && Number(data[key]) === 0) {
        continue;
      }
      str += `${key}: ` + data[key] + ", ";
    }
    str = str.slice(0, -2);
    return str;
  }
  formatGas(gasPrice) {
    return gasPrice
      ? Number(ethers_1.ethers.utils.formatUnits(gasPrice, "gwei")).toFixed(6)
      : "";
  }
  async normalizeError(e) {
    try {
      if (!e.code) {
        return { raw: e, code: e.name, msg: e.message };
      }
      switch (e.code) {
        case ethers_1.ethers.errors.CALL_EXCEPTION: {
          if (!e.receipt) {
            return { raw: e, code: e.code, msg: e.reason };
          }
          const abis = this.core.getContractParser(e.receipt?.to)
            ? [this.core.getContractParser(e.receipt?.to)?.interface].filter(
                (i) => i !== undefined
              )
            : [];
          const ret = await (0, revert_1.getRevertReason)(
            this.provider,
            e.receipt.transactionHash,
            abis
          );
          if (!ret) {
            return { raw: e, code: e.code, msg: e.message, receipt: e.receipt };
          }
          if (typeof ret === "string") {
            return { raw: e, code: e.code, msg: ret, receipt: e.receipt };
          }
          const parser = this.core.getContractParser(e.receipt?.to);
          const msg = await parser.parseError(ret);
          return {
            raw: e,
            code: e.code,
            msg: msg,
            description: ret,
            receipt: e.receipt,
          };
        }
        case "SERVER_ERROR": {
          return (0, revert_1.parseServerError)(e, []);
        }
        case "UNPREDICTABLE_GAS_LIMIT": {
          const parser =
            e.transaction && e.transaction.to
              ? this.core.getContractParser(e.transaction.to)
              : undefined;
          const abis = parser ? [parser.interface] : [];
          const ret = (0, revert_1.parseServerError)(e.error, abis);
          ret.code = e.code;
          ret.transaction = e.transaction;
          ret.msg =
            parser && ret.description
              ? e.reason + ": " + (await parser.parseError(ret.description))
              : ret.msg;
          return ret;
        }
        default: {
          return {
            raw: e,
            code: e.code,
            msg: e.reason,
            receipt: e.receipt,
            transaction: e.transaction,
          };
        }
      }
    } catch (err) {
      this.logger.error("normalizeError exception:", err);
      return e;
    }
  }
  get parsers() {
    return this.core.parsers;
  }
  get chainId() {
    return this.core.chainId;
  }
  get provider() {
    return this.core.provider;
  }
  get tokenInfo() {
    return this.core.tokenInfo;
  }
  get logger() {
    return this.core.logger;
  }
  get chainName() {
    return this.core.chainName;
  }
  get info() {
    return this.core.info;
  }
}
exports.TxModule = TxModule;
