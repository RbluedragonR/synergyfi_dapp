"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AcrossModule = void 0;
const tx_plugin_1 = require("@derivation-tech/tx-plugin");
const ethers_1 = require("ethers");
const constants_1 = require("./constants");
const typechain_1 = require("./typechain");
const context_1 = require("@derivation-tech/context");
const context_2 = require("@derivation-tech/context");
class AcrossModule {
  constructor(ctx) {
    this.ctx = ctx;
  }
  async getSuggestedFees(params) {
    const baseUrl = "https://app.across.to/api/suggested-fees";
    const baseParams = new URLSearchParams({
      originChainId: params.originChainId.toString(),
      destinationChainId: params.destinationChainId.toString(),
      token: params.token.toLowerCase(),
      amount: params.amount.toString(),
    });
    if (params.recipient) baseParams.append("recipient", params.recipient);
    if (params.message) baseParams.append("message", params.message);
    const url = `${baseUrl}?${baseParams.toString()}`;
    return await (
      await fetch(url, {
        method: "GET",
      })
    ).json();
  }
  async trackCrosschain(txHashOrReceipt) {
    // listen on V3FundsDeposited event
    const receipt =
      typeof txHashOrReceipt === "string"
        ? await this.ctx.provider.getTransactionReceipt(txHashOrReceipt)
        : txHashOrReceipt;
    const spokePool = typechain_1.SpokePool__factory.connect(
      constants_1.SPOKE_POOL_ADDRESS[this.ctx.chainId],
      this.ctx.provider
    );
    const event = (
      await this.ctx.provider.getLogs({
        address: spokePool.address,
        fromBlock: receipt.blockNumber,
        toBlock: receipt.blockNumber,
      })
    ).find((log) => log.transactionHash === receipt.transactionHash);
    const baseUrl = "https://app.across.to/api/deposit/status";
    const params = new URLSearchParams({
      originChainId: this.ctx.chainId.toString(),
      depositId: ethers_1.BigNumber.from(event.topics[2]).toString(),
    });
    const url = `${baseUrl}?${params.toString()}`;
    const status = await (
      await fetch(url, {
        method: "GET",
      })
    ).json();
    return {
      ...status,
      depositId: Number(status.depositId),
    };
  }
  async crosschain(params, txOptions) {
    const depositor =
      (await txOptions?.signer?.getAddress()) || (await txOptions?.from);
    if (!depositor)
      throw new Error(
        "Depositor not found, please provide a signer or from address"
      );
    const recipient = params.recipient ?? depositor;
    // The 0 address is resolved automatically to the equivalent supported
    // token on the the destination chain. Any other input/output token
    // combination should be advertised by the Across API available-routes
    // endpoint.
    const outputToken = context_2.ZERO_ADDRESS;
    // The outputAmount is set as the inputAmount - relay fees.
    // totalRelayFee.total is returned by the Across API suggested-fees
    // endpoint.
    const outputAmount = params.inputAmount.sub(
      ethers_1.BigNumber.from(params.suggestedFees.totalRelayFee.total)
    );
    // fillDeadline: A fill deadline of 5 hours. Can be up to
    // SpokePool.getCurrentTime() + SpokePool.fillDeadlineBuffer() seconds.
    const spokePool = typechain_1.SpokePool__factory.connect(
      constants_1.SPOKE_POOL_ADDRESS[params.fromChainId],
      this.ctx.provider
    );
    const [currentTimestamp, fillDeadlineBuffer] = await Promise.all([
      spokePool.getCurrentTime(),
      spokePool.fillDeadlineBuffer(),
    ]);
    const fillDeadline = currentTimestamp.add(fillDeadlineBuffer).toNumber();
    // timestamp is returned by the Across API suggested-fees endpoint.
    // This should be _at least 2_ mainnet blocks behind the current time
    // for best service from relayers.
    const quoteTimestamp = params.suggestedFees.timestamp;
    // Exclusive relayer and exclusivity deadline should be taken from the
    // Across API suggested-fees response.
    const exclusivityDeadline = params.suggestedFees.exclusivityDeadline;
    const exclusiveRelayer = params.suggestedFees.exclusiveRelayer;
    // if message is not provided, no action will be executed post-fill on the destination chain.
    const message = params.message ?? "0x";
    this.ctx.registerAddress(spokePool.address, "SpokePool");
    this.ctx.registerContractParser(
      spokePool.address,
      new context_1.ContractParser(spokePool.interface)
    );
    const tx = await spokePool.populateTransaction.depositV3(
      depositor,
      recipient,
      params.inputToken,
      outputToken,
      params.inputAmount,
      outputAmount,
      params.destinationChainId,
      exclusiveRelayer,
      quoteTimestamp,
      fillDeadline,
      exclusivityDeadline,
      message,
      {
        ...(0, tx_plugin_1.toPopulatedTxOverrides)(txOptions),
        from: await txOptions?.from,
      }
    );
    return await this.ctx.tx.sendTx(tx, txOptions);
  }
}
exports.AcrossModule = AcrossModule;
