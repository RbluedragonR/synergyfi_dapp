"use strict";
var __importDefault =
  (this && this.__importDefault) ||
  function (mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
Object.defineProperty(exports, "__esModule", { value: true });
exports.Graph = exports.GRAPH_PAGE_SIZE = void 0;
const async_retry_1 = __importDefault(require("async-retry"));
const logger_1 = require("../logger");
const axios_1 = __importDefault(require("axios"));
exports.GRAPH_PAGE_SIZE = 1000;
class Graph {
  constructor(endpoint, retryOption) {
    this.endpoint = endpoint;
    this._initLogger(retryOption);
    this.retryOption = retryOption ?? {
      retries: 3,
      onRetry: (error) => {
        this.logger.error("subgraph retrying on error:", error);
      },
    };
  }
  _initLogger(option) {
    if (option?.logger) {
      this.logger = option.logger;
      return;
    }
    if (option?.loggerLevel) {
      this.logger = logger_1.LoggerFactory.getLogger(
        "Graph",
        option.loggerLevel
      );
      return;
    }
    this.logger = logger_1.LoggerFactory.getLogger("Graph");
  }
  async query(graphQL, skip, first, lastId = "") {
    const graphql = JSON.stringify({
      query: `${graphQL}`,
      variables: lastId
        ? { first: first, lastID: lastId }
        : { skip: skip, first: first, lastID: lastId },
    });
    return (0, async_retry_1.default)(async () => {
      const response = await axios_1.default.post(this.endpoint, graphql, {
        headers: { "Content-Type": "application/json" },
        timeout: 100000,
      });
      if (!response.data || response.data.errors) {
        this.logger.error("subgraph query error:", response.data);
        throw new Error(
          "subgraph query error" + JSON.stringify(response.data.errors)
        );
      }
      return response.data.data;
    }, this.retryOption);
  }
  async queryAll(
    graphQL,
    pageSize = exports.GRAPH_PAGE_SIZE,
    pageByLastId = false
  ) {
    const result = [];
    let data = await this.query(graphQL, 0, pageSize);
    if (!data) {
      return result;
    }
    const key = Object.keys(data)[0];
    let page = 1;
    this.logger.info(
      this.endpoint,
      "page:",
      page,
      "data-length:",
      data[key].length
    );
    while (data && data[key].length > 0) {
      result.push(...data[key]);
      if (data[key].length < pageSize) {
        break;
      }
      if (pageByLastId) {
        const lastId = data[key][data[key].length - 1].id;
        if (!lastId) {
          throw new Error(
            `pageByLastId is used, while id is missing in GraphQL statement: ${graphQL}`
          );
        }
        data = await this.query(graphQL, pageSize * page, pageSize, lastId);
      } else {
        data = await this.query(graphQL, pageSize * page, pageSize);
      }
      page += 1;
      this.logger.info(
        this.endpoint,
        "page:",
        page,
        "data-length:",
        data[key].length
      );
    }
    return result;
  }
  async getMetaData() {
    const graphQL = `
        {
          _meta{
            block{
              number
            }
            deployment
            hasIndexingErrors
          }
        }`;
    return await this.query(graphQL, 0, exports.GRAPH_PAGE_SIZE);
  }
}
exports.Graph = Graph;
