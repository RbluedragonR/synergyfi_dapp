"use strict";
var __importDefault =
  (this && this.__importDefault) ||
  function (mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatDisplayNumber = formatDisplayNumber;
exports.toBN = toBN;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const ethers_1 = require("ethers");
const CURRENCY_UNITS = ["K", "M", "B", "T"];
const CURRENCY_UNIT_NUM = 10 ** 3;
function formatDisplayNumber({
  num,
  isShowSeparator = true,
  type = "normal",
  isOperateNum = false,
  isShowTBMK = false,
  isShowApproximatelyEqualTo = true,
  showPositive,
  roundingMode = bignumber_js_1.default.ROUND_DOWN,
}) {
  let numBN = toBN(num);
  if (numBN.isNaN() || numBN.eq(Infinity)) {
    numBN = toBN(0);
  }
  let sign = "";
  if (numBN.isNegative()) {
    sign = "-";
    numBN = numBN.abs();
  } else if (showPositive) {
    sign = "+";
  }
  let numStr = numBN.toString(10);
  if (isOperateNum) {
    if (numBN.gte(1)) {
      numStr = numBN.toFixed(4, roundingMode);
    } else {
      numStr = numBN.toPrecision(4, roundingMode);
    }
  } else {
    if (numBN.eq(0)) {
      numStr = numBN.toFixed(4, roundingMode);
    } else if (numBN.gte(10000)) {
      const numRes = numBN.integerValue(roundingMode);
      numStr = numRes.toString();
      if (isShowTBMK) {
        const numRes = getBigCurrencyNum(numBN, "K", roundingMode);
        numStr = numRes.numStr;
      }
    } else if (numBN.gte(1000) && numBN.lt(10000)) {
      if (type === "price") {
        numBN = numBN.precision(5, roundingMode);
        numStr = numBN.toPrecision(5, roundingMode);
      } else {
        const numRes = numBN.precision(5, roundingMode);
        numStr = numRes.toPrecision(5, roundingMode);
        if (isShowTBMK) {
          const numRes = getBigCurrencyNum(numBN, "K", roundingMode);
          numStr = numRes.numStr;
        }
      }
    } else if (numBN.gte(1) && numBN.lt(1000)) {
      numBN = numBN.precision(5, roundingMode);
      numStr = numBN.toPrecision(5, roundingMode);
    } else if (numBN.gte(0.0001) && numBN.lt(1)) {
      if (type === "price") {
        numBN = numBN.precision(5, roundingMode);
        numStr = numBN.toPrecision(5, roundingMode);
      } else {
        numStr = numBN.toFixed(4, roundingMode);
      }
    } else {
      if (type === "price") {
        numBN = numBN.precision(4, roundingMode);
        const decimalPlaces = numBN.decimalPlaces() || 0;
        if (decimalPlaces > 8) {
          numStr = numBN.toFixed(8, roundingMode);
        } else {
          numStr = numBN.toPrecision(4, roundingMode);
        }
      } else {
        if (sign !== "-") {
          return `<0.0001`;
        }
        return `${isShowApproximatelyEqualTo ? "â‰ˆ" : ""}0.0000`;
      }
    }
  }
  if (isShowSeparator) {
    numStr = toCurrencyNumber(numStr);
  }
  return `${sign}${numStr}`;
}
function toBN(value, unit = "normal") {
  let number = value;
  if (unit === "ether" && ethers_1.BigNumber.isBigNumber(value)) {
    number = ethers_1.utils.formatEther(value);
  }
  if (typeof number === "undefined") {
    number = 0;
  }
  return new bignumber_js_1.default(number.toString(10), 10);
}
const toCurrencyNumber = (x) => {
  const parts = x.toString().split(".");
  if (parts.length > 0) {
    parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ",");
    return parts.join(".");
  }
  return "";
};
function getBigCurrencyNum(numBN, unit, roundingMode) {
  if (!roundingMode) roundingMode = bignumber_js_1.default.ROUND_DOWN;
  const i = CURRENCY_UNITS.findIndex((u) => u === unit);
  let numStr = numBN.toString(10);
  numBN = numBN.div(CURRENCY_UNIT_NUM);
  if (numBN.gte(CURRENCY_UNIT_NUM) && unit !== "T") {
    return getBigCurrencyNum(numBN, CURRENCY_UNITS[i + 1]);
  }
  if (unit === "T" && numBN.gte(CURRENCY_UNIT_NUM)) {
    numBN = numBN.integerValue(roundingMode);
  } else {
    numBN = numBN.precision(4, roundingMode);
  }
  numStr = `${numBN.toPrecision(4, roundingMode)}${CURRENCY_UNITS[i]}`;
  return {
    numBN,
    numStr,
  };
}
