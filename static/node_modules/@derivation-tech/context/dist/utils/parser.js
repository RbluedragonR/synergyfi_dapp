"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UniswapV3RouterParser =
  exports.UniswapV3PoolParser =
  exports.UniswapV2RouterParser =
  exports.UniswapV2PairParser =
  exports.Erc20Parser =
  exports.ContractParser =
    void 0;
const ethers_1 = require("ethers");
const abi_1 = require("@ethersproject/abi");
const constant_1 = require("./constant");
const common_1 = require("./common");
const error_1 = require("../error");
class ContractParser {
  constructor(interface_, addressParser) {
    this.interface = interface_;
    this.addressParser = addressParser;
  }
  async _parseBaseParam(description, paramType, value) {
    if (paramType.baseType === "address") {
      return await this.parseAddress(value);
    } else {
      return await this.parseBaseParam(description, paramType, value);
    }
  }
  async parseAddress(value) {
    return this.addressParser
      ? "[" + (await this.addressParser(value)) + "]" + value
      : value;
  }
  async parseBaseParam(description, paramType, value) {
    return value.toString();
  }
  async parseBaseArrayParam(description, paramType, value) {
    let str = "";
    for (let i = 0; i < value.length; i++) {
      str +=
        (await this._parseBaseParam(
          description,
          paramType.arrayChildren,
          value[i]
        )) + ",";
    }
    str = str.slice(0, -1);
    return str;
  }
  async parseParam(description, paramType, value) {
    if (paramType.baseType === "array") {
      let str = paramType.name + ":" + "[";
      if (paramType.components) {
        for (const item of value) {
          str += "(";
          for (const subParamType of paramType.components) {
            str +=
              (await this.parseParam(
                description,
                subParamType,
                item[subParamType.name]
              )) + ", ";
          }
          str = str.slice(0, -2);
          str += "),";
        }
        str = str.slice(0, -1);
      } else {
        str += await this.parseBaseArrayParam(description, paramType, value);
      }
      str += "]";
      return str;
    } else if (paramType.baseType === "tuple") {
      let str = paramType.name + ":" + "(";
      for (const subParamType of paramType.components) {
        str +=
          (await this.parseParam(
            description,
            subParamType,
            value[subParamType.name]
          )) + ", ";
      }
      str = str.slice(0, -2);
      str += ")";
      return str;
    } else {
      return (
        paramType.name +
        ":" +
        (await this._parseBaseParam(description, paramType, value))
      );
    }
  }
  async parseFunction(description) {
    const inputs = [];
    for (let i = 0; i < description.functionFragment.inputs.length; i++) {
      const paramType = description.functionFragment.inputs[i];
      inputs.push(
        `${await this.parseParam(description, paramType, description.args[i])}`
      );
    }
    const value = description.value.gt(0)
      ? `{value: ${ethers_1.ethers.utils.formatEther(description.value)}}`
      : "";
    return `${description.name}(${inputs.join(",")})` + value;
  }
  async parseDeployment(tx) {
    if (!this.deploymentCodeSize) {
      throw new error_1.ContractParserError(
        "deploymentCodeSize is not set. I cannot determine where constructor arguments start"
      );
    }
    const fragment = this.interface.deploy;
    const encodedArgs = ethers_1.ethers.utils.hexDataSlice(
      tx.data,
      this.deploymentCodeSize
    );
    const description = new abi_1.TransactionDescription({
      args: this.interface._abiCoder.decode(fragment.inputs, encodedArgs),
      functionFragment: fragment,
      name: "constructor",
      signature: fragment.format(abi_1.FormatTypes.full),
      sighash: tx.data.substring(0, 10),
      value: ethers_1.BigNumber.from(tx.value || "0"),
    });
    return await this.parseFunction(description);
  }
  async parseEvent(description) {
    const inputs = [];
    for (let i = 0; i < description.eventFragment.inputs.length; i++) {
      const paramType = description.eventFragment.inputs[i];
      inputs.push(
        `${await this.parseParam(description, paramType, description.args[i])}`
      );
    }
    return `${description.eventFragment.name}(${inputs.join(",")})`;
  }
  async parseTransaction(tx) {
    const result = [];
    const description = this.interface.parseTransaction(tx);
    if (!description)
      throw new error_1.ContractParserError(
        `Invalid transaction data ${tx.data.toString()}`
      );
    if (description.name.toLowerCase() === "multicall") {
      for (const subcalldata of description.args.data) {
        result.push(...(await this.parseTransaction({ data: subcalldata })));
      }
    } else {
      result.push(await this.parseFunction(description));
    }
    return result;
  }
  async parseError(description) {
    const inputs = [];
    for (let i = 0; i < description.errorFragment.inputs.length; i++) {
      const paramType = description.errorFragment.inputs[i];
      inputs.push(
        `${await this.parseParam(description, paramType, description.args[i])}`
      );
    }
    return `${description.errorFragment.name}(${inputs.join(",")})`;
  }
}
exports.ContractParser = ContractParser;
class Erc20Parser extends ContractParser {
  constructor(iface, tokenInfo, addressParser) {
    super(iface, addressParser);
    this.tokenInfo = tokenInfo;
  }
  async parseBaseParam(description, paramType, value) {
    switch (paramType.type) {
      case "uint256":
        if (
          (description.name.toLowerCase() === "approve" ||
            description.name.toLowerCase() === "approval") &&
          ethers_1.BigNumber.from(value).gte(constant_1.MAX_UINT256.div(2))
        ) {
          return "MAX";
        }
        return `${(0, common_1.formatUnits)(value, this.tokenInfo.decimals)} ${
          this.tokenInfo.symbol
        }`;
      default:
        return value.toString();
    }
  }
}
exports.Erc20Parser = Erc20Parser;
class UniswapV2PairParser extends ContractParser {
  constructor(iface, tokenATokenInfo, tokenBTokenInfo, addressParser) {
    super(iface, addressParser);
    this.tokenATokenInfo = tokenATokenInfo;
    this.tokenBTokenInfo = tokenBTokenInfo;
    this.tokenAIsToken0 =
      tokenATokenInfo.address.toLowerCase() <
      tokenBTokenInfo.address.toLowerCase();
  }
  async parseEvent(description) {
    const inputs = [];
    for (let i = 0; i < description.eventFragment.inputs.length; i++) {
      const paramType = description.eventFragment.inputs[i];
      if (paramType.name && paramType.name.includes("0")) {
        const input =
          paramType.name +
          "[" +
          (this.tokenAIsToken0
            ? this.tokenATokenInfo.symbol
            : this.tokenBTokenInfo.symbol) +
          "]" +
          ":" +
          this.parseTokenParam(
            paramType,
            description.args[i],
            this.tokenAIsToken0
          );
        inputs.push(input);
        continue;
      } else if (paramType.name && paramType.name.includes("1")) {
        const input =
          paramType.name +
          "[" +
          (this.tokenAIsToken0
            ? this.tokenBTokenInfo.symbol
            : this.tokenATokenInfo.symbol) +
          "]" +
          ":" +
          this.parseTokenParam(
            paramType,
            description.args[i],
            this.tokenAIsToken0
          );
        inputs.push(input);
        continue;
      }
      inputs.push(
        `${await this.parseParam(description, paramType, description.args[i])}`
      );
    }
    return `${description.eventFragment.name}(${inputs.join(",")})`;
  }
  parseTokenParam(paramType, value, tokenAisToken0) {
    switch (paramType.type) {
      case "uint256":
      case "uint112":
        if (paramType.name && paramType.name.includes("0")) {
          return (0, common_1.formatUnits)(
            value,
            tokenAisToken0
              ? this.tokenATokenInfo.decimals
              : this.tokenBTokenInfo.decimals
          );
        } else if (paramType.name && paramType.name.includes("1")) {
          return (0, common_1.formatUnits)(
            value,
            tokenAisToken0
              ? this.tokenBTokenInfo.decimals
              : this.tokenATokenInfo.decimals
          );
        } else {
          return value.toString();
        }
      default:
        return value.toString();
    }
  }
}
exports.UniswapV2PairParser = UniswapV2PairParser;
class UniswapV2RouterParser extends ContractParser {}
exports.UniswapV2RouterParser = UniswapV2RouterParser;
class UniswapV3PoolParser extends ContractParser {
  constructor(iface, tokenATokenInfo, tokenBTokenInfo, addressParser) {
    super(iface, addressParser);
    this.tokenATokenInfo = tokenATokenInfo;
    this.tokenBTokenInfo = tokenBTokenInfo;
    this.tokenAIsToken0 =
      tokenATokenInfo.address.toLowerCase() <
      tokenBTokenInfo.address.toLowerCase();
  }
  async parseEvent(description) {
    const inputs = [];
    for (let i = 0; i < description.eventFragment.inputs.length; i++) {
      const paramType = description.eventFragment.inputs[i];
      if (paramType.name && paramType.name.includes("0")) {
        const input =
          paramType.name +
          "[" +
          (this.tokenAIsToken0
            ? this.tokenATokenInfo.symbol
            : this.tokenBTokenInfo.symbol) +
          "]" +
          ":" +
          this.parseTokenParam(
            paramType,
            description.args[i],
            this.tokenAIsToken0
          );
        inputs.push(input);
        continue;
      } else if (paramType.name && paramType.name.includes("1")) {
        const input =
          paramType.name +
          "[" +
          (this.tokenAIsToken0
            ? this.tokenBTokenInfo.symbol
            : this.tokenATokenInfo.symbol) +
          "]" +
          ":" +
          this.parseTokenParam(
            paramType,
            description.args[i],
            this.tokenAIsToken0
          );
        inputs.push(input);
        continue;
      }
      inputs.push(
        `${await this.parseParam(description, paramType, description.args[i])}`
      );
    }
    return `${description.eventFragment.name}(${inputs.join(",")})`;
  }
  parseTokenParam(paramType, value, tokenAisToken0) {
    switch (paramType.type) {
      case "int256":
        if (paramType.name && paramType.name.includes("0")) {
          return (0, common_1.formatUnits)(
            value,
            tokenAisToken0
              ? this.tokenATokenInfo.decimals
              : this.tokenBTokenInfo.decimals
          );
        } else if (paramType.name && paramType.name.includes("1")) {
          return (0, common_1.formatUnits)(
            value,
            tokenAisToken0
              ? this.tokenBTokenInfo.decimals
              : this.tokenATokenInfo.decimals
          );
        } else {
          return value.toString();
        }
      default:
        return value.toString();
    }
  }
}
exports.UniswapV3PoolParser = UniswapV3PoolParser;
class UniswapV3RouterParser extends ContractParser {}
exports.UniswapV3RouterParser = UniswapV3RouterParser;
