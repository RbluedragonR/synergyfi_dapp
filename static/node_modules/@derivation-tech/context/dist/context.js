"use strict";
var __importDefault =
  (this && this.__importDefault) ||
  function (mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
Object.defineProperty(exports, "__esModule", { value: true });
exports.Context = exports.DEFAULT_OPTION = void 0;
const ethers_1 = require("ethers");
const logger_1 = require("./logger");
const utils_1 = require("./utils");
const chain_1 = require("./chain");
const contracts_1 = require("@derivation-tech/contracts");
const sdk_1 = require("@eth-optimism/sdk");
const utils_2 = require("./utils");
const lodash_1 = require("lodash");
const async_retry_1 = __importDefault(require("async-retry"));
const error_1 = require("./error");
exports.DEFAULT_OPTION = {
  loggerOps: {
    level: logger_1.LogLevel.Info,
  },
};
class Context {
  get chainId() {
    return this.info.chainId;
  }
  get chainName() {
    return this.info.chainName.toLowerCase();
  }
  get nativeToken() {
    return this.info.nativeToken;
  }
  get wrappedNativeToken() {
    return this.info.wrappedNativeToken;
  }
  isNativeToken(symbolOrAddress) {
    if (ethers_1.ethers.utils.isAddress(symbolOrAddress)) {
      return (0, utils_1.isSameAddress)(
        symbolOrAddress,
        this.info.nativeToken.address
      );
    } else if (
      symbolOrAddress.toLowerCase() ===
      this.info.nativeToken.symbol.toLowerCase()
    ) {
      return true;
    }
    return false;
  }
  constructor(chanIdOrName, option = exports.DEFAULT_OPTION) {
    this.initHooks = [];
    this.setProviderHooks = [];
    this.tokenInfo = new Map();
    this.addressToName = new Map();
    this.nameToAddress = new Map();
    this.parsers = new Map();
    const info = (0, chain_1.getChainInfo)(chanIdOrName);
    this._init(info, {
      ...option,
    });
  }
  _init(info, option) {
    this.info = info;
    this._initLogger(option);
    if (option.providerOps?.url) {
      this.setProvider(
        (0, utils_2.getProvider)(
          option.providerOps.url,
          option.providerOps?.receipt?.timeout,
          option.providerOps?.receipt?.pollingInterval
        )
      );
    }
    if (option.providerOps?.wss) {
      this.wssProvider = (0, utils_2.getWssProvider)(
        option.providerOps.wss,
        option.providerOps?.receipt?.pollingInterval
      );
    }
    this.registerTokenInfo(info.nativeToken);
    this.registerTokenInfo(info.wrappedNativeToken);
    info.erc20.forEach((tokenInfo) => {
      this.registerTokenInfo(tokenInfo);
    });
  }
  _initLogger(option) {
    if (option.loggerOps?.logger) {
      this.logger = option.loggerOps.logger;
      return;
    }
    const loggerName = `Context-${this.info.chainName}`;
    if (option.loggerOps?.level) {
      this.logger = logger_1.LoggerFactory.getLogger(
        loggerName,
        option.loggerOps.level
      );
      return;
    }
    this.logger = logger_1.LoggerFactory.getLogger(loggerName);
  }
  async init() {
    for (let i = 0; i < this.initHooks.length; i++) {
      await this.initHooks[i]();
    }
  }
  registerContractParser(address, parser) {
    if (!parser.addressParser) {
      parser.addressParser = async (addr) => this.getAddressName(addr);
    }
    this.parsers.set(address.toLowerCase(), parser);
  }
  getAddressName(address) {
    return this.addressToName.get(address.toLowerCase()) ?? "UNKNOWN";
  }
  registerTokenInfo(tokenInfo) {
    this.tokenInfo.set(tokenInfo.symbol.toLowerCase(), tokenInfo);
    this.tokenInfo.set(tokenInfo.address.toLowerCase(), tokenInfo);
    this.registerAddress(tokenInfo.address, tokenInfo.symbol);
  }
  registerAddress(address, name) {
    this.addressToName.set(address.toLowerCase(), name);
    this.nameToAddress.set(name.toLowerCase(), address);
  }
  setProvider(provider, isOpSdkCompatible) {
    if (!isOpSdkCompatible) {
      this.info.isOpSdkCompatible = false;
    }
    if (provider) {
      this.provider = this.info.isOpSdkCompatible
        ? (0, sdk_1.asL2Provider)(provider)
        : provider;
    }
    this.wrappedNative = contracts_1.WrappedNative__factory.connect(
      this.info.wrappedNativeToken.address,
      this.provider
    );
    this.tokenAssistant = contracts_1.TokenAssistant__factory.connect(
      this.info.tokenAssistant,
      this.provider
    );
    this.multiCall3 = contracts_1.Multicall3__factory.connect(
      this.info.multicall3,
      this.provider
    );
    this.registerContractParser(
      this.wrappedNativeToken.address,
      new utils_2.Erc20Parser(
        this.wrappedNative.interface,
        this.info.wrappedNativeToken
      )
    );
    this.registerContractParser(
      this.info.multicall3,
      new utils_2.ContractParser(this.multiCall3.interface)
    );
    this.registerContractParser(
      this.info.tokenAssistant,
      new utils_2.ContractParser(this.tokenAssistant.interface)
    );
    this.registerAddress(this.info.multicall3, "Multicall3");
    this.registerAddress(this.info.tokenAssistant, "TokenAssistant");
    for (let i = 0; i < this.setProviderHooks.length; i++) {
      this.setProviderHooks[i]();
    }
  }
  getContractParser(address) {
    address = address.toLowerCase();
    let parser = this.parsers.get(address);
    if (parser) return parser;
    const tokenInfo = this.tokenInfo.get(address);
    if (
      tokenInfo &&
      tokenInfo.address !== ethers_1.ethers.constants.AddressZero
    ) {
      parser = new utils_2.Erc20Parser(
        contracts_1.ERC20__factory.createInterface(),
        tokenInfo,
        async (addr) => this.getAddressName(addr)
      );
      this.registerContractParser(address, parser);
    }
    return parser;
  }
  async balanceOfTokenBatch(tokens, targets, batch = 500, overrides) {
    if (tokens.length > batch)
      throw new error_1.ContextCoreError(
        `${tokens.length} exceeds batch size ${batch}`
      );
    const chunks = (0, lodash_1.chunk)(targets, batch / tokens.length);
    overrides =
      overrides && overrides.blockTag
        ? overrides
        : { blockTag: await this.provider.getBlockNumber() };
    const bs = await Promise.all(
      chunks.map((chunk) =>
        this.retry(() =>
          this.tokenAssistant.balanceOfTokenBatch(tokens, chunk, overrides)
        )
      )
    );
    const blockInfo = {
      timestamp: bs[0].blockInfo.timestamp.toNumber(),
      height: bs[0].blockInfo.height.toNumber(),
    };
    const balances = (0, utils_1.transpose)(bs.map((b) => b.balances).flat());
    return { blockInfo, balances };
  }
  async getTokenInfo(symbolOrAddress) {
    let info = this.tokenInfo.get(symbolOrAddress.toLowerCase());
    if (
      info === undefined &&
      ethers_1.ethers.utils.isAddress(symbolOrAddress)
    ) {
      try {
        const results = await this.retry(() =>
          this.tokenAssistant.metaOfTokenBatch([symbolOrAddress])
        );
        info = {
          address: results[0].token,
          name: results[0].name,
          symbol: results[0].symbol,
          decimals: results[0].decimals,
        };
        this.registerTokenInfo(info);
        return info;
      } catch (err) {
        throw new error_1.ContextCoreError(
          `Failed to get token info:  ${symbolOrAddress} ${err.toString()}`
        );
      }
    }
    return info;
  }
  getExplorerTxLink(txHash) {
    return this.info.explorer + "/tx/" + txHash;
  }
  getTokenAssistant() {
    return contracts_1.TokenAssistant__factory.connect(
      this.info.tokenAssistant,
      this.provider
    );
  }
  getMulticall3() {
    return contracts_1.Multicall3__factory.connect(
      this.info.multicall3,
      this.provider
    );
  }
  retry(func, retryOption = utils_1.DEFAULT_RETRY_OPTION) {
    return (0, async_retry_1.default)(func, retryOption);
  }
  use(plugin) {
    plugin.install(this);
    return this;
  }
  addInitHook(func) {
    this.initHooks.push(func);
  }
  addSetProviderHook(func) {
    this.setProviderHooks.push(func);
  }
}
exports.Context = Context;
